// src/index.js
var BRAND = Symbol.for("hyper-async/Async");
var typeOf = (v) => v === null ? "null" : Array.isArray(v) ? "array" : typeof v;
var isAsync = (x) => !!(x && x[BRAND] === true && typeof x.fork === "function");
var Async = (fork) => ({
  [BRAND]: true,
  fork,
  toPromise: () => new Promise((resolve, reject) => {
    let settled = false;
    const ok = (v) => {
      if (settled)
        return;
      settled = true;
      resolve(v);
    };
    const err = (e) => {
      if (settled)
        return;
      settled = true;
      reject(e);
    };
    try {
      fork(err, ok);
    } catch (e) {
      err(e);
    }
  }),
  map: (fn) => {
    if (typeof fn !== "function")
      return Rejected(
        new TypeError(`Async.map expected function, got ${typeOf(fn)}`)
      );
    return Async(
      (rej, res) => fork(rej, (x) => {
        try {
          res(fn(x));
        } catch (e) {
          rej(e);
        }
      })
    );
  },
  bimap: (f, g) => {
    if (typeof f !== "function" || typeof g !== "function")
      return Rejected(
        new TypeError(
          `Async.bimap expected functions, got ${typeOf(f)} and ${typeOf(g)}`
        )
      );
    return Async(
      (rej, res) => fork(
        (x) => {
          try {
            rej(f(x));
          } catch (e) {
            rej(e);
          }
        },
        (x) => {
          try {
            res(g(x));
          } catch (e) {
            rej(e);
          }
        }
      )
    );
  },
  chain: (fn) => {
    if (typeof fn !== "function")
      return Rejected(
        new TypeError(`Async.chain expected function, got ${typeOf(fn)}`)
      );
    return Async(
      (rej, res) => fork(rej, (x) => {
        try {
          const y = fn(x);
          if (!isAsync(y)) {
            rej(
              new TypeError(
                `Async.chain expected function returning Async, got ${typeOf(
                  y
                )}`
              )
            );
            return;
          }
          y.fork(rej, res);
        } catch (e) {
          rej(e);
        }
      })
    );
  },
  bichain: (f, g) => {
    if (typeof f !== "function" || typeof g !== "function")
      return Rejected(
        new TypeError(
          `Async.bichain expected functions, got ${typeOf(f)} and ${typeOf(g)}`
        )
      );
    return Async(
      (rej, res) => fork(
        (x) => {
          try {
            const y = f(x);
            if (!isAsync(y)) {
              rej(
                new TypeError(
                  `Async.bichain expected rejected function returning Async, got ${typeOf(
                    y
                  )}`
                )
              );
              return;
            }
            y.fork(rej, res);
          } catch (e) {
            rej(e);
          }
        },
        (x) => {
          try {
            const y = g(x);
            if (!isAsync(y)) {
              rej(
                new TypeError(
                  `Async.bichain expected resolved function returning Async, got ${typeOf(
                    y
                  )}`
                )
              );
              return;
            }
            y.fork(rej, res);
          } catch (e) {
            rej(e);
          }
        }
      )
    );
  },
  fold: (f, g) => {
    if (typeof f !== "function" || typeof g !== "function")
      return Rejected(
        new TypeError(
          `Async.fold expected functions, got ${typeOf(f)} and ${typeOf(g)}`
        )
      );
    return Async(
      (rej, res) => fork(
        (x) => {
          try {
            const y = f(x);
            if (!isAsync(y)) {
              rej(
                new TypeError(
                  `Async.fold expected rejected function returning Async, got ${typeOf(
                    y
                  )}`
                )
              );
              return;
            }
            y.fork(rej, res);
          } catch (e) {
            rej(e);
          }
        },
        (x) => {
          try {
            const y = g(x);
            if (!isAsync(y)) {
              rej(
                new TypeError(
                  `Async.fold expected resolved function returning Async, got ${typeOf(
                    y
                  )}`
                )
              );
              return;
            }
            y.fork(rej, res);
          } catch (e) {
            rej(e);
          }
        }
      )
    );
  }
});
var of = (x) => Async((rej, res) => res(x));
var Resolved = (x) => Async((rej, res) => res(x));
var Rejected = (x) => Async((rej, res) => rej(x));
var fromPromise = (f) => {
  if (typeof f !== "function") {
    return () => Rejected(
      new TypeError(`Async.fromPromise expected function, got ${typeOf(f)}`)
    );
  }
  return (...args) => Async((rej, res) => {
    let out;
    try {
      out = f(...args);
    } catch (e) {
      rej(e);
      return;
    }
    if (out && typeof out.then === "function") {
      out.then(res, rej);
    } else {
      res(out);
    }
  });
};
var src_default = {
  of,
  fromPromise,
  Resolved,
  Rejected
};
export {
  Rejected,
  Resolved,
  src_default as default,
  fromPromise,
  of
};
