// index.js
var pipe = (...fns) => (i) => fns.reduce((acc, fn) => fn(acc), i);
var defaultTo = (dVal) => (val) => val == null ? dVal : val;
var propOr = (defaultV) => (prop) => pipe(
  (obj) => obj ? obj[prop] : obj,
  defaultTo(defaultV)
);
var mapObject = (fn) => (obj) => {
  const res = {};
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) res[key] = fn(obj[key], key, obj);
  }
  return res;
};
var complement = (fn) => (...args) => !fn(...args);
var findProtocolBoundaries = (protocol) => (tags) => {
  const startIdx = tags.findIndex((t) => t.name === "Data-Protocol" && t.value === protocol);
  if (startIdx === -1) return [0, 0];
  let endIdx = tags.findIndex((t, idx) => idx > startIdx && t.name === "Data-Protocol" && t.value !== protocol);
  if (endIdx === -1) endIdx = tags.length;
  return [startIdx, endIdx];
};
var findFirstProtocolBoundary = (tags) => {
  let idx = tags.findIndex((t) => t.name === "Data-Protocol");
  if (idx === -1) idx = tags.length;
  return idx;
};
var byName = (name) => (t) => t.name === name;
var findAll = (protocol, tags) => pipe(
  findProtocolBoundaries(protocol),
  ([start, end]) => tags.slice(start, end)
)(tags);
var findAllByName = (protocol, name, tags) => pipe(
  (tags2) => findAll(protocol, tags2),
  (pTags) => pTags.filter(byName(name))
)(tags);
var findByName = (protocol, name, tags) => pipe(
  (tags2) => findAllByName(protocol, name, tags2),
  (arr) => arr[0]
)(tags);
var create = (protocol, pTags) => {
  pTags = pTags.filter((t) => t.name !== "Data-Protocol" || t.value !== protocol);
  if (!pTags.length) return [];
  return [
    { name: "Data-Protocol", value: protocol },
    ...pTags
  ];
};
var concat = (protocol, pTags, tags) => {
  const [start, end] = findProtocolBoundaries(protocol)(tags);
  let [before, cur, after] = [
    tags.slice(0, start),
    tags.slice(start, end),
    tags.slice(end)
  ];
  if (!cur.length) {
    pTags = create(protocol, pTags);
    before = after;
    after = [];
  }
  return [before, cur, pTags, after].flat(1);
};
var concatUnassoc = (others, tags) => {
  const idx = findFirstProtocolBoundary(tags);
  const [before, after] = [tags.slice(0, idx), tags.slice(idx)];
  return [before, others, after].flat(1);
};
var update = (protocol, pTags, tags) => {
  const [start, end] = findProtocolBoundaries(protocol)(tags);
  let [before, after] = [tags.slice(0, start), tags.slice(end)];
  if (after.length === tags.length) {
    before = after;
    after = [];
  }
  return [before, create(protocol, pTags), after].flat(1);
};
var removeAll = (protocol, tags) => update(protocol, [], tags);
var removeAllByName = (protocol, name, tags) => {
  const [start, end] = findProtocolBoundaries(protocol)(tags);
  const [before, cur, after] = [tags.slice(0, start), tags.slice(start, end), tags.slice(end)];
  return [before, create(protocol, cur.filter(complement(byName(name)))), after].flat(1);
};
var parseTags = (tags, multi = false) => pipe(
  defaultTo([]),
  /**
   * Mutation is okay here, since it's
   * an internal data structure
   */
  (tags2) => tags2.reduce(
    (parsed, tag) => pipe(
      // [value, value, ...] || []
      propOr([])(tag.name),
      // [value]
      (arr) => {
        arr.push(tag.value);
        return arr;
      },
      // { [name]: [value, value, ...] }
      (arr) => {
        parsed[tag.name] = arr;
        return parsed;
      }
    )(parsed),
    {}
  ),
  mapObject((values) => multi ? values : values[0])
)(tags);
var parseProtocol = (protocol, tags, multi) => pipe(
  defaultTo([]),
  (tags2) => findAll(protocol, tags2),
  (tags2) => parseTags(tags2, multi)
)(tags);
var parseAll = (protocol, tags) => parseProtocol(protocol, tags, true);
var parse = (protocol, tags) => parseProtocol(protocol, tags, false);
var parseUnassoc = (tags) => {
  const idx = findFirstProtocolBoundary(tags);
  return parseTags(tags.slice(0, idx), false);
};
var parseAllUnassoc = (tags) => {
  const idx = findFirstProtocolBoundary(tags);
  return parseTags(tags.slice(0, idx), true);
};
var proto = (p) => ({
  /**
   * @type {import('./types').RemoveFirstArg<findAll>}
   */
  findAll: (tags) => findAll(p, tags),
  /**
   * @type {import('./types').RemoveFirstArg<findAllByName>}
   */
  findAllByName: (name, tags) => findAllByName(p, name, tags),
  /**
   * @type {import('./types').RemoveFirstArg<findByName>}
   */
  findByName: (name, tags) => findByName(p, name, tags),
  /**
   * @type {import('./types').RemoveFirstArg<create>}
   */
  create: (tags) => create(p, tags),
  /**
   * @type {import('./types').RemoveFirstArg<update>}
   */
  update: (pTags, tags) => update(p, pTags, tags),
  /**
   * @type {import('./types').RemoveFirstArg<concat>}
   */
  concat: (pTags, tags) => concat(p, pTags, tags),
  /**
   * @type {import('./types').RemoveFirstArg<removeAll>}
   */
  removeAll: (tags) => removeAll(p, tags),
  /**
   * @type {import('./types').RemoveFirstArg<removeAllByName>}
   */
  removeAllByName: (name, tags) => removeAllByName(p, name, tags),
  /**
   * @type {import('./types').RemoveFirstArg<parse>}
   */
  parse: (tags) => parse(p, tags),
  /**
   * @type {import('./types').RemoveFirstArg<parseAll>}
   */
  parseAll: (tags) => parseAll(p, tags),
  concatUnassoc,
  parseUnassoc,
  parseAllUnassoc
});
export {
  concat,
  concatUnassoc,
  create,
  findAll,
  findAllByName,
  findByName,
  parse,
  parseAll,
  parseAllUnassoc,
  parseUnassoc,
  proto,
  removeAll,
  removeAllByName,
  update
};
