var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.js
var index_exports = {};
__export(index_exports, {
  assign: () => assign,
  connect: () => connect,
  createDataItemSigner: () => createDataItemSigner2,
  createSigner: () => createSigner2,
  dryrun: () => dryrun,
  message: () => message,
  monitor: () => monitor,
  result: () => result,
  results: () => results,
  serializeCron: () => serializeCron,
  spawn: () => spawn,
  unmonitor: () => unmonitor
});
module.exports = __toCommonJS(index_exports);

// src/index.common.js
var import_ao_scheduler_utils = require("@permaweb/ao-scheduler-utils");

// node_modules/hyper-async/dist/index.js
var Async = (fork) => ({
  fork,
  toPromise: () => new Promise((resolve, reject) => fork(reject, resolve)),
  map: (fn) => Async((rej, res) => fork(rej, (x) => res(fn(x)))),
  bimap: (f, g) => Async(
    (rej, res) => fork(
      (x) => rej(f(x)),
      (x) => res(g(x))
    )
  ),
  chain: (fn) => Async((rej, res) => fork(rej, (x) => fn(x).fork(rej, res))),
  bichain: (f, g) => Async(
    (rej, res) => fork(
      (x) => f(x).fork(rej, res),
      (x) => g(x).fork(rej, res)
    )
  ),
  fold: (f, g) => Async(
    (rej, res) => fork(
      (x) => f(x).fork(rej, res),
      (x) => g(x).fork(rej, res)
    )
  )
});
var of = (x) => Async((rej, res) => res(x));
var Resolved = (x) => Async((rej, res) => res(x));
var Rejected = (x) => Async((rej, res) => rej(x));
var fromPromise = (f) => (...args) => Async(
  (rej, res) => f(...args).then(res).catch(rej)
);

// src/client/signer.js
var import_buffer3 = require("buffer/index.js");
var import_base64url4 = __toESM(require("base64url"), 1);
var import_http_message_signatures = require("http-message-signatures");
var import_structured_headers = require("structured-headers");

// src/lib/data-item.js
var import_buffer = require("buffer/index.js");
var import_base64url = __toESM(require("base64url"), 1);
var ArBundles = __toESM(require("@dha-team/arbundles"), 1);
if (!globalThis.Buffer) globalThis.Buffer = import_buffer.Buffer;
var pkg = ArBundles.default ? ArBundles.default : ArBundles;
var { createData, DataItem, SIG_CONFIG } = pkg;
function createDataItemBytes(data, signer, opts) {
  const signerMeta = SIG_CONFIG[signer.type];
  if (!signerMeta) throw new Error(`Metadata for signature type ${signer.type} not found`);
  signerMeta.signatureType = signer.type;
  signerMeta.ownerLength = signerMeta.pubLength;
  signerMeta.signatureLength = signerMeta.sigLength;
  signerMeta.publicKey = signer.publicKey;
  const dataItem = createData(data, signerMeta, opts);
  return dataItem.getRaw();
}
function getSignatureData(dataItemBytes) {
  const dataItem = new DataItem(dataItemBytes);
  return dataItem.getSignatureData();
}
function verify(dataItemBytes) {
  return DataItem.verify(dataItemBytes);
}

// src/client/hb.js
var import_ramda3 = require("ramda");
var import_base64url3 = __toESM(require("base64url"), 1);

// src/lib/utils.js
var import_ramda = require("ramda");
var import_zod = require("zod");
var joinUrl = ({ url, path: path2 }) => {
  if (!path2) return url;
  if (path2.startsWith("/")) return joinUrl({ url, path: path2.slice(1) });
  url = new URL(url);
  url.pathname += path2;
  return url.toString();
};
function parseTags(rawTags) {
  return (0, import_ramda.pipe)(
    (0, import_ramda.defaultTo)([]),
    (0, import_ramda.reduce)(
      (map3, tag) => (0, import_ramda.pipe)(
        // [value, value, ...] || []
        (0, import_ramda.propOr)([], tag.name),
        // [value]
        (0, import_ramda.append)(tag.value),
        // { [name]: [value, value, ...] }
        (0, import_ramda.assoc)(tag.name, import_ramda.__, map3)
      )(map3),
      {}
    ),
    /**
    * If the field is only a singly list, then extract the one value.
    *
    * Otherwise, keep the value as a list.
    */
    (0, import_ramda.map)((values) => values.length > 1 ? values : values[0])
  )(rawTags);
}
function eqOrIncludes(val) {
  return (0, import_ramda.cond)([
    [(0, import_ramda.is)(String), (0, import_ramda.equals)(val)],
    [(0, import_ramda.is)(Array), (0, import_ramda.includes)(val)],
    [import_ramda.T, import_ramda.F]
  ]);
}
function errFrom(err) {
  let e;
  if ((0, import_ramda.is)(import_zod.ZodError, err)) {
    e = new Error(mapZodErr(err));
    e.stack += err.stack;
  } else if ((0, import_ramda.is)(Error, err)) {
    e = err;
  } else if ((0, import_ramda.has)("message", err)) {
    e = new Error(err.message);
  } else if ((0, import_ramda.is)(String, err)) {
    e = new Error(err);
  } else {
    e = new Error("An error occurred");
  }
  return e;
}
function mapZodErr(zodErr) {
  return (0, import_ramda.pipe)(
    (zodErr2) => (
      /**
       * Take a ZodError and flatten it's issues into a single depth array
       */
      function gatherZodIssues(zodErr3, status, contextCode) {
        return (0, import_ramda.reduce)(
          (issues, issue) => (0, import_ramda.pipe)(
            (0, import_ramda.cond)([
              /**
               * These issue codes indicate nested ZodErrors, so we resursively gather those
               * See https://github.com/colinhacks/zod/blob/HEAD/ERROR_HANDLING.md#zodissuecode
               */
              [
                (0, import_ramda.equals)(import_zod.ZodIssueCode.invalid_arguments),
                () => gatherZodIssues(issue.argumentsError, 422, "Invalid Arguments")
              ],
              [
                (0, import_ramda.equals)(import_zod.ZodIssueCode.invalid_return_type),
                () => gatherZodIssues(issue.returnTypeError, 500, "Invalid Return")
              ],
              [
                (0, import_ramda.equals)(import_zod.ZodIssueCode.invalid_union),
                // An array of ZodErrors, so map over and flatten them all
                () => (0, import_ramda.chain)((i) => gatherZodIssues(i, 400, "Invalid Union"), issue.unionErrors)
              ],
              [import_ramda.T, () => [{ ...issue, status, contextCode }]]
            ]),
            (0, import_ramda.concat)(issues)
          )(issue.code),
          [],
          zodErr3.issues
        );
      }(zodErr2, 400, "")
    ),
    /**
     * combine all zod issues into a list of { message, status }
     * summaries of each issue
     */
    (zodIssues) => (0, import_ramda.reduce)(
      (acc, zodIssue) => {
        const { message: message2, path: _path, contextCode: _contextCode } = zodIssue;
        const path2 = _path[1] || _path[0];
        const contextCode = _contextCode ? `${_contextCode} ` : "";
        acc.push(`${contextCode}'${path2}': ${message2}.`);
        return acc;
      },
      [],
      zodIssues
    ),
    (0, import_ramda.join)(" | ")
  )(zodErr);
}

// src/client/hb-encode.js
var import_base64url2 = __toESM(require("base64url"), 1);
var import_buffer2 = require("buffer/index.js");
if (!globalThis.Buffer) globalThis.Buffer = import_buffer2.Buffer;
var MAX_HEADER_LENGTH = 4096;
async function hasNewline(value) {
  if (typeof value === "string") return value.includes("\n");
  if (value instanceof Blob) {
    value = await value.text();
    return value.includes("\n");
  }
  if (isBytes(value)) return Buffer.from(value).includes("\n");
  return false;
}
async function sha256(data) {
  return crypto.subtle.digest("SHA-256", data);
}
function isBytes(value) {
  return value instanceof ArrayBuffer || ArrayBuffer.isView(value);
}
function isPojo(value) {
  return !isBytes(value) && !Array.isArray(value) && !(value instanceof Blob) && typeof value === "object" && value !== null;
}
function hbEncodeValue(value) {
  if (isBytes(value)) {
    if (value.byteLength === 0) return hbEncodeValue("");
    return [void 0, value];
  }
  if (typeof value === "string") {
    if (value.length === 0) return [void 0, "empty-binary"];
    return [void 0, value];
  }
  if (Array.isArray(value)) {
    if (value.length === 0) return ["empty-list", void 0];
    const encoded = value.reduce(
      (acc, cur) => {
        let [type, curEncoded] = hbEncodeValue(cur);
        if (!type) type = "binary";
        acc.push(`(ao-type-${type}) ${curEncoded}`);
        return acc;
      },
      []
    );
    return ["list", encoded.join(",")];
  }
  if (typeof value === "number") {
    if (!Number.isInteger(value)) return ["float", `${value}`];
    return ["integer", `${value}`];
  }
  if (typeof value === "symbol") {
    return ["atom", value.description];
  }
  throw new Error(`Cannot encode value: ${value.toString()}`);
}
function hbEncodeLift(obj, parent = "", top = {}) {
  const [flattened, types] = Object.entries({ ...obj }).reduce((acc, [key, value]) => {
    const flatK = (parent ? `${parent}/${key}` : key).toLowerCase();
    if (value == null) return acc;
    if (Array.isArray(value) && value.some(isPojo)) {
      value = value.reduce((indexedObj, v, idx) => Object.assign(indexedObj, { [idx]: v }), {});
    }
    if (isPojo(value)) {
      hbEncodeLift(value, flatK, top);
      return acc;
    }
    const [type, encoded] = hbEncodeValue(value);
    if (encoded) {
      if (Buffer.from(encoded).byteLength > MAX_HEADER_LENGTH) {
        top[flatK] = encoded;
      } else acc[0][key] = encoded;
    }
    if (type) acc[1][key] = type;
    return acc;
  }, [{}, {}]);
  if (Object.keys(flattened).length === 0) return top;
  if (Object.keys(types).length > 0) {
    const aoTypes = Object.entries(types).map(([key, value]) => `${key.toLowerCase()}=${value}`).join(",");
    if (Buffer.from(aoTypes).byteLength > MAX_HEADER_LENGTH) {
      const flatK = parent ? `${parent}/ao-types` : "ao-types";
      top[flatK] = aoTypes;
    } else flattened["ao-types"] = aoTypes;
  }
  if (parent) top[parent] = flattened;
  else Object.assign(top, flattened);
  return top;
}
function encodePart(name, { headers, body }) {
  const parts = Object.entries(Object.fromEntries(headers)).reduce((acc, [name2, value]) => {
    acc.push(`${name2}: `, value, "\r\n");
    return acc;
  }, [`content-disposition: form-data;name="${name}"\r
`]);
  if (body) parts.push("\r\n", body);
  return new Blob(parts);
}
async function encode(obj = {}) {
  if (Object.keys(obj) === 0) return;
  const flattened = hbEncodeLift(obj);
  const bodyKeys = [];
  const headerKeys = [];
  await Promise.all(
    Object.keys(flattened).map(async (key) => {
      const value = flattened[key];
      if (isPojo(value)) {
        const subPart = await encode(value);
        if (!subPart) return;
        bodyKeys.push(key);
        flattened[key] = encodePart(key, subPart);
        return;
      }
      if (await hasNewline(value) || key.includes("/") || Buffer.from(value).byteLength > MAX_HEADER_LENGTH) {
        bodyKeys.push(key);
        flattened[key] = new Blob([
          `content-disposition: form-data;name="${key}"\r
\r
`,
          value
        ]);
        return;
      }
      headerKeys.push(key);
      flattened[key] = value;
    })
  );
  const h = new Headers();
  headerKeys.forEach((key) => h.append(key, flattened[key]));
  if (h.has("data")) {
    bodyKeys.push("data");
  }
  let body, finalContent;
  if (bodyKeys.length) {
    if (bodyKeys.length === 1) {
      body = new Blob([obj.data]);
      h.append("inline-body-key", bodyKeys[0]);
      h.delete(bodyKeys[0]);
    } else {
      const bodyParts = await Promise.all(
        bodyKeys.map((name) => {
          return flattened[name].arrayBuffer();
        })
      );
      const base = new Blob(
        bodyParts.flatMap((p, i, arr) => i < arr.length - 1 ? [p, "\r\n"] : [p])
      );
      const hash = await sha256(await base.arrayBuffer());
      const boundary = import_base64url2.default.encode(Buffer.from(hash));
      const blobParts = bodyParts.flatMap((p) => [`--${boundary}\r
`, p, "\r\n"]);
      blobParts.push(`--${boundary}--`);
      h.set("Content-Type", `multipart/form-data; boundary="${boundary}"`);
      body = new Blob(blobParts);
    }
    finalContent = await body.arrayBuffer();
    const contentDigest = await sha256(finalContent);
    const base64 = import_base64url2.default.toBase64(import_base64url2.default.encode(contentDigest));
    h.append("Content-Digest", `sha-256=:${base64}:`);
  }
  return { headers: h, body };
}

// src/logger.js
var import_debug = __toESM(require("debug"), 1);
var import_ramda2 = require("ramda");
var createLogger = (name = "@permaweb/aoconnect") => {
  const logger = (0, import_debug.default)(name);
  logger.child = (name2) => createLogger(`${logger.namespace}:${name2}`);
  logger.tap = (note, ...rest) => (0, import_ramda2.tap)((...args) => logger(note, ...rest, ...args));
  return logger;
};
var verboseLog = (...args) => {
  if (process.env.DEBUG) {
    console.log(...args);
  }
};

// src/client/hb.js
var reqFormatCache = {};
function toSigBaseArgs({ url, method, headers, includePath = false }) {
  headers = new Headers(headers);
  return {
    /**
     * Always sign all headers, and the path,
     * and that there is a deterministic signature
     * component ordering
     *
     * TODO: removing path from signing, for now.
     */
    fields: [
      ...headers.keys(),
      ...includePath ? ["@path"] : []
    ].sort(),
    request: { url, method, headers: { ...Object.fromEntries(headers) } }
  };
}
function httpSigName(address) {
  const decoded = import_base64url3.default.toBuffer(address);
  const hexString = [...decoded.subarray(1, 9)].map((byte) => byte.toString(16).padStart(2, "0")).join("");
  return `http-sig-${hexString}`;
}
function requestWith(args) {
  const { fetch: fetch2, logger: _logger, HB_URL, signer } = args;
  let signingFormat = args["signing-format"] || args.signingFormat;
  const logger = _logger.child("request");
  return async function(fields) {
    const { path: path2, method, ...restFields } = fields;
    signingFormat = fields["signing-format"] || fields.signingFormat;
    if (!signingFormat) {
      signingFormat = reqFormatCache[fields.path] ?? "HTTP";
    }
    try {
      let fetch_req = {};
      verboseLog("SIGNING FORMAT: ", signingFormat, ". REQUEST: ", fields);
      if (signingFormat === "ANS-104") {
        const ans104Request = toANS104Request(restFields);
        verboseLog("ANS-104 REQUEST PRE-SIGNING: ", JSON.stringify(ans104Request, null, 2));
        const signedRequest = await toDataItemSigner(signer)(ans104Request.item);
        verboseLog("SIGNED ANS-104 ITEM: ", signedRequest);
        fetch_req = {
          body: signedRequest.raw,
          url: joinUrl({ url: HB_URL, path: path2 }),
          path: path2,
          method,
          headers: ans104Request.headers
        };
      } else {
        const req = await encode(restFields);
        const signingArgs = toSigBaseArgs({
          url: joinUrl({ url: HB_URL, path: path2 }),
          method,
          headers: req.headers
        });
        const signedRequest = await toHttpSigner(signer)(signingArgs);
        fetch_req = { ...signedRequest, body: req.body, path: path2, method };
      }
      verboseLog("Sending signed message to HB: %o");
      const res = await fetch2(fetch_req.url, {
        method: fetch_req.method,
        headers: fetch_req.headers,
        body: fetch_req.body,
        redirect: "follow"
      });
      verboseLog("PUSH FORMAT: ", signingFormat, ". RESPONSE:", res);
      if (res.status === 422 && signingFormat === "HTTP") {
        reqFormatCache[fields.path] = "ANS-104";
        return requestWith({ ...args, signingFormat: "ANS-104" })(fields);
      }
      if (res.status == 500) {
        verboseLog("ERROR RESPONSE: ", res);
        throw new Error(`${res.status}: ${await res.text()}`);
      }
      if (res.status === 404) {
        verboseLog("ERROR RESPONSE: ", res);
        throw new Error(`${res.status}: ${await res.text()}`);
      }
      if (res.status >= 400) {
        logger.tap("ERROR RESPONSE: ", res);
        throw new Error(`${res.status}: ${await res.text()}`);
      }
      if (res.status >= 300) {
        return res;
      }
      let body = await res.text();
      return {
        headers: res.headers,
        body
      };
    } catch (error) {
      verboseLog("ERROR RESPONSE: ", error);
      throw error;
    }
  };
}
function toANS104Request(fields) {
  verboseLog("TO ANS 104 REQUEST: ", fields);
  const dataItem = {
    target: fields.target,
    anchor: fields.anchor ?? "",
    tags: (0, import_ramda3.keys)(
      (0, import_ramda3.omit)(
        [
          "Target",
          "target",
          "Anchor",
          "anchor",
          "Data",
          "data",
          "data-protocol",
          "Data-Protocol",
          "variant",
          "Variant",
          "dryrun",
          "Dryrun",
          "Type",
          "type",
          "path",
          "method",
          "signingFormat",
          "signing-format"
        ],
        fields
      )
    ).map(function(key) {
      return { name: key, value: fields[key] };
    }, fields).concat([
      { name: "data-protocol", value: "ao" },
      { name: "type", value: fields.type ?? "Message" },
      { name: "variant", value: fields.variant ?? "ao.N.1" }
    ]),
    data: fields?.data || ""
  };
  verboseLog("ANS104 REQUEST: ", JSON.stringify(dataItem, null, 2));
  return { headers: {
    "Content-Type": "application/ans104",
    "codec-device": "ans104@1.0",
    "accept-bundle": "true"
  }, item: dataItem };
}

// src/client/signer.js
var { augmentHeaders, createSignatureBase, createSigningParameters, formatSignatureBase } = import_http_message_signatures.httpbis;
if (!globalThis.Buffer) globalThis.Buffer = import_buffer3.Buffer;
var toView = (value) => {
  if (ArrayBuffer.isView(value)) value = Buffer.from(value.buffer, value.byteOffset, value.byteLength);
  else if (typeof value === "string") value = import_base64url4.default.toBuffer(value);
  else throw new Error("Unexpected type. Value must be one of Uint8Array, ArrayBuffer, or base64url-encoded string");
  return value;
};
var DATAITEM_SIGNER_KIND = "ans104";
var HTTP_SIGNER_KIND = "httpsig";
var toDataItemSigner = (signer) => {
  return async ({ data, tags, target, anchor }) => {
    let resolveUnsigned;
    let createCalled;
    const dataToSign = new Promise((resolve) => {
      resolveUnsigned = resolve;
    });
    const create = async (injected) => {
      createCalled = true;
      if (injected.passthrough) return { data, tags, target, anchor };
      const { publicKey, type = 1, alg = "rsa-v1_5-sha256" } = injected;
      const unsigned = createDataItemBytes(
        data,
        { type, publicKey: toView(publicKey) },
        { target, tags, anchor }
      );
      resolveUnsigned(unsigned);
      const deepHash = await getSignatureData(unsigned);
      return deepHash;
    };
    return signer(create, DATAITEM_SIGNER_KIND).then((res) => {
      if (!createCalled) {
        throw new Error("create() must be invoked in order to construct the data to sign");
      }
      if (typeof res === "object" && res.id && res.raw) return res;
      if (!res.signature || !res.signature) {
        throw new Error("signer must return its signature and address");
      }
      const { signature } = res;
      return dataToSign.then((unsigned) => {
        return Promise.resolve(signature).then(toView).then(async (rawSig) => {
          const signedBytes = unsigned;
          signedBytes.set(rawSig, 2);
          const isValid = await verify(signedBytes);
          if (!isValid) throw new Error("Data Item signature is not valid");
          return {
            /**
             * A data item's ID is the base64url encoded
             * SHA-256 of the signature
             */
            id: await crypto.subtle.digest("SHA-256", rawSig).then((raw) => import_base64url4.default.encode(raw)),
            raw: signedBytes
          };
        });
      });
    });
  };
};
var toHttpSigner = (signer) => {
  const params = ["alg", "keyid"].sort();
  return async ({ request, fields }) => {
    let resolveUnsigned;
    let createCalled;
    const httpSig = {};
    const dataToSign = new Promise((resolve) => {
      resolveUnsigned = resolve;
    }).then();
    const create = (injected) => {
      createCalled = true;
      let { publicKey, type = 1, alg = "rsa-pss-sha512" } = injected;
      publicKey = toView(publicKey);
      const signingParameters = createSigningParameters({
        params,
        paramValues: {
          keyid: import_base64url4.default.encode(publicKey),
          alg
        }
      });
      const signatureBase = createSignatureBase({ fields }, request);
      const signatureInput = (0, import_structured_headers.serializeList)([
        [signatureBase.map(([item]) => (0, import_structured_headers.parseItem)(item)), signingParameters]
      ]);
      signatureBase.push(['"@signature-params"', [signatureInput]]);
      const base = formatSignatureBase(signatureBase);
      httpSig.signatureInput = signatureInput;
      httpSig.signatureBase = base;
      const encoded = new TextEncoder().encode(base);
      resolveUnsigned(encoded);
      return encoded;
    };
    return signer(create, HTTP_SIGNER_KIND).then((res) => {
      if (!res.signature || !res.signature) {
        throw new Error("signer must return its signature and address");
      }
      const { signature, address } = res;
      if (!createCalled) {
        throw new Error("create() must be invoked in order to construct the data to sign");
      }
      return dataToSign.then(() => {
        return Promise.resolve(signature).then(toView).then((rawSig) => {
          const withSignature = augmentHeaders(
            request.headers,
            rawSig,
            httpSig.signatureInput,
            httpSigName(address)
          );
          const signedRequest = { ...request, headers: withSignature };
          return signedRequest;
        });
      });
    });
  };
};

// src/client/ao-mu.js
function signDataItemChain(args, logger) {
  return of(args).chain(fromPromise(
    ({ processId, data, tags, anchor, signer }) => toDataItemSigner(signer)({ data, tags, target: processId, anchor })
  )).map(logger.tap("Successfully built and signed data item"));
}
function sendDataItemChain(signedDataItem, { fetch: fetch2, MU_URL: MU_URL2, logger, verifyBeforeSend = false }) {
  let chain2 = of(signedDataItem);
  if (verifyBeforeSend) {
    chain2 = chain2.chain(fromPromise(async (item) => {
      const verified = await verify(item.raw);
      if (!verified) throw new Error("Signed data item verification failed.");
      return item;
    }));
  }
  return chain2.chain(fromPromise(
    async (item) => fetch2(MU_URL2, {
      method: "POST",
      headers: {
        "Content-Type": "application/octet-stream",
        Accept: "application/json"
      },
      redirect: "follow",
      body: item.raw
    })
  )).bichain(
    (err) => {
      if (err.name === "RedirectRequested") {
        return Rejected(err);
      } else {
        return Rejected(new Error(`Error while communicating with MU: ${JSON.stringify(err)}`));
      }
    },
    fromPromise(async (res) => {
      if (res.ok) return res.json();
      throw new Error(`${res.status}: ${await res.text()}`);
    })
  ).bimap(
    logger.tap("Error encountered when writing message via MU"),
    logger.tap("Successfully wrote message via MU")
  ).map((res) => ({ res, messageId: signedDataItem.id }));
}
function deployMessageWith({ fetch: fetch2, MU_URL: MU_URL2, logger: _logger }) {
  const logger = _logger.child("deployMessage");
  return (args) => {
    return signDataItemChain(args, logger).chain((signedDataItem) => sendDataItemChain(signedDataItem, { fetch: fetch2, MU_URL: MU_URL2, logger })).toPromise();
  };
}
function signMessageWith({ logger: _logger }) {
  const logger = _logger.child("signMessage");
  return (args) => {
    return signDataItemChain(args, logger).toPromise();
  };
}
function sendSignedMessageWith({ fetch: fetch2, MU_URL: MU_URL2, logger: _logger }) {
  const logger = _logger.child("sendSignedMessage");
  return (signedDataItem) => {
    return sendDataItemChain(signedDataItem, { fetch: fetch2, MU_URL: MU_URL2, logger, verifyBeforeSend: true }).toPromise();
  };
}
function deployProcessWith({ fetch: fetch2, MU_URL: MU_URL2, logger: _logger }) {
  const logger = _logger.child("deployProcess");
  return (args) => {
    return of(args).chain(
      fromPromise(({ data, tags, signer }) => {
        return toDataItemSigner(signer)({ data, tags });
      })
    ).map(logger.tap("Successfully built and signed data item")).chain(
      (signedDataItem) => of(signedDataItem).chain(
        fromPromise(async (signedDataItem2) => {
          return fetch2(MU_URL2, {
            method: "POST",
            headers: {
              "Content-Type": "application/octet-stream",
              Accept: "application/json"
            },
            redirect: "follow",
            body: signedDataItem2.raw
          });
        })
      ).bichain(
        (err) => Rejected(
          new Error(
            `Error while communicating with MU: ${JSON.stringify(err)}`
          )
        ),
        fromPromise(async (res) => {
          if (res.ok) return res.json();
          throw new Error(`${res.status}: ${await res.text()}`);
        })
      ).bimap(
        logger.tap("Error encountered when deploying process via MU"),
        logger.tap("Successfully deployed process via MU")
      ).map((res) => ({ res, processId: res.processId || signedDataItem.id }))
    ).toPromise();
  };
}
function deployMonitorWith({ fetch: fetch2, MU_URL: MU_URL2, logger: _logger }) {
  const logger = _logger.child("deployMonitor");
  return (args) => of(args).chain(
    fromPromise(
      ({ processId, data, tags, anchor, signer }) => toDataItemSigner(signer)({ data, tags, target: processId, anchor })
    )
  ).map(logger.tap("Successfully built and signed data item")).chain(
    (signedDataItem) => of(signedDataItem).chain(
      fromPromise(
        async (signedDataItem2) => fetch2(MU_URL2 + "/monitor/" + args.processId, {
          method: "POST",
          headers: {
            "Content-Type": "application/octet-stream",
            Accept: "application/json"
          },
          redirect: "follow",
          body: signedDataItem2.raw
        })
      )
    ).bichain(
      (err) => Rejected(
        new Error(
          `Error while communicating with MU: ${JSON.stringify(err)}`
        )
      ),
      fromPromise(async (res) => {
        if (res.ok) return { ok: true };
        throw new Error(`${res.status}: ${await res.text()}`);
      })
    ).bimap(
      logger.tap("Error encountered when subscribing to process via MU"),
      logger.tap("Successfully subscribed to process via MU")
    ).map((res) => ({ res, messageId: signedDataItem.id }))
  ).toPromise();
}
function deployUnmonitorWith({ fetch: fetch2, MU_URL: MU_URL2, logger: _logger }) {
  const logger = _logger.child("deployUnmonitor");
  return (args) => of(args).chain(
    fromPromise(
      ({ processId, data, tags, anchor, signer }) => toDataItemSigner(signer)({ data, tags, target: processId, anchor })
    )
  ).map(logger.tap("Successfully built and signed data item")).chain(
    (signedDataItem) => of(signedDataItem).chain(
      fromPromise(
        async (signedDataItem2) => fetch2(MU_URL2 + "/monitor/" + args.processId, {
          method: "DELETE",
          headers: {
            "Content-Type": "application/octet-stream",
            Accept: "application/json"
          },
          redirect: "follow",
          body: signedDataItem2.raw
        })
      )
    ).bichain(
      (err) => Rejected(
        new Error(
          `Error while communicating with MU: ${JSON.stringify(err)}`
        )
      ),
      fromPromise(async (res) => {
        if (res.ok) return { ok: true };
        throw new Error(`${res.status}: ${await res.text()}`);
      })
    ).bimap(
      logger.tap(
        "Error encountered when unsubscribing to process via MU"
      ),
      logger.tap("Successfully unsubscribed to process via MU")
    ).map((res) => ({ res, messageId: signedDataItem.id }))
  ).toPromise();
}
function deployAssignWith({ fetch: fetch2, MU_URL: MU_URL2, logger: _logger }) {
  const logger = _logger.child("deployAssign");
  return (args) => {
    return of(args).chain(
      fromPromise(
        async ({ process: process2, message: message2, baseLayer, exclude }) => fetch2(
          `${MU_URL2}?process-id=${process2}&assign=${message2}${baseLayer ? "&base-layer" : ""}${exclude ? "&exclude=" + exclude.join(",") : ""}`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/octet-stream",
              Accept: "application/json"
            }
          }
        )
      )
    ).bichain(
      (err) => Rejected(
        new Error(
          `Error while communicating with MU: ${JSON.stringify(err)}`
        )
      ),
      fromPromise(async (res) => {
        if (res.ok) return res.json();
        throw new Error(`${res.status}: ${await res.text()}`);
      })
    ).bimap(
      logger.tap("Error encountered when writing assignment via MU"),
      logger.tap("Successfully wrote assignment via MU")
    ).map((res) => ({ res, assignmentId: res.id })).toPromise();
  };
}

// src/client/ao-cu.js
function dryrunFetchWith({ fetch: fetch2, CU_URL: CU_URL2, logger }) {
  return (msg) => of(msg).map(logger.tap("posting dryrun request to CU")).chain(fromPromise((msg2) => fetch2(`${CU_URL2}/dry-run?process-id=${msg2.Target}`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    redirect: "follow",
    body: JSON.stringify(msg2)
  }).then((res) => res.json()))).toPromise();
}
function loadResultWith({ fetch: fetch2, CU_URL: CU_URL2, logger }) {
  return ({ id, processId }) => {
    return of(`${CU_URL2}/result/${id}?process-id=${processId}`).map(logger.tap("fetching message result from CU")).chain(fromPromise(
      async (url) => fetch2(url, {
        method: "GET",
        headers: {
          Accept: "application/json"
        },
        redirect: "follow"
      }).then((res) => res.json())
    )).toPromise();
  };
}
function queryResultsWith({ fetch: fetch2, CU_URL: CU_URL2, logger }) {
  return ({ process: process2, from, to, sort, limit }) => {
    const target = new URL(`${CU_URL2}/results/${process2}`);
    const params = new URLSearchParams(target.search);
    if (from) {
      params.append("from", from);
    }
    if (to) {
      params.append("to", to);
    }
    if (sort) {
      params.append("sort", sort);
    }
    if (limit) {
      params.append("limit", limit);
    }
    target.search = params;
    return of(target.toString()).map(logger.tap("fetching message result from CU")).chain(fromPromise(
      async (url) => fetch2(url, {
        method: "GET",
        headers: {
          Accept: "application/json"
        },
        redirect: "follow"
      }).then((res) => res.json())
    )).toPromise();
  };
}

// src/client/gateway.js
var import_ramda4 = require("ramda");
var import_zod2 = require("zod");
function loadTransactionMetaWith({ fetch: fetch2, GRAPHQL_URL: GRAPHQL_URL2, logger }) {
  const GET_TRANSACTIONS_QUERY = `
    query GetTransactions ($transactionIds: [ID!]!) {
      transactions(ids: $transactionIds) {
        edges {
          node {
            owner {
              address
            }
            tags {
              name
              value
            }
            block {
              id
              height
              timestamp
            }
          }
        }
      }
    }`;
  const transactionConnectionSchema = import_zod2.z.object({
    data: import_zod2.z.object({
      transactions: import_zod2.z.object({
        edges: import_zod2.z.array(import_zod2.z.object({
          node: import_zod2.z.record(import_zod2.z.any())
        }))
      })
    })
  });
  return (id) => of(id).chain(fromPromise(
    (id2) => fetch2(GRAPHQL_URL2, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        query: GET_TRANSACTIONS_QUERY,
        variables: { transactionIds: [id2] }
      })
    }).then(async (res) => {
      if (res.ok) return res.json();
      logger('Error Encountered when querying gateway for transaction "%s"', id2);
      throw new Error(`${res.status}: ${await res.text()}`);
    }).then(transactionConnectionSchema.parse).then((0, import_ramda4.path)(["data", "transactions", "edges", "0", "node"]))
  )).toPromise();
}

// src/client/ao-su.js
var import_lru_map = __toESM(require("mnemonist/lru-map.js"), 1);
var getMessagesByRange = ({ fetch: fetch2, locate: locate2 }) => {
  return async ({ processId, from, to, limit }) => {
    const suUrl = (await locate2(processId)).url;
    return fetch2(`${suUrl}/${processId}?from=${from}&to=${to}&limit=${limit}`).then((res) => res.json());
  };
};
var getMessageById = ({ fetch: fetch2, locate: locate2 }) => {
  return async ({ processId, messageId }) => {
    const suUrl = (await locate2(processId)).url;
    return fetch2(`${suUrl}/${messageId}?process-id=${processId}`).then((res) => res.json());
  };
};
var getLastSlotWith = ({ fetch: fetch2, locate: locate2 }) => {
  return async ({ processId, since }) => {
    if (!since) {
      since = 10 * 60 * 1e3;
    }
    const from = Date.now() - since;
    const suUrl = (await locate2(processId)).url;
    return fetch2(`${suUrl}/${processId}?process-id=${processId}&limit=100&from=${from}`).then((res) => res.json()).then((suResult) => {
      return suResult.edges[suResult?.edges?.length - 1]?.node?.assignment?.tags?.find((t) => t.name === "Nonce")?.value;
    });
  };
};

// src/lib/messages/index.js
var import_zod3 = require("zod");
var inputSchema = import_zod3.z.object({
  processId: import_zod3.z.string(),
  from: import_zod3.z.string(),
  to: import_zod3.z.string(),
  limit: import_zod3.z.string().default("1000").optional()
}).passthrough();
function messagesWith(env) {
  const messages = env.messages;
  return (fields) => {
    fields = inputSchema.parse(fields);
    return messages(fields);
  };
}

// src/lib/message-id/index.js
var import_zod4 = require("zod");
var inputSchema2 = import_zod4.z.object({
  processId: import_zod4.z.string(),
  messageId: import_zod4.z.string()
}).passthrough();
function messageIdWith(env) {
  const getMessageId = env.getMessageId;
  return (fields) => {
    fields = inputSchema2.parse(fields);
    return getMessageId(fields);
  };
}

// src/lib/process-id/index.js
var import_zod5 = require("zod");
var inputSchema3 = import_zod5.z.object({
  processId: import_zod5.z.string(),
  since: import_zod5.z.number().optional()
}).passthrough();
function processIdWith(env) {
  const processId = env.processId;
  return (fields) => {
    fields = inputSchema3.parse(fields);
    return processId(fields);
  };
}

// src/lib/request/index.js
var import_ramda5 = require("ramda");
var import_zod6 = require("zod");

// src/lib/request/multipart.js
function parseMultipartContent(content, contentType) {
  const boundaryMatch = contentType.match(/boundary="?([^";]+)"?/);
  if (!boundaryMatch) {
    throw new Error("No boundary found in Content-Type");
  }
  const boundary = boundaryMatch[1];
  const boundaryRegex = new RegExp(`--${boundary}(?:--)?(\\r\\n|\\n)`);
  const parts = content.split(boundaryRegex).filter((p) => p !== "\r\n");
  const resultMap = /* @__PURE__ */ new Map();
  for (let i = 0; i < parts.length; i += 2) {
    if (!parts[i] || parts[i].trim() === "") continue;
    const partContent = parts[i];
    const lines = partContent.split(/\r\n|\n/);
    const headers = {};
    let j = 0;
    while (j < lines.length && lines[j].trim() !== "") {
      const line = lines[j];
      const colonIndex = line.indexOf(":");
      if (colonIndex !== -1) {
        const headerName = line.substring(0, colonIndex).trim().toLowerCase();
        const headerValue = line.substring(colonIndex + 1).trim();
        headers[headerName] = headerValue;
      }
      j++;
    }
    j++;
    const bodyContent = lines.slice(j).join("\n").trim();
    const contentDisposition = headers["content-disposition"] || "";
    const nameMatch = contentDisposition.match(/name="([^"]+)"/);
    if (nameMatch) {
      const name = nameMatch[1];
      const entry = Object.assign({}, headers, { body: bodyContent });
      const fields = {};
      lines.slice(j).forEach((line) => {
        if (line.trim() === "") return;
        const colonIndex = line.indexOf(":");
        if (colonIndex !== -1) {
          const fieldName = line.substring(0, colonIndex).trim();
          const fieldValue = line.substring(colonIndex + 1).trim();
          fields[fieldName] = fieldValue;
        }
      });
      if (Object.keys(fields).length > 0) {
        entry.fields = fields;
      }
      resultMap.set(name, entry);
    }
  }
  return resultMap;
}

// src/lib/request/index.js
function requestWith2(env) {
  return (fields) => {
    return of(fields).chain(verifyInput).chain(dispatch(env)).map(logResult(env, fields)).map(transformToMap).bimap(errFrom, import_ramda5.identity).toPromise();
  };
}
function verifyInput(args) {
  const inputSchema7 = import_zod6.z.object({
    path: import_zod6.z.string().min(1, { message: "path is required" }),
    method: import_zod6.z.string()
  }).passthrough();
  return of(inputSchema7.parse(args));
}
function transformToMap(result2) {
  let map3 = {};
  const res = result2;
  if (res.headers.get("content-type") && res.headers.get("content-type").startsWith("multipart")) {
    map3 = (0, import_ramda5.mergeRight)(
      map3,
      Object.fromEntries(
        parseMultipartContent(res.body, res.headers.get("content-type"))
      )
    );
  } else {
    map3.body = res.body;
  }
  res.headers.forEach((v, k) => {
    map3[k] = v;
  });
  return map3;
}
function dispatch(env) {
  return fromPromise(env.request);
}
function logResult(env, fields) {
  return (res) => {
    env.logger(
      'Received response from message sent to path "%s" with res %O',
      fields?.path ?? "/",
      res
    );
    return res;
  };
}

// src/lib/result/index.js
var import_ramda6 = require("ramda");

// src/lib/result/verify-input.js
var import_zod7 = require("zod");
var inputSchema4 = import_zod7.z.object({
  id: import_zod7.z.string().min(1, { message: "message is required to be a message id" }),
  processId: import_zod7.z.string().min(1, { message: "process is required to be a process id" })
});
function verifyInputWith() {
  return (ctx) => {
    return of(ctx).map(inputSchema4.parse).map(() => ctx);
  };
}

// src/dal.js
var import_zod8 = require("zod");
var tagSchema = import_zod8.z.object({
  name: import_zod8.z.string(),
  value: import_zod8.z.any()
});
var dryrunResultSchema = import_zod8.z.function().args(import_zod8.z.object({
  Id: import_zod8.z.string(),
  Target: import_zod8.z.string(),
  Owner: import_zod8.z.string(),
  Anchor: import_zod8.z.string().optional(),
  Data: import_zod8.z.any().default("1234"),
  Tags: import_zod8.z.array(import_zod8.z.object({ name: import_zod8.z.string(), value: import_zod8.z.string() }))
})).returns(import_zod8.z.promise(import_zod8.z.any()));
var loadResultSchema = import_zod8.z.function().args(import_zod8.z.object({
  id: import_zod8.z.string().min(1, { message: "message id is required" }),
  processId: import_zod8.z.string().min(1, { message: "process id is required" })
})).returns(import_zod8.z.promise(import_zod8.z.any()));
var queryResultsSchema = import_zod8.z.function().args(import_zod8.z.object({
  process: import_zod8.z.string().min(1, { message: "process id is required" }),
  from: import_zod8.z.string().optional(),
  to: import_zod8.z.string().optional(),
  sort: import_zod8.z.enum(["ASC", "DESC"]).default("ASC"),
  limit: import_zod8.z.number().optional()
})).returns(import_zod8.z.promise(import_zod8.z.object({
  edges: import_zod8.z.array(import_zod8.z.object({
    cursor: import_zod8.z.string(),
    node: import_zod8.z.object({
      Output: import_zod8.z.any().optional(),
      Messages: import_zod8.z.array(import_zod8.z.any()).optional(),
      Spawns: import_zod8.z.array(import_zod8.z.any()).optional(),
      Error: import_zod8.z.any().optional()
    })
  }))
})));
var deployMessageSchema = import_zod8.z.function().args(import_zod8.z.object({
  processId: import_zod8.z.string(),
  data: import_zod8.z.any(),
  tags: import_zod8.z.array(tagSchema),
  anchor: import_zod8.z.string().optional(),
  signer: import_zod8.z.any().nullish()
})).returns(import_zod8.z.promise(
  import_zod8.z.object({
    messageId: import_zod8.z.string()
  }).passthrough()
));
var prepareMessageSchema = import_zod8.z.function().args(import_zod8.z.object({
  processId: import_zod8.z.string(),
  data: import_zod8.z.any(),
  tags: import_zod8.z.array(tagSchema),
  anchor: import_zod8.z.string().optional(),
  signer: import_zod8.z.any().nullish()
})).returns(import_zod8.z.promise(
  import_zod8.z.object({
    id: import_zod8.z.string(),
    raw: import_zod8.z.any()
  }).passthrough()
));
var sendSignedMessageSchema = import_zod8.z.function().args(import_zod8.z.object({
  id: import_zod8.z.string(),
  raw: import_zod8.z.any()
})).returns(import_zod8.z.promise(
  import_zod8.z.object({
    messageId: import_zod8.z.string()
  }).passthrough()
));
var deployProcessSchema = import_zod8.z.function().args(import_zod8.z.object({
  data: import_zod8.z.any(),
  tags: import_zod8.z.array(tagSchema),
  signer: import_zod8.z.any().nullish()
})).returns(import_zod8.z.promise(
  import_zod8.z.object({
    processId: import_zod8.z.string()
  }).passthrough()
));
var deployAssignSchema = import_zod8.z.function().args(import_zod8.z.object({
  process: import_zod8.z.string(),
  message: import_zod8.z.string(),
  baseLayer: import_zod8.z.boolean().optional(),
  exclude: import_zod8.z.array(import_zod8.z.string()).optional()
})).returns(import_zod8.z.promise(
  import_zod8.z.object({
    assignmentId: import_zod8.z.string()
  }).passthrough()
));
var deployMonitorSchema = deployMessageSchema;
var loadProcessMetaSchema = import_zod8.z.function().args(import_zod8.z.object({
  suUrl: import_zod8.z.string().url(),
  processId: import_zod8.z.string()
})).returns(import_zod8.z.promise(
  import_zod8.z.object({
    tags: import_zod8.z.array(tagSchema)
  }).passthrough()
));
var locateSchedulerSchema = import_zod8.z.function().args(import_zod8.z.string()).returns(import_zod8.z.promise(
  import_zod8.z.object({
    url: import_zod8.z.string()
  })
));
var validateSchedulerSchema = import_zod8.z.function().args(import_zod8.z.string()).returns(import_zod8.z.promise(import_zod8.z.boolean()));
var loadTransactionMetaSchema = import_zod8.z.function().args(import_zod8.z.string()).returns(import_zod8.z.promise(
  import_zod8.z.object({
    tags: import_zod8.z.array(tagSchema)
  }).passthrough()
));
var signerSchema = import_zod8.z.function();

// src/lib/result/read.js
function readWith({ loadResult }) {
  loadResult = fromPromise(loadResultSchema.implement(loadResult));
  return (ctx) => {
    return of({ id: ctx.id, processId: ctx.processId }).chain(loadResult);
  };
}

// src/lib/result/index.js
function resultWith(env) {
  const verifyInput2 = verifyInputWith(env);
  const read = readWith(env);
  return ({ message: message2, process: process2 }) => {
    return of({ id: message2, processId: process2 }).chain(verifyInput2).chain(read).map(
      env.logger.tap(
        'readResult result for message "%s": %O',
        message2
      )
    ).map((result2) => result2).bimap(errFrom, import_ramda6.identity).toPromise();
  };
}

// src/lib/message/index.js
var import_ramda8 = require("ramda");

// src/lib/message/upload-message.js
var import_zod9 = require("zod");
var import_ramda7 = require("ramda");
var import_protocol_tag_utils = require("@permaweb/protocol-tag-utils");
var aoProto = (0, import_protocol_tag_utils.proto)("ao");
var removeAoProtoByName = (0, import_ramda7.curry)(aoProto.removeAllByName);
var concatAoProto = (0, import_ramda7.curry)(aoProto.concat);
var concatUnassoc = (0, import_ramda7.curry)(aoProto.concatUnassoc);
var tagSchema2 = import_zod9.z.array(import_zod9.z.object({
  name: import_zod9.z.string(),
  value: import_zod9.z.string()
}));
function buildTagsWith() {
  return (ctx) => {
    const variant = ctx?.tags?.find((tag) => tag.name.toLowerCase() === "variant")?.value || "ao.TN.1";
    return of(ctx.tags).map((0, import_ramda7.defaultTo)([])).map(removeAoProtoByName("Variant")).map(removeAoProtoByName("Type")).map(concatAoProto([
      { name: "Variant", value: variant },
      { name: "Type", value: "Message" }
    ])).map(tagSchema2.parse).map((0, import_ramda7.assoc)("tags", import_ramda7.__, ctx));
  };
}
function buildDataWith({ logger }) {
  return (ctx) => {
    return of(ctx).chain((0, import_ramda7.ifElse)(
      (0, import_ramda7.always)(ctx.data),
      /**
       * data is provided as input, so do nothing
       */
      () => Resolved(ctx),
      /**
       * No data is provided, so replace with one space
       */
      () => Resolved(" ").map((0, import_ramda7.assoc)("data", import_ramda7.__, ctx)).map(
        (ctx2) => (0, import_ramda7.pipe)(
          (0, import_ramda7.prop)("tags"),
          concatUnassoc([{ name: "Content-Type", value: "text/plain" }]),
          (0, import_ramda7.assoc)("tags", import_ramda7.__, ctx2)
        )(ctx2)
      ).map(logger.tap('added pseudo-random string as message "data"'))
    )).map(
      (ctx2) => (0, import_ramda7.pipe)(
        (0, import_ramda7.prop)("tags"),
        concatUnassoc([{ name: "SDK", value: "aoconnect" }]),
        (0, import_ramda7.assoc)("tags", import_ramda7.__, ctx2)
      )(ctx2)
    );
  };
}
function uploadMessageWith(env) {
  const buildTags = buildTagsWith(env);
  const buildData = buildDataWith(env);
  const deployMessage = deployMessageSchema.implement(env.deployMessage);
  return (ctx) => {
    return of(ctx).chain(buildTags).chain(buildData).chain(fromPromise(({ id, data, tags, anchor, signer }) => {
      return deployMessage({ processId: id, data, tags, anchor, signer: signerSchema.implement(signer || env.signer) });
    })).map((res) => (0, import_ramda7.assoc)("messageId", res.messageId, ctx));
  };
}
function prepareMessageWith(env) {
  const buildTags = buildTagsWith(env);
  const buildData = buildDataWith(env);
  const signMessage = prepareMessageSchema.implement(env.signMessage);
  return (ctx) => {
    return of(ctx).chain(buildTags).chain(buildData).chain(fromPromise(
      ({ id, data, tags, anchor, signer }) => signMessage({ processId: id, data, tags, anchor, signer: signerSchema.implement(signer || env.signer) })
    )).map((res) => {
      return res;
    });
  };
}
function sendSignedMessageWith2(env) {
  const sendSignedMessage = sendSignedMessageSchema.implement(env.sendSignedMessage);
  return (ctx) => {
    return of(ctx).chain(fromPromise(
      ({ id, raw }) => sendSignedMessage({ id, raw })
    )).map((res) => (0, import_ramda7.assoc)("messageId", res.messageId, ctx));
  };
}

// src/lib/message/index.js
function messageWith(env) {
  const uploadMessage = uploadMessageWith(env);
  return ({ process: process2, data, tags, anchor, signer }) => {
    return of({ id: process2, data, tags, anchor, signer }).chain(uploadMessage).map((ctx) => ctx.messageId).bimap(errFrom, import_ramda8.identity).toPromise();
  };
}
function prepareWith(env) {
  const prepareMessage = prepareMessageWith(env);
  return ({ process: process2, data, tags, anchor, signer }) => {
    return of({ id: process2, data, tags, anchor, signer }).chain(prepareMessage).map((ctx) => ctx).bimap(errFrom, import_ramda8.identity).toPromise();
  };
}
function signedMessageWith(env) {
  const sendSignedMessage = sendSignedMessageWith2(env);
  return ({ id, raw }) => {
    return of({ id, raw }).chain(sendSignedMessage).map((ctx) => ctx.messageId).bimap(errFrom, import_ramda8.identity).toPromise();
  };
}

// src/lib/spawn/index.js
var import_ramda11 = require("ramda");

// src/lib/spawn/verify-inputs.js
var import_ramda9 = require("ramda");
var checkTag = (name, pred, err) => (tags) => pred(tags[name]) ? Resolved(tags) : Rejected(`Tag '${name}': ${err}`);
function verifyModuleWith({ loadTransactionMeta, logger }) {
  loadTransactionMeta = fromPromise(loadTransactionMetaSchema.implement(loadTransactionMeta));
  return (module2) => of(module2).chain(loadTransactionMeta).map((0, import_ramda9.prop)("tags")).map(parseTags).chain(checkTag("Data-Protocol", eqOrIncludes("ao"), "value 'ao' was not found on module")).chain(checkTag("Type", eqOrIncludes("Module"), "value 'Module' was not found on module")).chain(checkTag("Module-Format", import_ramda9.isNotNil, "was not found on module")).chain(checkTag("Input-Encoding", import_ramda9.isNotNil, "was not found on module")).chain(checkTag("Output-Encoding", import_ramda9.isNotNil, "was not found on module")).bimap(
    logger.tap("Verifying module source failed: %s"),
    logger.tap("Verified module source")
  );
}
function verifySchedulerWith({ logger, validateScheduler }) {
  validateScheduler = fromPromise(validateSchedulerSchema.implement(validateScheduler));
  return (scheduler) => of(scheduler).chain(
    (scheduler2) => validateScheduler(scheduler2).chain((isValid) => isValid ? Resolved(scheduler2) : Rejected(`Valid Scheduler-Location owned by ${scheduler2} not found`))
  ).bimap(
    logger.tap("Verifying scheduler failed: %s"),
    logger.tap("Verified scheduler")
  );
}
function verifySignerWith({ logger }) {
  return (signer) => of(signer).map(logger.tap("Checking for signer")).chain((signer2) => signer2 ? Resolved(signer2) : Rejected("signer not found"));
}
function verifyInputsWith(env) {
  const logger = env.logger.child("verifyInput");
  env = { ...env, logger };
  const verifyModule = verifyModuleWith(env);
  const verifyScheduler = verifySchedulerWith(env);
  const verifySigner = verifySignerWith(env);
  return (ctx) => {
    return of(ctx).chain((ctx2) => verifyModule(ctx2.module).map(() => ctx2)).bimap(
      logger.tap("Error when verify input: %s"),
      logger.tap("Successfully verified inputs")
    );
  };
}

// src/lib/spawn/upload-process.js
var import_zod10 = require("zod");
var import_ramda10 = require("ramda");
var import_protocol_tag_utils2 = require("@permaweb/protocol-tag-utils");
var aoProto2 = (0, import_protocol_tag_utils2.proto)("ao");
var removeAoProtoByName2 = (0, import_ramda10.curry)(aoProto2.removeAllByName);
var concatAoProto2 = (0, import_ramda10.curry)(aoProto2.concat);
var concatUnassoc2 = (0, import_ramda10.curry)(aoProto2.concatUnassoc);
var tagsSchema = import_zod10.z.array(tagSchema);
function buildTagsWith2() {
  return (ctx) => {
    const variant = ctx?.tags?.find((tag) => tag.name.toLowerCase() === "variant")?.value || "ao.TN.1";
    return of(ctx).map((0, import_ramda10.prop)("tags")).map((0, import_ramda10.defaultTo)([])).map(removeAoProtoByName2("Variant")).map(removeAoProtoByName2("Type")).map(removeAoProtoByName2("Module")).map(removeAoProtoByName2("Scheduler")).map(concatAoProto2([
      { name: "Variant", value: variant },
      { name: "Type", value: "Process" },
      { name: "Module", value: ctx.module },
      { name: "Scheduler", value: ctx.scheduler },
      { name: "Timestamp", value: Date.now().toString() }
    ])).map(tagsSchema.parse).map((0, import_ramda10.assoc)("tags", import_ramda10.__, ctx));
  };
}
function buildDataWith2({ logger }) {
  return (ctx) => {
    return of(ctx).chain((0, import_ramda10.ifElse)(
      (0, import_ramda10.always)(ctx.data),
      /**
       * data is provided as input, so do nothing
       */
      () => Resolved(ctx),
      /**
       * No data is provided, so replace with one space
       */
      () => Resolved(" ").map((0, import_ramda10.assoc)("data", import_ramda10.__, ctx)).map(
        (ctx2) => (0, import_ramda10.pipe)(
          (0, import_ramda10.prop)("tags"),
          concatUnassoc2([{ name: "Content-Type", value: "text/plain" }]),
          (0, import_ramda10.assoc)("tags", import_ramda10.__, ctx2)
        )(ctx2)
      ).map(logger.tap('added pseudo-random string as process "data"'))
    )).map(
      (ctx2) => (0, import_ramda10.pipe)(
        (0, import_ramda10.prop)("tags"),
        concatUnassoc2([{ name: "SDK", value: "aoconnect" }]),
        (0, import_ramda10.assoc)("tags", import_ramda10.__, ctx2)
      )(ctx2)
    );
  };
}
function uploadProcessWith(env) {
  const logger = env.logger.child("uploadProcess");
  env = { ...env, logger };
  const buildTags = buildTagsWith2(env);
  const buildData = buildDataWith2(env);
  const deployProcess = deployProcessSchema.implement(env.deployProcess);
  return (ctx) => {
    return of(ctx).chain(buildTags).chain(buildData).chain(fromPromise(
      ({ data, tags, signer }) => deployProcess({ data, tags, signer: signerSchema.implement(signer || env.signer) })
    )).map((res) => (0, import_ramda10.assoc)("processId", res.processId, ctx));
  };
}

// src/lib/spawn/index.js
function spawnWith(env) {
  const verifyInputs = verifyInputsWith(env);
  const uploadProcess = uploadProcessWith(env);
  return ({ module: module2, scheduler, signer, tags, data }) => {
    return of({ module: module2, scheduler, signer, tags, data }).chain(verifyInputs).chain(uploadProcess).map((ctx) => ctx.processId).bimap(errFrom, import_ramda11.identity).toPromise();
  };
}

// src/lib/monitor/index.js
var import_ramda13 = require("ramda");

// src/lib/monitor/upload-monitor.js
var import_ramda12 = require("ramda");
function uploadMonitorWith(env) {
  const deployMonitor = deployMonitorSchema.implement(env.deployMonitor);
  return (ctx) => {
    return of(ctx).chain(fromPromise(
      ({ id, signer }) => deployMonitor({
        processId: id,
        signer: signerSchema.implement(signer || env.signer),
        /**
         * No tags or data can be provided right now,
         *
         * so just set data to single space and set tags to an empty array
         */
        data: " ",
        tags: []
      })
    )).map((res) => (0, import_ramda12.assoc)("monitorId", res.messageId, ctx));
  };
}

// src/lib/monitor/index.js
function monitorWith(env) {
  const uploadMonitor = uploadMonitorWith(env);
  return ({ process: process2, signer }) => of({ id: process2, signer }).chain(uploadMonitor).map((ctx) => ctx.monitorId).bimap(errFrom, import_ramda13.identity).toPromise();
}

// src/lib/unmonitor/index.js
var import_ramda15 = require("ramda");

// src/lib/unmonitor/upload-unmonitor.js
var import_ramda14 = require("ramda");
function uploadUnmonitorWith(env) {
  const deployUnmonitor = deployMonitorSchema.implement(env.deployUnmonitor);
  return (ctx) => {
    return of(ctx).chain(fromPromise(
      ({ id, signer }) => deployUnmonitor({
        processId: id,
        signer: signerSchema.implement(signer || env.signer),
        /**
         * No tags or data can be provided right now,
         *
         * so just set data to single space and set tags to an empty array
         */
        data: " ",
        tags: []
      })
    )).map((res) => (0, import_ramda14.assoc)("monitorId", res.messageId, ctx));
  };
}

// src/lib/unmonitor/index.js
function unmonitorWith(env) {
  const uploadUnmonitor = uploadUnmonitorWith(env);
  return ({ process: process2, signer }) => of({ id: process2, signer }).chain(uploadUnmonitor).map((ctx) => ctx.monitorId).bimap(errFrom, import_ramda15.identity).toPromise();
}

// src/lib/results/index.js
var import_ramda16 = require("ramda");

// src/lib/results/verify-input.js
var import_zod11 = require("zod");
var inputSchema5 = import_zod11.z.object({
  process: import_zod11.z.string().min(1, { message: "process identifier is required" }),
  from: import_zod11.z.string().optional(),
  to: import_zod11.z.string().optional(),
  sort: import_zod11.z.enum(["ASC", "DESC"]).default("ASC"),
  limit: import_zod11.z.number().optional()
});
function verifyInputWith2() {
  return (ctx) => {
    return of(ctx).map(inputSchema5.parse).map(() => ctx);
  };
}

// src/lib/results/query.js
function queryWith({ queryResults }) {
  queryResults = fromPromise(queryResultsSchema.implement(queryResults));
  return (ctx) => {
    return of({ process: ctx.process, from: ctx.from, to: ctx.to, sort: ctx.sort, limit: ctx.limit }).chain(queryResults);
  };
}

// src/lib/results/index.js
function resultsWith(env) {
  const verifyInput2 = verifyInputWith2(env);
  const query = queryWith(env);
  return ({ process: process2, from, to, sort, limit }) => {
    return of({ process: process2, from, to, sort, limit }).chain(verifyInput2).chain(query).map(
      env.logger.tap(
        'readResults result for message "%s": %O',
        process2
      )
    ).map((result2) => result2).bimap(errFrom, import_ramda16.identity).toPromise();
  };
}

// src/lib/dryrun/verify-input.js
var import_zod12 = require("zod");
var inputSchema6 = import_zod12.z.object({
  Id: import_zod12.z.string(),
  Target: import_zod12.z.string(),
  Owner: import_zod12.z.string(),
  Anchor: import_zod12.z.string().optional(),
  Data: import_zod12.z.any().default("1234"),
  Tags: import_zod12.z.array(import_zod12.z.object({ name: import_zod12.z.string(), value: import_zod12.z.string() }))
});
function verifyInputWith3() {
  return (msg) => {
    return of(msg).map(inputSchema6.parse).map((m) => {
      m.Tags = m.Tags.concat([
        { name: "Data-Protocol", value: "ao" },
        { name: "Type", value: "Message" },
        { name: "Variant", value: "ao.TN.1" }
      ]);
      return m;
    });
  };
}

// src/lib/dryrun/run.js
function runWith({ dryrunFetch }) {
  return fromPromise(dryrunResultSchema.implement(dryrunFetch));
}

// src/lib/dryrun/index.js
function dryrunWith(env) {
  const verifyInput2 = verifyInputWith3(env);
  const dryrun2 = runWith(env);
  return (msg) => of(msg).map(convert).chain(verifyInput2).chain(dryrun2).toPromise();
}
function convert({ process: process2, data, tags, anchor, ...rest }) {
  return {
    Id: "1234",
    Owner: "1234",
    ...rest,
    Target: process2,
    Data: data || "1234",
    Tags: tags || [],
    Anchor: anchor || "0"
  };
}

// src/lib/assign/index.js
var import_ramda18 = require("ramda");

// src/lib/assign/send-assign.js
var import_ramda17 = require("ramda");
function sendAssignWith(env) {
  const deployAssign = deployAssignSchema.implement(env.deployAssign);
  return (ctx) => {
    return of(ctx).chain(fromPromise(
      ({ process: process2, message: message2, baseLayer, exclude }) => deployAssign({ process: process2, message: message2, baseLayer, exclude })
    )).map((res) => (0, import_ramda17.assoc)("assignmentId", res.assignmentId, ctx));
  };
}

// src/lib/assign/index.js
function assignWith(env) {
  const sendAssign = sendAssignWith(env);
  return ({ process: process2, message: message2, baseLayer, exclude }) => {
    return of({ process: process2, message: message2, baseLayer, exclude }).chain(sendAssign).map((ctx) => ctx.assignmentId).bimap(errFrom, import_ramda18.identity).toPromise();
  };
}

// src/lib/serializeCron/index.js
var import_ramda19 = require("ramda");
function serializeCron(cron) {
  function parseInterval(interval2 = "") {
    if (typeof interval2 !== "string") throw new Error("Encountered Error serializing cron: invalid interval");
    const [value, unit] = interval2.split("-").map((s) => s.trim());
    if (!value || !unit) throw new Error("Encountered Error serializing cron: invalid interval");
    if (!parseInt(value) || parseInt(value) < 0) throw new Error("Encountered Error serializing cron: invalid interval value");
    const singularRegex = /^(millisecond|second|minute|hour|day|month|year|block)$/;
    const pluralRegex = /^(milliseconds|seconds|minutes|hours|days|months|years|blocks)$/;
    const unitSingularMatch = unit.match(singularRegex);
    const unitPluralMatch = unit.match(pluralRegex);
    if (parseInt(value) > 1 && !unitPluralMatch || parseInt(value) === 1 && !unitSingularMatch) throw new Error("Encountered Error serializing cron: invalid interval type");
    return `${value}-${unit}`;
  }
  function parseTags2(tags2 = []) {
    return (0, import_ramda19.map)((tag) => {
      if (!tag.name || !tag.value) throw new Error("Encountered Error serializing cron: invalid tag structure");
      if (typeof tag.name !== "string" || typeof tag.value !== "string") throw new Error("Encountered Error serializing cron: invalid interval tag types");
      return { name: `Cron-Tag-${tag.name}`, value: tag.value };
    }, tags2);
  }
  const interval = parseInterval(cron.interval);
  const tags = parseTags2(cron.tags);
  return [{ name: "Cron-Interval", value: interval }, ...tags];
}

// src/index.common.js
var DEFAULT_GATEWAY_URL = "https://arweave.net";
var DEFAULT_MU_URL = "https://mu.ao-testnet.xyz";
var DEFAULT_CU_URL = "https://cu.ao-testnet.xyz";
var DEFAULT_RELAY_URL = "http://relay.ao-hb.xyz";
var DEFAULT_RELAY_CU_URL = "http://cu.s451-comm3-main.xyz";
var DEFAULT_RELAY_MU_URL = "http://mu.s451-comm3-main.xyz";
var DEFAULT_DEVICE = "relay@1.0";
var defaultFetch = fetch;
function connectWith({ createDataItemSigner: createDataItemSigner3, createSigner: createSigner3 }) {
  const _logger = createLogger();
  function legacyMode({
    MODE,
    GRAPHQL_URL: GRAPHQL_URL2,
    GRAPHQL_MAX_RETRIES: GRAPHQL_MAX_RETRIES2,
    GRAPHQL_RETRY_BACKOFF: GRAPHQL_RETRY_BACKOFF2,
    MU_URL: MU_URL2 = DEFAULT_MU_URL,
    CU_URL: CU_URL2 = DEFAULT_CU_URL,
    fetch: fetch2 = defaultFetch,
    noLog
  }) {
    const logger = _logger.child("legacy");
    if (!noLog) logger("Mode Activated \u2139\uFE0F");
    const { validate } = (0, import_ao_scheduler_utils.connect)({
      cacheSize: 100,
      GRAPHQL_URL: GRAPHQL_URL2,
      GRAPHQL_MAX_RETRIES: GRAPHQL_MAX_RETRIES2,
      GRAPHQL_RETRY_BACKOFF: GRAPHQL_RETRY_BACKOFF2
    });
    const resultLogger = logger.child("result");
    const result2 = resultWith({
      loadResult: loadResultWith({
        fetch: fetch2,
        CU_URL: CU_URL2,
        logger: resultLogger
      }),
      logger: resultLogger
    });
    const messageLogger = logger.child("message");
    const message2 = messageWith({
      deployMessage: deployMessageWith({
        fetch: fetch2,
        MU_URL: MU_URL2,
        logger: messageLogger
      }),
      logger: messageLogger
    });
    const signMessageLogger = logger.child("signMessage");
    const signMessage = prepareWith({
      signMessage: signMessageWith({
        logger: signMessageLogger
      }),
      logger: signMessageLogger
    });
    const sendSignedMessageLogger = logger.child("sendSignedMessage");
    const sendSignedMessage = signedMessageWith({
      sendSignedMessage: sendSignedMessageWith({
        fetch: fetch2,
        MU_URL: MU_URL2,
        logger: sendSignedMessageLogger
      }),
      logger: sendSignedMessageLogger
    });
    const spawnLogger = logger.child("spawn");
    const spawn2 = spawnWith({
      loadTransactionMeta: loadTransactionMetaWith({
        fetch: fetch2,
        GRAPHQL_URL: GRAPHQL_URL2,
        logger: spawnLogger
      }),
      validateScheduler: validate,
      deployProcess: deployProcessWith({
        fetch: fetch2,
        MU_URL: MU_URL2,
        logger: spawnLogger
      }),
      logger: spawnLogger
    });
    const monitorLogger = logger.child("monitor");
    const monitor2 = monitorWith({
      deployMonitor: deployMonitorWith({
        fetch: fetch2,
        MU_URL: MU_URL2,
        logger: monitorLogger
      }),
      logger: monitorLogger
    });
    const unmonitorLogger = logger.child("unmonitor");
    const unmonitor2 = unmonitorWith({
      deployUnmonitor: deployUnmonitorWith({
        fetch: fetch2,
        MU_URL: MU_URL2,
        logger: unmonitorLogger
      }),
      logger: monitorLogger
    });
    const resultsLogger = logger.child("results");
    const results2 = resultsWith({
      queryResults: queryResultsWith({
        fetch: fetch2,
        CU_URL: CU_URL2,
        logger: resultsLogger
      }),
      logger: resultsLogger
    });
    const dryrunLogger = logger.child("dryrun");
    const dryrun2 = dryrunWith({
      dryrunFetch: dryrunFetchWith({
        fetch: fetch2,
        CU_URL: CU_URL2,
        logger: dryrunLogger
      }),
      logger: dryrunLogger
    });
    const assignLogger = logger.child("assign");
    const assign2 = assignWith({
      deployAssign: deployAssignWith({
        fetch: fetch2,
        MU_URL: MU_URL2,
        logger: assignLogger
      }),
      logger: messageLogger
    });
    const getMessageById2 = messageIdWith({
      getMessageId: getMessageById({ fetch: fetch2, locate: import_ao_scheduler_utils.locate })
    });
    const getMessages = messagesWith({
      messages: getMessagesByRange({ fetch: fetch2, locate: import_ao_scheduler_utils.locate })
    });
    const getLastSlot = processIdWith({
      processId: getLastSlotWith({
        fetch: fetch2,
        locate: import_ao_scheduler_utils.locate
      })
    });
    return {
      MODE,
      result: result2,
      results: results2,
      message: message2,
      spawn: spawn2,
      monitor: monitor2,
      unmonitor: unmonitor2,
      dryrun: dryrun2,
      assign: assign2,
      createDataItemSigner: createDataItemSigner3,
      signMessage,
      sendSignedMessage,
      getMessages,
      getLastSlot,
      getMessageById: getMessageById2
    };
  }
  function mainnetMode({
    MODE,
    signer,
    GRAPHQL_URL: GRAPHQL_URL2,
    device = DEFAULT_DEVICE,
    URL: URL2 = DEFAULT_RELAY_URL,
    MU_URL: MU_URL2 = DEFAULT_RELAY_MU_URL,
    CU_URL: CU_URL2 = DEFAULT_RELAY_CU_URL,
    fetch: fetch2 = defaultFetch
  }) {
    const logger = _logger.child("mainnet-process");
    logger("Mode Activated %s", "\u{1F432}");
    if (!signer) {
      throw new Error("mainnet mode requires providing a signer to connect()");
    }
    const mainnetDataItemSigner = signer ? () => signer : createDataItemSigner3;
    const mainnetSigner = signer ? () => signer : createSigner3;
    const getMessageById2 = messageIdWith({
      getMessageId: getMessageById({ fetch: fetch2, locate: import_ao_scheduler_utils.locate })
    });
    const getMessages = messagesWith({
      messages: getMessagesByRange({ fetch: fetch2, locate: import_ao_scheduler_utils.locate })
    });
    const getLastSlot = processIdWith({
      processId: getLastSlotWith({
        fetch: fetch2,
        locate: import_ao_scheduler_utils.locate
      })
    });
    const requestLogger = logger.child("request");
    const request = requestWith2({
      signer,
      logger: requestLogger,
      MODE,
      method: "GET",
      request: requestWith({
        fetch: defaultFetch,
        logger: requestLogger,
        HB_URL: URL2,
        signer
      })
    });
    return {
      MODE: "mainnet",
      request,
      createSigner: mainnetSigner,
      createDataItemSigner: mainnetDataItemSigner,
      getMessages,
      getLastSlot,
      getMessageById: getMessageById2
      /**
      * do we want helpers for payments?
      *
      * - getOperator
      * - getNodeBalance
      */
    };
  }
  function connect2(args = {}) {
    let { GRAPHQL_URL: GRAPHQL_URL2, GATEWAY_URL: GATEWAY_URL2 = DEFAULT_GATEWAY_URL, ...restArgs } = args;
    if (!GRAPHQL_URL2) {
      GRAPHQL_URL2 = joinUrl({ url: GATEWAY_URL2, path: "/graphql" });
    }
    const MODE = args.MODE || "legacy";
    if (MODE === "legacy") return legacyMode({ ...restArgs, GRAPHQL_URL: GRAPHQL_URL2 });
    if (MODE === "mainnet") return mainnetMode({ ...restArgs, GRAPHQL_URL: GRAPHQL_URL2 });
    throw new Error(`Unrecognized MODE: ${MODE}`);
  }
  return connect2;
}

// src/client/node/wallet.js
var wallet_exports = {};
__export(wallet_exports, {
  createDataItemSigner: () => createDataItemSigner,
  createSigner: () => createSigner
});
var import_node_crypto = require("node:crypto");
function createANS104Signer({ privateKey, publicKey, address }) {
  const signer = async (create) => {
    const deepHash = await create({
      type: 1,
      publicKey,
      alg: "rsa-v1_5-sha256"
    });
    const signature = (0, import_node_crypto.createSign)("sha256").update(deepHash).sign({ key: privateKey, padding: import_node_crypto.constants.RSA_PKCS1_PSS_PADDING });
    return { signature, address };
  };
  return signer;
}
function createHttpSigner({ publicKey, privateKey, address }) {
  const signer = async (create) => {
    const signatureBase = await create({
      type: 1,
      publicKey,
      alg: "rsa-pss-sha512"
    });
    const signature = (0, import_node_crypto.createSign)("sha512").update(signatureBase).sign({ key: privateKey, padding: import_node_crypto.constants.RSA_PKCS1_PSS_PADDING });
    return { signature, address };
  };
  return signer;
}
function createSigner(wallet) {
  const publicKey = Buffer.from(wallet.n, "base64url");
  const privateKey = (0, import_node_crypto.createPrivateKey)({ key: wallet, format: "jwk" });
  const address = (0, import_node_crypto.createHash)("sha256").update(publicKey).digest("base64url");
  const dataItemSigner = createANS104Signer({ wallet, privateKey, publicKey, address });
  const httpSigner = createHttpSigner({ wallet, publicKey, privateKey, address });
  const signer = (create, kind) => {
    if (kind === DATAITEM_SIGNER_KIND) return dataItemSigner(create);
    if (kind === HTTP_SIGNER_KIND) return httpSigner(create);
    throw new Error(`signer kind unknown "${kind}"`);
  };
  return signer;
}
var createDataItemSigner = createSigner;

// src/index.js
var GATEWAY_URL = process.env.GATEWAY_URL || void 0;
var MU_URL = process.env.MU_URL || void 0;
var CU_URL = process.env.CU_URL || void 0;
var GRAPHQL_URL = process.env.GRAPHQL_URL || void 0;
var GRAPHQL_MAX_RETRIES = process.env.GRAPHQL_MAX_RETRIES || void 0;
var GRAPHQL_RETRY_BACKOFF = process.env.GRAPHQL_RETRY_BACKOFF || void 0;
var RELAY_URL = process.env.RELAY_URL || void 0;
var AO_URL = process.env.AO_URL = void 0;
var connect = connectWith({
  createDataItemSigner: wallet_exports.createDataItemSigner,
  createSigner: wallet_exports.createSigner
});
var createDataItemSigner2 = wallet_exports.createDataItemSigner;
var createSigner2 = wallet_exports.createSigner;
var { result, results, message, spawn, monitor, unmonitor, dryrun, assign } = connect({
  MODE: "legacy",
  GATEWAY_URL,
  MU_URL,
  CU_URL,
  RELAY_URL,
  AO_URL,
  GRAPHQL_URL,
  GRAPHQL_MAX_RETRIES,
  GRAPHQL_RETRY_BACKOFF,
  noLog: true
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  assign,
  connect,
  createDataItemSigner,
  createSigner,
  dryrun,
  message,
  monitor,
  result,
  results,
  serializeCron,
  spawn,
  unmonitor
});
