// src/client/gateway.js
import { defaultTo, find, juxt, path, pipe, prop } from "ramda";

// src/err.js
var InvalidSchedulerLocationError = class extends Error {
  name = "InvalidSchedulerLocation";
};
var SchedulerTagNotFoundError = class extends Error {
  name = "SchedulerTagNotFound";
};
var TransactionNotFoundError = class extends Error {
  name = "TransactionNotFound";
};

// src/utils.js
function trimSlash(str = "") {
  str = str.trim();
  return str.endsWith("/") ? trimSlash(str.slice(0, -1)) : str;
}
var backoff = (fn, { maxRetries = 0, delay = 300 }) => {
  const action = (retry, delay2) => {
    return Promise.resolve().then(fn).catch((err) => {
      if (retry >= maxRetries) {
        return Promise.reject(err);
      }
      const newRetry = retry + 1;
      const newDelay = delay2 + delay2;
      return new Promise((resolve) => setTimeout(resolve, delay2)).then(() => action(newRetry, newDelay));
    });
  };
  return action(0, delay);
};
var okRes = (res) => {
  if (res.ok)
    return res;
  throw res;
};

// src/client/gateway.js
var URL_TAG = "Url";
var TTL_TAG = "Time-To-Live";
var SCHEDULER_TAG = "Scheduler";
var findTagValue = (name) => pipe(
  defaultTo([]),
  find((tag) => tag.name && tag.name.toLowerCase() === name.toLowerCase()),
  defaultTo({}),
  prop("value")
);
var findTransactionTags = (err) => pipe(
  (transaction) => {
    if (!transaction)
      throw new TransactionNotFoundError(err);
    return transaction;
  },
  prop("tags"),
  defaultTo([])
);
var parseHyperBeamResponse = (process2) => {
  const commitments = process2.commitments;
  const processId = Object.keys(commitments).find((key) => commitments[key].type === "rsa-pss-sha256");
  if (!processId) {
    return { id: void 0, tags: [] };
  }
  const signedCommitment = commitments[processId];
  const committed = signedCommitment.committed;
  const originalTags = Object.values(signedCommitment["original-tags"] ?? {});
  const data = process2.data;
  const tags = [];
  if (!originalTags || originalTags.length === 0) {
    delete process2.data;
    const tags2 = Object.keys(process2).map((key) => ({ name: key, value: process2[key] }));
    return { id: processId, tags: tags2, data };
  }
  for (const tag of originalTags) {
    const { name, value } = tag;
    if (committed.includes(name.toLowerCase()) && name.toLowerCase() !== "data") {
      tags.push({ name, value });
    }
  }
  return { id: processId, tags, data };
};
function gatewayWith({ fetch: fetch2, GRAPHQL_URL: GRAPHQL_URL2, GRAPHQL_MAX_RETRIES: GRAPHQL_MAX_RETRIES2 = 0, GRAPHQL_RETRY_BACKOFF: GRAPHQL_RETRY_BACKOFF2 = 300 }) {
  return async ({ query, variables }) => {
    return backoff(
      () => fetch2(GRAPHQL_URL2, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ query, variables })
      }).then(okRes).then((res) => res.json()),
      { maxRetries: GRAPHQL_MAX_RETRIES2, delay: GRAPHQL_RETRY_BACKOFF2 }
    );
  };
}
function loadProcessWith({ fetch: fetch2, HB_GRAPHQL_URL, GRAPHQL_URL: GRAPHQL_URL2, GRAPHQL_MAX_RETRIES: GRAPHQL_MAX_RETRIES2, GRAPHQL_RETRY_BACKOFF: GRAPHQL_RETRY_BACKOFF2 }) {
  const gateway = gatewayWith({ fetch: fetch2, GRAPHQL_URL: GRAPHQL_URL2, GRAPHQL_MAX_RETRIES: GRAPHQL_MAX_RETRIES2, GRAPHQL_RETRY_BACKOFF: GRAPHQL_RETRY_BACKOFF2 });
  const GET_PROCESS_QUERY = `
        query ($ids: [ID!]!) {
        transactions(
          ids: $ids
        ) {
          pageInfo {
            hasNextPage
          }
          edges {
            cursor
            node {
              id
              anchor
              signature
              recipient
              block {
                timestamp
              }
              owner {
                address
                key
              }
              fee {
                winston
                ar
              }
              quantity {
                winston
                ar
              }
              data {
                size
                type
              }
              tags {
                name
                value
              }
              block {
                id
                timestamp
                height
                previous
              }
              parent {
                id
              }
            }
          }
        }
      }
  `;
  return async (process2) => {
    return fetch2(`${HB_GRAPHQL_URL}/${process2}?require-codec=application/json`, {
      headers: {
        Accept: "application/json"
      }
    }).then((res) => res.json()).then(parseHyperBeamResponse).catch((_e) => {
      return gateway({ query: GET_PROCESS_QUERY, variables: { ids: [process2] } }).then(path(["data", "transactions", "edges", "0", "node"]));
    });
  };
}
function loadProcessSchedulerWith({ fetch: fetch2, GRAPHQL_URL: GRAPHQL_URL2, GRAPHQL_MAX_RETRIES: GRAPHQL_MAX_RETRIES2, GRAPHQL_RETRY_BACKOFF: GRAPHQL_RETRY_BACKOFF2 }) {
  const gateway = gatewayWith({ fetch: fetch2, GRAPHQL_URL: GRAPHQL_URL2, GRAPHQL_MAX_RETRIES: GRAPHQL_MAX_RETRIES2, GRAPHQL_RETRY_BACKOFF: GRAPHQL_RETRY_BACKOFF2 });
  const loadScheduler = loadSchedulerWith({ fetch: fetch2, GRAPHQL_URL: GRAPHQL_URL2, GRAPHQL_MAX_RETRIES: GRAPHQL_MAX_RETRIES2, GRAPHQL_RETRY_BACKOFF: GRAPHQL_RETRY_BACKOFF2 });
  const GET_TRANSACTIONS_QUERY = `
    query GetTransactions ($transactionIds: [ID!]!) {
      transactions(
        ids: $transactionIds
        tags: [
          { name: "Data-Protocol", values: ["ao"] }
        ]
      ) {
        edges {
          node {
            tags {
              name
              value
            }
          }
        }
      }
    }
  `;
  const TESTNET_SU_ROUTER = "https://su-router.ao-testnet.xyz";
  return async (process2) => {
    const eagerTestnet = await fetch2(`https://su-router.ao-testnet.xyz?process-id=${process2}`).then(
      (res) => !res.ok ? void 0 : res.json().then(({ address }) => ({
        url: TESTNET_SU_ROUTER,
        ttl: 1e3 * 60 * 60 * 48,
        address
      }))
    );
    if (eagerTestnet)
      return eagerTestnet;
    return gateway({ query: GET_TRANSACTIONS_QUERY, variables: { transactionIds: [process2] } }).then(path(["data", "transactions", "edges", "0", "node"])).then(findTransactionTags(`Process ${process2} was not found on gateway`)).then(findTagValue(SCHEDULER_TAG)).then((walletAddress) => {
      if (!walletAddress)
        throw new SchedulerTagNotFoundError('No "Scheduler" tag found on process');
      return loadScheduler(walletAddress);
    });
  };
}
function loadSchedulerWith({ fetch: fetch2, GRAPHQL_URL: GRAPHQL_URL2, GRAPHQL_MAX_RETRIES: GRAPHQL_MAX_RETRIES2, GRAPHQL_RETRY_BACKOFF: GRAPHQL_RETRY_BACKOFF2 }) {
  const gateway = gatewayWith({ fetch: fetch2, GRAPHQL_URL: GRAPHQL_URL2, GRAPHQL_MAX_RETRIES: GRAPHQL_MAX_RETRIES2, GRAPHQL_RETRY_BACKOFF: GRAPHQL_RETRY_BACKOFF2 });
  const GET_SCHEDULER_LOCATION = `
    query GetSchedulerLocation ($owner: String!) {
      transactions (
        owners: [$owner]
        tags: [
          { name: "Data-Protocol", values: ["ao"] },
          { name: "Type", values: ["Scheduler-Location"] }
        ]
        # Only need the most recent Scheduler-Location
        sort: HEIGHT_DESC
        first: 1
      ) {
        edges {
          node {
            tags {
              name
              value
            }
          }
        }
      }
    }
  `;
  return async (walletAddress) => gateway({ query: GET_SCHEDULER_LOCATION, variables: { owner: walletAddress } }).then(path(["data", "transactions", "edges", "0", "node"])).then(findTransactionTags(`Could not find 'Scheduler-Location' owner by wallet ${walletAddress}`)).then(juxt([
    findTagValue(URL_TAG),
    findTagValue(TTL_TAG)
  ])).then(([url, ttl]) => {
    if (!url)
      throw new InvalidSchedulerLocationError('No "Url" tag found on Scheduler-Location');
    if (!ttl)
      throw new InvalidSchedulerLocationError('No "Time-To-Live" tag found on Scheduler-Location');
    return { url, ttl, address: walletAddress };
  });
}

// src/client/in-memory.js
import { LRUCache } from "lru-cache";
function createLruCache({ size }) {
  const cache = new LRUCache({
    /**
     * number of entries
     */
    max: size,
    /**
     * max size of cache, as a scalar.
     *
     * In our case, characters (see sizeCalculation)
     */
    maxSize: 1e6 * 5,
    /**
     * Simply stringify to get the bytes
     */
    sizeCalculation: (v) => JSON.stringify(v).length,
    allowStale: true
  });
  return cache;
}
function getByProcessWith({ cache }) {
  return async (process2) => {
    if (!cache.max)
      return;
    return cache.get(process2);
  };
}
function setByProcessWith({ cache }) {
  return async (process2, { url, address }, ttl) => {
    if (!cache.max)
      return;
    return cache.set(process2, { url, address }, { ttl });
  };
}
function getByOwnerWith({ cache }) {
  return async (owner) => {
    if (!cache.max)
      return;
    return cache.get(owner);
  };
}
function setByOwnerWith({ cache }) {
  return async (owner, url, ttl) => {
    if (!cache.max)
      return;
    return cache.set(owner, { url, address: owner, ttl }, { ttl });
  };
}
function getProcessResponseWith({ cache }) {
  return async (process2) => {
    if (!cache.max)
      return;
    return cache.get(process2);
  };
}
function setProcessResponseWith({ cache }) {
  return async (process2, processResponse, ttl) => {
    if (!cache.max)
      return;
    return cache.set(process2, processResponse, { ttl });
  };
}

// src/client/scheduler.js
function checkForRedirectWith({ fetch: fetch2 }) {
  return async (url, process2) => {
    const response = await fetch2(`${url}?process-id=${process2}`, { method: "GET", redirect: "manual" });
    if ([301, 302, 307, 308].includes(response.status)) {
      return new URL(response.headers.get("Location")).origin;
    }
    return url;
  };
}

// src/dal.js
import { z } from "zod";
var processCacheEntry = z.object({ url: z.string(), address: z.string() });
var scheduler = z.object({ url: z.string(), address: z.string(), ttl: z.coerce.number() });
var checkForRedirectSchema = z.function().args(z.string(), z.string()).returns(z.promise(z.string()));
var getByProcessSchema = z.function().args(z.string()).returns(z.promise(processCacheEntry.nullish()));
var setByProcessSchema = z.function().args(z.string(), processCacheEntry, z.number()).returns(z.promise(z.any()));
var getByOwnerSchema = z.function().args(z.string()).returns(z.promise(scheduler.nullish()));
var setByOwnerSchema = z.function().args(z.string(), z.string(), z.number()).returns(z.promise(z.any()));
var loadSchedulerSchema = z.function().args(z.string()).returns(z.promise(scheduler));
var loadProcessSchedulerSchema = loadSchedulerSchema;

// src/locate.js
function locateWith({ loadProcessScheduler, loadScheduler, cache, followRedirects, checkForRedirect }) {
  loadProcessScheduler = loadProcessSchedulerSchema.implement(loadProcessScheduler);
  loadScheduler = loadSchedulerSchema.implement(loadScheduler);
  checkForRedirect = checkForRedirectSchema.implement(checkForRedirect);
  const getByProcess = getByProcessSchema.implement(cache.getByProcess);
  const getByOwner = getByOwnerSchema.implement(cache.getByOwner);
  const setByProcess = setByProcessSchema.implement(cache.setByProcess);
  const setByOwner = setByOwnerSchema.implement(cache.setByOwner);
  return (process2, schedulerHint) => getByProcess(process2).then(async (cached) => {
    if (cached)
      return cached;
    return Promise.resolve().then(async () => {
      if (schedulerHint) {
        const byOwner = await getByOwner(schedulerHint);
        if (byOwner)
          return byOwner;
        return loadScheduler(schedulerHint).then((scheduler2) => {
          setByOwner(scheduler2.address, scheduler2.url, scheduler2.ttl);
          return scheduler2;
        });
      }
      return loadProcessScheduler(process2);
    }).then(async (scheduler2) => {
      let finalUrl = scheduler2.url;
      if (followRedirects)
        finalUrl = await checkForRedirect(scheduler2.url, process2);
      const byProcess = { url: trimSlash(finalUrl), address: scheduler2.address };
      await setByProcess(process2, byProcess, scheduler2.ttl);
      return byProcess;
    });
  });
}

// src/raw.js
function rawWith({ loadScheduler, cache }) {
  loadScheduler = loadSchedulerSchema.implement(loadScheduler);
  const getByOwner = getByOwnerSchema.implement(cache.getByOwner);
  const setByOwner = setByOwnerSchema.implement(cache.setByOwner);
  return (address) => getByOwner(address).then((cached) => {
    if (cached)
      return { url: cached.url };
    return loadScheduler(address).then(
      (scheduler2) => setByOwner(address, scheduler2.url, scheduler2.ttl).then(() => ({ url: trimSlash(scheduler2.url) }))
    ).catch((err) => {
      if (err instanceof InvalidSchedulerLocationError)
        return void 0;
      throw err;
    });
  });
}

// src/validate.js
function validateWith({ loadScheduler, cache }) {
  loadScheduler = loadSchedulerSchema.implement(loadScheduler);
  const getByOwner = getByOwnerSchema.implement(cache.getByOwner);
  const setByOwner = setByOwnerSchema.implement(cache.setByOwner);
  return (address) => getByOwner(address).then((cached) => {
    if (cached)
      return true;
    return loadScheduler(address).then((scheduler2) => setByOwner(address, scheduler2.url, scheduler2.ttl)).then(() => true).catch((err) => {
      if (err instanceof InvalidSchedulerLocationError)
        return false;
      throw err;
    });
  });
}

// src/getProcess.js
function getProcessWith({ getProcess, cache }) {
  const getProcessResponse = cache.getProcessResponse;
  const setProcessResponse = cache.setProcessResponse;
  return (process2) => getProcessResponse(process2).then(async (cached) => {
    if (cached)
      return cached;
    return Promise.resolve().then(() => {
      return getProcess(process2);
    }).then(async (processResponse) => {
      await setProcessResponse(process2, processResponse, 6e3);
      return processResponse;
    });
  });
}

// src/index.common.js
var DEFAULT_CACHE_SIZE = 100;
var DEFAULT_GRAPHQL_URL = "https://arweave.net/graphql";
var DEFAULT_HB_GRAPHQL_URL = "https://cache.forward.computer";
var DEFAULT_GRAPHQL_MAX_RETRIES = 0;
var DEFAULT_GRAPHQL_RETRY_BACKOFF = 300;
var DEFAULT_FOLLOW_REDIRECTS = false;
function connect({
  cacheSize = DEFAULT_CACHE_SIZE,
  followRedirects = DEFAULT_FOLLOW_REDIRECTS,
  GRAPHQL_URL: GRAPHQL_URL2 = DEFAULT_GRAPHQL_URL,
  GRAPHQL_MAX_RETRIES: GRAPHQL_MAX_RETRIES2 = DEFAULT_GRAPHQL_MAX_RETRIES,
  GRAPHQL_RETRY_BACKOFF: GRAPHQL_RETRY_BACKOFF2 = DEFAULT_GRAPHQL_RETRY_BACKOFF,
  HB_GRAPHQL_URL = DEFAULT_HB_GRAPHQL_URL
} = {}) {
  const _cache = createLruCache({ size: cacheSize });
  const _processCache = createLruCache({ size: cacheSize });
  const loadScheduler = loadSchedulerWith({ fetch, GRAPHQL_URL: GRAPHQL_URL2, GRAPHQL_MAX_RETRIES: GRAPHQL_MAX_RETRIES2, GRAPHQL_RETRY_BACKOFF: GRAPHQL_RETRY_BACKOFF2 });
  const cache = {
    getByProcess: getByProcessWith({ cache: _cache }),
    getByOwner: getByOwnerWith({ cache: _cache }),
    setByProcess: setByProcessWith({ cache: _cache }),
    setByOwner: setByOwnerWith({ cache: _cache })
  };
  const processCache = {
    getProcessResponse: getProcessResponseWith({ cache: _processCache }),
    setProcessResponse: setProcessResponseWith({ cache: _processCache })
  };
  const locate2 = locateWith({
    loadProcessScheduler: loadProcessSchedulerWith({ fetch, GRAPHQL_URL: GRAPHQL_URL2, GRAPHQL_MAX_RETRIES: GRAPHQL_MAX_RETRIES2, GRAPHQL_RETRY_BACKOFF: GRAPHQL_RETRY_BACKOFF2 }),
    loadScheduler,
    cache,
    followRedirects,
    checkForRedirect: checkForRedirectWith({ fetch })
  });
  const validate2 = validateWith({ loadScheduler, cache });
  const raw2 = rawWith({ loadScheduler, cache });
  const getProcess = getProcessWith({
    getProcess: loadProcessWith({ fetch, HB_GRAPHQL_URL, GRAPHQL_URL: GRAPHQL_URL2, GRAPHQL_MAX_RETRIES: GRAPHQL_MAX_RETRIES2, GRAPHQL_RETRY_BACKOFF: GRAPHQL_RETRY_BACKOFF2 }),
    cache: processCache
  });
  return { locate: locate2, validate: validate2, raw: raw2, getProcess };
}

// src/index.js
var GRAPHQL_URL = process.env.GRAPHQL_URL || void 0;
var CACHE_SIZE = process.env.SCHEDULER_UTILS_CACHE_SIZE || void 0;
var FOLLOW_REDIRECTS = process.env.SCHEDULER_UTILS_FOLLOW_REDIRECTS === "true" || void 0;
var GRAPHQL_MAX_RETRIES = process.env.GRAPHQL_MAX_RETRIES || void 0;
var GRAPHQL_RETRY_BACKOFF = process.env.GRAPHQL_RETRY_BACKOFF || void 0;
var { locate, validate, raw } = connect({ GRAPHQL_URL, cacheSize: CACHE_SIZE, followRedirects: FOLLOW_REDIRECTS, GRAPHQL_MAX_RETRIES, GRAPHQL_RETRY_BACKOFF });
export {
  InvalidSchedulerLocationError,
  SchedulerTagNotFoundError,
  TransactionNotFoundError,
  connect,
  locate,
  raw,
  validate
};
