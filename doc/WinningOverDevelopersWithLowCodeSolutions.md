
# ä¹Ÿè®¸æ˜¯ AO ç”Ÿæ€çš„èƒœåˆ©ä¹‹åŒ™ï¼šä»¥ä½ä»£ç èµ¢å¾—å¼€å‘è€…é’ç

# Perhaps the Key to Victory for the AO Ecosystem: Winning Over Developers with Low-Code Solutions


[rough-draft]


---

[AO](https://ao.arweave.dev/) æ˜¯è¿è¡Œåœ¨ [Arweave](https://www.arweave.org/) ä¸Šçš„è®¡ç®—æœºç³»ç»Ÿï¼Œæ—¨åœ¨å®ç°å¯éªŒè¯çš„æ— é™è®¡ç®—èƒ½åŠ›ã€‚

AOï¼Œæ˜¯ Actor Orientedï¼ˆé¢å‘å‚ä¸è€…ï¼‰çš„ç®€ç§°ã€‚é¡¾åæ€ä¹‰ï¼Œè¿™è¯´æ˜è¿è¡Œåœ¨ AO ä¸Šçš„å»ä¸­å¿ƒåŒ–åº”ç”¨éœ€è¦é‡‡ç”¨ [Actor æ¨¡å‹](https://en.wikipedia.org/wiki/Actor_mode)ä¸ºåŸºç¡€çš„è®¾è®¡å’Œç¼–ç¨‹æ–¹æ³•ã€‚ 

AO is a computing system running on Arweave, aimed at achieving verifiable infinite computational power.

AO stands for Actor Oriented. As the name suggests, this implies that decentralized applications running on AO need to adopt design and programming methods based on the [actor model](https://en.wikipedia.org/wiki/Actor_model).

----

äº‹å®ä¸Šï¼ŒAO å¹¶ä¸æ˜¯æœ€æ—©å°† Actor æ¨¡å‹ç”¨äºåŒºå—é“¾ï¼ˆæˆ–è€…è¯´â€œå»ä¸­å¿ƒåŒ–åŸºç¡€è®¾æ–½â€ï¼‰çš„ã€‚

In fact, AO is not the first to apply actor model to blockchain (or "decentralized infrastructure").

æ¯”å¦‚ï¼Œ[TON](https://docs.ton.org/learn/overviews/ton-blockchain) çš„æ™ºèƒ½åˆçº¦å°±æ˜¯ä½¿ç”¨ Actor æ¨¡å‹æ„å»ºçš„ã€‚

For example, smart contracts on [TON](https://docs.ton.org/learn/overviews/ton-blockchain) are built using the Actor model.

è¯´åˆ° TONï¼Œæˆ‘ä¸ªäººè§‰å¾—å®ƒå’Œ AO åœ¨æŸäº›æ–¹é¢é¢‡æœ‰ç›¸ä¼¼ä¹‹å¤„ã€‚

Speaking of TON, I personally find it quite similar to AO in some ways.

å¯¹äºå°šæœªæ·±å…¥äº†è§£ Web3 çš„ Web2 å¼€å‘è€…æ¥è¯´ï¼Œæƒ³è¦è¿…é€Ÿç†è§£ AO æˆ– TON ç›¸å¯¹å…¶ä»–â€œå•ä½“åŒºå—é“¾â€çš„æœ€å¤§ç‰¹è‰²ï¼Œä¸€ä¸ªæ–¹ä¾¿çš„æŠ“æ‰‹æ˜¯ï¼šæŠŠè¿è¡Œåœ¨å®ƒä»¬ä¹‹ä¸Šçš„æ™ºèƒ½åˆçº¦ï¼ˆé“¾ä¸Šç¨‹åºï¼‰æƒ³æˆæ˜¯â€œ[å¾®æœåŠ¡](https://en.wikipedia.org/wiki/Microservices)â€ã€‚è€Œ AO æˆ– TON æ˜¯æ”¯æŒè¿™äº›å¾®æœåŠ¡è¿è¡Œçš„åŸºç¡€è®¾æ–½ï¼Œæ¯”å¦‚ Kafkaã€Kubernetes ç­‰ã€‚

For Web2 developers who have not yet delved deeply into Web3, a convenient way to quickly grasp the most distinctive features of AO or TON, compared to other monolithic blockchains, is to think of the smart contracts (on-chain programs) running on them as [microservices](https://en.wikipedia.org/wiki/Microservices). AO or TON is the infrastructures that support these microservices, such as Kafka, Kubernetes, and so on.


---

é‚£ä¹ˆï¼Œå°† Actor æ¨¡å‹åº”ç”¨äºåŒºå—é“¾ï¼ŒçœŸçš„æœ‰å¿…è¦å—ï¼Ÿç­”æ¡ˆæ˜¯è‚¯å®šçš„ã€‚çœ‹çœ‹å·²ç»å–å¾—â€œå¤§è§„æ¨¡é‡‡ç”¨â€çš„ Web2 åº”ç”¨ï¼Œä½ å°±ä¼šæ˜ç™½ã€‚


Is the integration of the Actor model into blockchain technology truly essential? The answer is unequivocally affirmative. One only needs to observe the Web2 applications that have reached "mass adoption" to understand why.

---

å¤ªå¤šçš„æ¶æ„å¸ˆå·²ç»çŸ¥é“å¦‚ä½•å°† Web2 åº”ç”¨â€œæå¤§â€ï¼šå¾®æœåŠ¡æ¶æ„ï¼ˆMSAï¼‰ã€äº‹ä»¶é©±åŠ¨çš„æ¶æ„ï¼ˆEDAï¼‰ã€æ¶ˆæ¯é€šä¿¡æœºåˆ¶ã€æœ€ç»ˆä¸€è‡´æ€§æ¨¡å‹ã€åˆ†ç‰‡â€¦â€¦è¿™äº›ä¸œè¥¿ï¼Œä¸ç®¡å«ä»€ä¹ˆï¼Œæ€»æ˜¯ä¸ Actor æ¨¡å‹å…±ç”Ÿå…±å­˜çš„ã€‚å…¶ä¸­çš„ä¸€äº›æ¦‚å¿µï¼Œç”šè‡³å¯ä»¥è¯´åªæ˜¯ä¸€ä¸ªäº‹ç‰©çš„ä¸åŒæ–¹é¢ã€‚

Numerous architects are already versed in making Web2 applications bigger and bigger through strategies such as Microservice Architecture (MSA), Event-Driven Architecture (EDA), messaging mechanisms, and the Eventual Consistency model, Sharding... These things, whatever they may be called, are always symbiotic with the Actor model.  Some of these concepts can even be described as just different aspects of one thing.

---

ä»Šæ—¥äº’è”ç½‘çš„ç¹è£ï¼Œç¦»ä¸å¼€è¿™äº›æ¶æ„å¸ˆçš„æ™ºæ…§ã€‚ä»–ä»¬ä¸æ–­åœ°æ¢ç´¢ã€å®è·µã€æ€»ç»“ï¼Œæœ€ç»ˆå½¢æˆäº†ä¸€å¥—å®Œæ•´çš„å·¥ç¨‹å®è·µä½“ç³»ã€‚

The flourishing state of today's Internet owes much to the ingenuity of its architects. They have persistently explored, experimented, and reflected, culminating in the establishment of a comprehensive framework of engineering practices.

---

ä½œä¸º Web3 åŸºç¡€è®¾æ–½ï¼ŒAO åšçš„å¾ˆæ£’ã€‚
æœ€å°‘ï¼ŒAO ä½œä¸ºï¼ˆæˆ‘çœ¼ä¸­çš„ï¼‰å½“å‰ Web3 é¢†åŸŸçš„æœ€ä½³å»ä¸­å¿ƒåŒ–æ¶ˆæ¯ä»£ç†ï¼Œå·²ç»å±•ç°å‡ºå·¨å¤§çš„æ½œåŠ›ã€‚

æˆ‘ç›¸ä¿¡ä¼ ç»Ÿ Web2 åº”ç”¨çš„å¼€å‘è€…ç”±æ­¤å¯ä»¥é©¬ä¸Šç†è§£å…¶ä¸­çš„é‡å¤§æ„ä¹‰ï¼š

å€˜è‹¥æ²¡æœ‰ [Kafka](https://kafka.apache.org) æˆ–è€…ç±» Kafka çš„æ¶ˆæ¯ä»£ç†å¯ç”¨ï¼Œä½ èƒ½æƒ³è±¡ç°åœ¨å¾ˆå¤šå¤§å‹çš„äº’è”ç½‘åº”ç”¨â€œç¨‹åºè¦æ€ä¹ˆå†™â€å—ï¼Ÿ


As a piece of Web3 infrastructure, AO has been outstanding.
At the very least, AO has shown great potential as what I consider to be the best decentralized messaging agent in the Web3 space today.

I believe that developers from the traditional Web2 space can immediately grasp the profound implications of this:

Can you imagine how the programming of many of today's large-scale internet applications would be without the availability of [Kafka](https://kafka.apache.org) or Kafka-like message brokers?


----

è™½ç„¶ Actor æ¨¡å‹åœ¨å¾ˆå¤šæ–¹é¢å…·æœ‰ç†è®ºä¸Šçš„ä¼˜åŠ¿ï¼Œä½†æ˜¯ä¸ç®¡æ˜¯ Actor æ¨¡å‹ä¹Ÿå¥½ï¼Œå¾®æœåŠ¡æ¶æ„ä¹Ÿå¥½ï¼Œåœ¨æˆ‘çœ‹æ¥ï¼Œæ›´å¤šæ˜¯å¼€å‘è€…ä¸ºäº†å¼€å‘æŸäº›åº”ç”¨ï¼ˆç‰¹åˆ«æ˜¯å¤§å‹åº”ç”¨ï¼‰æ‰€ä¸å¾—ä¸æ‰¿å—ä¹‹â€œæ¶â€ã€‚

Although the Actor model has theoretical advantages in many respects, whether it's the Actor model or Microservice Architecture (MSA), in my view, they often represent a necessary "evil" that developers must contend with when building certain applications, particularly large-scale ones.

--------

è®©æˆ‘ä»¬ç”¨ä¸€ä¸ªç®€å•çš„ä¾‹å­æ¥å‘éæŠ€æœ¯è¯»è€…è¯´æ˜è¿™ä¸€ç‚¹ã€‚å‡è®¾ä¸–ç•Œä¸Šæ‰€æœ‰é“¶è¡Œéƒ½åŸºäºä¸€ä¸ªâ€œä¸–ç•Œè®¡ç®—æœºâ€æ¥å¼€å±•ä¸šåŠ¡ï¼Œè€Œè¿™ä¸ªä¸–ç•Œè®¡ç®—æœºæ˜¯ä¸€ä¸ªå•ä½“æ¶æ„çš„ç³»ç»Ÿã€‚é‚£ä¹ˆï¼Œå½“å·¥å•†é“¶è¡Œçš„å®¢æˆ·â€œå¼ ä¸‰â€å‘åœ¨æ‹›å•†é“¶è¡Œå¼€è®¾è´¦æˆ·çš„â€œæå››â€æ±‡æ¬¾ 100 å…ƒçš„æ—¶å€™ï¼Œå¼€å‘è€…å¯ä»¥è¿™æ ·ç¼–å†™è½¬è´¦ç¨‹åºçš„ä»£ç ï¼š

1. å¼€å§‹ä¸€ä¸ªäº‹åŠ¡ï¼ˆæˆ–è€…è¯´â€œäº¤æ˜“â€ï¼Œå®ƒä»¬åœ¨è‹±æ–‡ä¸­åŒä¸€ä¸ªè¯ï¼‰ï¼›
2. åœ¨å¼ ä¸‰çš„è´¦æˆ·ä¸Šæ‰£å‡ 100 å…ƒï¼›
3. åœ¨æå››çš„è´¦æˆ·ä¸Šå¢åŠ  100 å…ƒï¼›
4. æäº¤äº‹åŠ¡ã€‚

ä»¥ä¸Šæ­¥éª¤ä¸ç®¡å“ªä¸€æ­¥å‡ºç°é—®é¢˜ï¼Œæ¯”å¦‚è¯´ç¬¬ä¸‰æ­¥ï¼Œåœ¨æå››çš„è´¦æˆ·ä¸Šå¢åŠ é‡‘é¢ï¼Œå› ä¸ºæŸç§åŸå› å¤±è´¥äº†ï¼Œé‚£ä¹ˆæ•´ä¸ªæ“ä½œéƒ½ä¼šè¢«å›æ»šï¼Œå°±åƒä»€ä¹ˆéƒ½æ²¡æœ‰å‘ç”Ÿè¿‡ä¸€æ ·ã€‚
å¯¹äº†ï¼Œç¨‹åºè¿™æ ·å†™ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºé‡‡ç”¨â€œå¼ºä¸€è‡´æ€§â€æ¨¡å‹ã€‚

Let's use a simple example to illustrate this point to the non-technical reader. Imagine all the banks in the world operated on a "World Computer," a monolithic system. In this scenario, when a customer from ICBC named "John Doe" transfers $100 to "Jane Doe," who has an account at China Merchants Bank, a developer might code the transfer process like this:

1. Start a transaction;
2. Deduct $100 from John Doe's account;
3. Credit $100 to Jane Doe's account;
4. Commit the transaction.

If any step encounters an issue, such as step 3 where crediting Jane Doe's account fails for some reason, the entire operation would be rolled back, as if nothing had happened.
By the way, when the program is written this way, we say that it adopts the Strong Consistency model.

--------

å€˜è‹¥è¿™ä¸ªä¸–ç•Œè®¡ç®—æœºæ˜¯ä¸ªé‡‡ç”¨ MSA çš„ç³»ç»Ÿå‘¢ï¼Ÿé‚£ä¹ˆï¼Œç®¡ç†å·¥å•†é“¶è¡Œè´¦æˆ·çš„é‚£ä¸ªå¾®æœåŠ¡ï¼ˆæˆ–è€…è¯´ Actorï¼‰ä¸ç®¡ç†æ‹›å•†é“¶è¡Œè´¦æˆ·çš„é‚£ä¸ªå¾®æœåŠ¡ï¼Œå‡ ä¹ä¸å¤ªå¯èƒ½æ˜¯åŒä¸€ä¸ªã€‚æˆ‘ä»¬å…ˆå‡è®¾å®ƒä»¬ç¡®å®ä¸æ˜¯åŒä¸€ä¸ªï¼Œå‰è€…æˆ‘ä»¬ç§°ä¸º Actor ICBCï¼Œåè€…æˆ‘ä»¬ç§°ä¸º Actor CMBã€‚æ­¤æ—¶ï¼Œå¼€å‘è€…å¯èƒ½éœ€è¦è¿™æ ·ç¼–å†™è½¬è´¦çš„ä»£ç ï¼š

1. Actor ICBC å…ˆè®°å½•å¥½ä»¥ä¸‹ä¿¡æ¯ï¼šâ€œå¼ ä¸‰å‘æå››è½¬è´¦100 å…ƒâ€ï¼›
2. Actor ICBC åœ¨å¼ ä¸‰çš„è´¦æˆ·ä¸Šæ‰£å‡ 100 å…ƒï¼Œå¹¶å‘ Actor CMB å‘é€ä¸€æ¡æ¶ˆæ¯ï¼šâ€œå¼ ä¸‰å‘æå››è½¬è´¦100 å…ƒâ€ï¼›
3. Actor CMB æ”¶åˆ°æ¶ˆæ¯ï¼Œåœ¨æå››çš„è´¦æˆ·ä¸Šå¢åŠ  100 å…ƒï¼Œç„¶åå‘ Actor ICBC å‘é€ä¸€æ¡æ¶ˆæ¯â€œæå››å·²æ”¶åˆ°å¼ ä¸‰æ±‡å…¥çš„ 100 å…ƒâ€ï¼›
4. Actor ICBC æ”¶åˆ°æ¶ˆæ¯ï¼Œè®°å½•å¥½ï¼šâ€œå¼ ä¸‰å‘æå››è½¬è´¦ 100 å…ƒï¼Œå·²æˆåŠŸâ€ã€‚

ä¸Šé¢åªæ˜¯â€œä¸€åˆ‡éƒ½å¥½â€çš„è¿‡ç¨‹ã€‚ä½†æ˜¯ï¼Œå¦‚æœæŸä¸ªæ­¥éª¤ï¼Œæ¯”å¦‚è¯´ç¬¬ä¸‰ä¸ªæ­¥éª¤ï¼Œâ€œåœ¨æå››çš„è´¦æˆ·ä¸Šå¢åŠ  100 å…ƒâ€ï¼Œå‡ºç°äº†é—®é¢˜ï¼Œæ€ä¹ˆåŠï¼Ÿ

What if this World Computer were a system using a Microservice Architecture (MSA)? In that case, the microservice managing the ICBC accounts and the one managing the CMB accounts would almost certainly not be the same. Let's assume they are indeed different; the former is called Actor ICBC, and the latter is called Actor CMB. Under these circumstances, a developer might write the code for the transfer process as follows:

1. Actor ICBC records the following information: "John Doe transfers $100 to Jane Doe."
2. Actor ICBC deducts 100 yuan from John Doe's account and sends a message to Actor CMB: "John Doe transfers $100 to Jane Doe."
3. Upon receiving the message, Actor CMB adds $100 to Jane Doe's account and then sends a message back to Actor ICBC: "Jane Doe has received the $100 transferred by John Doe."
4. Actor ICBC, upon receiving the confirmation, records: "The transfer of $100 from John Doe to Jane Doe was successful."

The above describes the process when everything goes well. But what if there's a problem at some step, such as the third step, "adds $100 to Jane Doe's account"?

---

å¼€å‘è€…éœ€è¦é’ˆå¯¹è¿™ä¸ªå¯èƒ½å‘ç”Ÿçš„é—®é¢˜ï¼Œç¼–å†™è¿™æ ·çš„å¤„ç†é€»è¾‘ï¼š

* Actor CMB å‘ Actor ICBC å‘é€ä¸€æ¡æ¶ˆæ¯ï¼šâ€œå¼ ä¸‰å‘æå››è½¬è´¦ 100 å…ƒï¼Œå¤„ç†å¤±è´¥â€ã€‚  
* Actor ICBC æ”¶åˆ°æ¶ˆæ¯ï¼Œåœ¨å¼ ä¸‰çš„è´¦æˆ·ä¸Šå¢åŠ  100 å…ƒï¼Œå¹¶è®°å½•ï¼šâ€œå¼ ä¸‰å‘æå››è½¬è´¦ 100 å…ƒï¼Œå·²å¤±è´¥â€ã€‚

For this possible problem, developers need to write such processing logic:

*  Actor CMB sends a message to Actor ICBC: "John Doe's transfer of $100 to Jane Doe has failed."
* Upon receiving the message, Actor ICBC adds $100 back to John Doe's account and records: "John Doe's transfer of 100 yuan to Jane Doe has failed."

---


ç¨‹åºè¿™æ ·å†™ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºé‡‡ç”¨æœ€ç»ˆä¸€è‡´æ€§æ¨¡å‹ã€‚

When the program is written in this way, we refer to it as adopting the Eventual Consistency model.

ä»¥ä¸Šï¼ŒéæŠ€æœ¯è¯»è€…åº”è¯¥èƒ½ç›´è§‚æ„Ÿå—åˆ°å¼€å‘å•ä½“æ¶æ„çš„åº”ç”¨ä¸å¼€å‘ MSA åº”ç”¨ä¹‹é—´çš„å·¨å¤§å·®å¼‚äº†å§ï¼Ÿ
è¦çŸ¥é“ï¼Œä¸Šé¢æ‰€è¯´çš„è½¬è´¦ç¤ºä¾‹åªæ˜¯ä¸€ä¸ªéå¸¸ç®€å•çš„åº”ç”¨è€Œå·²ï¼Œå¦‚æœæˆ‘ä»¬æŠŠå®ƒç§°ä¹‹ä¸ºåº”ç”¨ï¼Œè€Œä¸æ˜¯åŠŸèƒ½çš„è¯ã€‚å¤§å‹åº”ç”¨é‡Œé¢çš„åŠŸèƒ½å¾€å¾€æ¯”è¿™æ ·çš„ä¾‹å­è¦å¤æ‚çš„å¤ªå¤šã€‚

With the above comparison, non-technical readers should be able to visualize the huge difference between developing monolithic architecture applications and developing MSA applications, right?
It should be noted that the aforementioned transfer example is merely a very simple application, if we choose to call it an application rather than a feature.
The features within large applications are often much more complex than this example.

---

é‡‡ç”¨ MSA æ¶æ„ä¸€ä¸ªå¸¸è§çš„é—®é¢˜æ˜¯â€œè¿™ä¸ªå¾®æœåŠ¡åº”è¯¥å¤šå¤§ï¼Ÿâ€â€”â€”æˆ–è€…æ¢å¥è¯è¯´ï¼Œ"è¿™ä¸ªå¾®æœåŠ¡æ˜¯ä¸æ˜¯å¤ªå¤§äº†ï¼Œåº”è¯¥ä¸€åˆ†ä¸ºäºŒï¼Ÿâ€

å¾ˆä¸å¹¸ï¼Œè¿™ä¸ªé—®é¢˜æ²¡æœ‰æ ‡å‡†ç­”æ¡ˆï¼Œå®ƒæ˜¯ä¸€é—¨è‰ºæœ¯ğŸ˜‚ã€‚å¾®æœåŠ¡è¶Šå°ï¼Œå°±è¶Šå®¹æ˜“é€šè¿‡åˆ›å»ºæ–°å®ä¾‹å¹¶æŒ‰éœ€ç§»åŠ¨å®ƒä»¬æ¥ä¼˜åŒ–ç³»ç»Ÿã€‚ä½†æ˜¯ï¼Œå¾®æœåŠ¡è¶Šå°ï¼Œå¼€å‘äººå‘˜å°±è¶Šéš¾å®æ–½å¤æ‚çš„æµç¨‹ï¼Œæ­£å¦‚ä¸Šé¢å±•ç¤ºçš„é‚£æ ·ã€‚


When adopting a Microservice Architecture (MSA), a common question arises: "How large should a microservice be?" or put another way, "Is this microservice too large and in need of division?"

Unfortunately, there's no definitive answer to this dilemma, it's more of an artğŸ˜‚. The smaller the microservice, the more manageable it becomes to optimize the system by spawning new instances and relocating them as needed. However, the trade-off is that developers may find it more challenging to implement complex processes within tinier services, as illustrated earlier.


---


å¯¹äº†ï¼Œå°†ä¸€ä¸ªåº”ç”¨æ‹†åˆ†ä¸ºå¤šä¸ªå¾®æœåŠ¡ï¼Œä»æ•°æ®åº“è®¾è®¡è§’åº¦çœ‹ï¼Œå³æ‰€è°“çš„â€œåˆ†ç‰‡ï¼ˆShardingï¼‰â€ã€‚å¾®æœåŠ¡çš„æœ€ä½³å®è·µä¹‹ä¸€ï¼Œå°±æ˜¯æ¯ä¸ªå¾®æœåŠ¡ä»…ä½¿ç”¨ä¸€ä¸ªå±äºè‡ªå·±çš„æœ¬åœ°æ•°æ®åº“ã€‚ç®€å•æ¥è¯´ï¼Œåˆ†ç‰‡å…è®¸æ°´å¹³æ‰©å±•ã€‚å½“æ•°æ®é›†å˜å¾—å¤ªå¤§ï¼Œæ— æ³•é€šè¿‡ä¼ ç»Ÿæ–¹å¼å¤„ç†æ—¶ï¼Œé™¤äº†å°†å®ƒä»¬æ‹†åˆ†æˆæ›´å°çš„ç‰‡æ®µä»¥å¤–ï¼Œåˆ«æ— ä»–æ³•ï¼ˆæ¥è¿›è¡Œæ‰©å±•ï¼‰ã€‚

Incidentally, decomposing an application into multiple microservices is akin to what is termed "sharding" in the realm of database design. It is considered one of the best practices for microservices that each microservice operates exclusively with its own local database. In essence, sharding facilitates horizontal scaling. When datasets grow too voluminous to manage via conventional methods, the only recourse is to segment them into smaller, more manageable fragments.


---

è¿˜æœ‰ä»€ä¹ˆä¸œè¥¿å¯èƒ½æ„æˆå¤§å‹ Web2 åº”ç”¨è¿ç§»åˆ° AO ç”Ÿæ€çš„éšœç¢ï¼Ÿæˆ‘æƒ³è°ˆè°ˆè¯­è¨€å’Œç¨‹åºè¿è¡Œæ—¶çš„é—®é¢˜ã€‚

AO æ˜¯ä¸€ä¸ªæ•°æ®åè®®ã€‚ä½ å¯ä»¥è®¤ä¸ºå®ƒæ˜¯ä¸€å¥—å®šä¹‰ AO ç½‘ç»œä¸­çš„å„ä¸ªâ€œ[å•å…ƒ](https://cookbook_ao.g8way.io/concepts/units.html)â€å¦‚ä½•å®ç°åä½œçš„æ¥å£è§„èŒƒã€‚

ç›®å‰ï¼ŒAO çš„å®˜æ–¹å®ç°åŒ…å«äº†ä¸€ä¸ªåŸºäº WASM çš„è™šæ‹Ÿæœºç¯å¢ƒï¼Œä»¥åŠä¸€ä¸ªç¼–è¯‘ä¸ºWASM çš„ Lua è¿è¡Œæ—¶ç¯å¢ƒï¼ˆao-libï¼‰ï¼Œæ—¨åœ¨ç®€åŒ– AO è¿›ç¨‹çš„å¼€å‘ã€‚

Lua æ˜¯ä¸€ç§å°è€Œç¾çš„è¯­è¨€ã€‚

ä¸€èˆ¬è®¤ä¸ºï¼ŒLua çš„ä¼˜åŠ¿åœ¨äºå®ƒçš„è½»é‡çº§å’Œæ˜“äºåµŒå…¥å…¶ä»–è¯­è¨€ï¼Œè¿™ä½¿å¾—å®ƒåœ¨ç‰¹å®šåœºæ™¯ï¼ˆæ¯”å¦‚æ¸¸æˆå¼€å‘ï¼‰ä¸­ç‰¹åˆ«æœ‰ç”¨ã€‚

ä½†æ˜¯ï¼Œå¯¹äºå¼€å‘å¤§å‹äº’è”ç½‘åº”ç”¨æ¥è¯´ï¼ŒLua è¯­è¨€å¹¶ä¸æ˜¯ä¸»æµçš„é€‰æ‹©ã€‚å¤§å‹çš„äº’è”ç½‘åº”ç”¨å¼€å‘é€šå¸¸å€¾å‘äºä½¿ç”¨å¦‚ Javaã€C#ã€PHPã€Pythonã€JavaScriptã€Ruby ç­‰è¯­è¨€ï¼Œå› ä¸ºè¿™äº›è¯­è¨€æä¾›äº†æ›´å…¨é¢çš„ç”Ÿæ€ç³»ç»Ÿå’Œå·¥å…·é“¾ï¼Œä»¥åŠæ›´å¹¿æ³›çš„ç¤¾åŒºæ”¯æŒã€‚

æœ‰äººå¯èƒ½è¦äº‰è®ºï¼Œè¿™äº›è¯­è¨€éƒ½å¯ä»¥ç¼–è¯‘æˆ WASM å­—èŠ‚ç ï¼Œåœ¨ WASM è™šæ‹Ÿæœºé‡Œè¿è¡Œã€‚ä½†æ˜¯äº‹å®ä¸Šï¼Œç›®å‰äº’è”ç½‘åº”ç”¨é‡‡ç”¨ WASM ä½œä¸ºåç«¯çš„è¿è¡Œç¯å¢ƒå¹¶ä¸æ˜¯ä¸€ä¸ªä¸»æµé€‰æ‹©ï¼Œè™½ç„¶ WASM åœ¨ Web å‰ç«¯å¼€å‘é¢†åŸŸçš„è¡¨ç°å¾ˆå¼ºåŠ¿ã€‚æ³¨æ„ï¼Œæ™ºèƒ½åˆçº¦ï¼ˆé“¾ä¸Šç¨‹åºï¼‰æ˜¯ Web3 æ—¶ä»£çš„â€œæ–°åç«¯â€ã€‚


What other factors might pose obstacles to the migration of large Web2 applications to the AO ecosystem? I would like to discuss issues related to programming languages and runtime environments.

AO is a data protocol. Think of it as a set of interface standards that delineate how various [Units](https://cookbook_ao.g8way.io/concepts/units.html) within the AO network collaborate.

The official implementation of AO currently includes a WASM-based virtual machine environment, as well as a Lua runtime environment (ao-lib) that compiles to WASM, designed to allow for the easy development of processes in AO.

Lua is a compact and elegant language.

It is widely recognized that Lua's strengths are its lightweight design and its ease of embedding within other languages, making it particularly valuable in certain contexts, such as game development.

However, Lua is not the preferred language for developing large-scale internet applications. Development of substantial internet applications typically leans towards languages like Java, C#, PHP, Python, JavaScript, Ruby, etc., because these languages provide more extensive ecosystems and toolchains, along with broader community support.

Some might contend that all these languages can be compiled into WASM bytecode and executed within a WASM virtual machine. Yet, in reality, employing WASM as a backend runtime environment for internet applications is not a prevalent choice at present, despite WASM's strong performance in web frontend development. It's important to note that smart contracts (on-chain programs) represent the "new backend" in the Web3 era.

---

æˆ‘ä»¬éƒ½çŸ¥é“ï¼Œå…¬é“¾ä¹‹äº‰ï¼Œå…¶å®æ˜¯äº‰å¤ºåº”ç”¨å¼€å‘è€…çš„æˆ˜äº‰ã€‚
é‚£ä¹ˆ AO è¦å¦‚ä½•èµ¢å¾—å¼€å‘è€…å‘¢ï¼Ÿ

We all understand that the competition among public blockchains is essentially a battle to win over application developers.
So how does AO win over developers?

---

å³ä½¿åœ¨å·¥ç¨‹åŒ–æ›´æˆç†Ÿçš„ Web2 ç¯å¢ƒä¸­ï¼ŒåŸºäºæ¶ˆæ¯é€šä¿¡æ¥å®ç°â€œæœ€ç»ˆä¸€è‡´æ€§â€ï¼Œå¯¹äºè®¸å¤šå¼€å‘è€…è€Œè¨€éƒ½æ˜¯ä¸å°çš„æŒ‘æˆ˜ã€‚åœ¨æ–°ç”Ÿçš„ AO å¹³å°ä¸Šå¼€å‘ Dappï¼Œè¿™ä¸ªæŒ‘æˆ˜ä¼¼ä¹è¿˜è¦æ›´åŠ å‡¸æ˜¾ä¸€äº›ã€‚[è¿™ä¸ªé“¾æ¥](https://github.com/dddappp/A-AO-Demo?tab=readme-ov-file#an-ao-dapp-development-demo-with-a-low-code-approach)å°±å±•ç¤ºäº†ä¸€ä¸ªä¾‹å­ã€‚

Even within the more mature engineering landscape of Web2, implementing "eventual consistency" through message communication poses a significant challenge for numerous developers. This hurdle appears to be even more pronounced when developing Dapps on the emerging AO platform. The following [link](https://github.com/dddappp/A-AO-Demo?tab=readme-ov-file#an-ao-dapp-development-demo-with-a-low-code-approach) provides an illustrative example.

---

é‚£ä¹ˆï¼Œæ€ä¹ˆåŠå‘¢ï¼Ÿå½“ç„¶æ˜¯å‘å·²ç»è·å¾—â€œå¤§è§„æ¨¡é‡‡ç”¨â€çš„ Web2 å­¦ä¹ ã€‚å­¦ä¹ å®ƒçš„åŸºç¡€è®¾æ–½ã€å¼€å‘å·¥å…·ã€å·¥ç¨‹å®è·µï¼Œå‡¡æ­¤ç§ç§ã€‚

So, what's the next step? Naturally, it's to learn from Web2, which has already seen mass adoption. This includes understanding its infrastructure, development tools, engineering practices, and the like.

---


