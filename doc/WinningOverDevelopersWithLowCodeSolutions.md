
# ä¹Ÿè®¸æ˜¯ AO ç”Ÿæ€çš„èƒœåˆ©ä¹‹åŒ™ï¼šä»¥ä½ä»£ç èµ¢å¾—å¼€å‘è€…é’ç

# Perhaps the Key to Victory for the AO Ecosystem: Winning Over Developers with Low-code Solutions


[rough-draft]


---

æ˜¯ä»€ä¹ˆé˜»ç¢äº† Web3 çš„å¤§è§„æ¨¡é‡‡ç”¨ï¼Ÿ

å¾ˆç®€å•ï¼Œå› ä¸ºå€¼å¾—äººä»¬ä½¿ç”¨çš„å»ä¸­å¿ƒåŒ–åº”ç”¨å¤ªå°‘äº†ã€‚

åŸºäº Web3 åŸºç¡€è®¾æ–½ã€å¼€å‘å·¥å…·ã€è½¯ä»¶å·¥ç¨‹å®è·µç­‰æ–¹é¢çš„ç°çŠ¶ï¼Œå¾ˆå¤šç±»å‹çš„å»ä¸­å¿ƒåŒ–åº”ç”¨å½“å‰å‡ ä¹æ˜¯æ— æ³•å®ç°çš„ã€‚

åœ¨åŸºç¡€è®¾æ–½æ–¹é¢ï¼Œæˆ‘è®¤ä¸º AO çš„å‡ºç°å¡«è¡¥äº†å…¶ä¸­ä¸€éƒ¨åˆ†é‡å¤§çš„ç©ºç™½ã€‚ä½†æ˜¯ï¼Œç›®å‰æ„å»ºå¤§å‹å»ä¸­å¿ƒåŒ–åº”ç”¨çš„å·¥ç¨‹å¤æ‚æ€§ï¼Œä»ç„¶æ˜¯ä»¤äººæœ›è€Œç”Ÿç•çš„ã€‚
è¿™ä½¿å¾—æˆ‘ä»¬æ— æ³•åœ¨èµ„æºå—é™çš„æƒ…å†µä¸‹â€”â€”åœ¨äº‹ç‰©å‘å±•çš„åˆå§‹é˜¶æ®µï¼Œé€šå¸¸å¦‚æ­¤â€”â€”å¼€å‘å‡ºæ›´å¤šæ ·åŒ–çš„ã€æ›´å¤§è§„æ¨¡ã€å¾€å¾€ä¹Ÿæ„å‘³ç€æ›´æ£’ã€åŠŸèƒ½æ›´ä¸°å¯Œçš„å»ä¸­å¿ƒåŒ–åº”ç”¨ã€‚

ä¸è¦ç›¸ä¿¡é‚£äº›ç±»ä¼¼â€œæ™ºèƒ½åˆçº¦ / é“¾ä¸Šç¨‹åºåº”è¯¥å°±æ˜¯å¾ˆç®€å•çš„ï¼Œæ²¡æœ‰å¿…è¦æå¾—å¤ªå¤æ‚â€ä¹‹ç±»å€’æœä¸ºå› çš„é¬¼è¯ï¼

ç°å®é—®é¢˜å¹¶ä¸æ˜¯â€œä¸æƒ³â€ï¼Œè€Œæ˜¯â€œä¸èƒ½â€â€”â€”è‡£å¦¾åšä¸åˆ°å•Šã€‚


What's holding back the mass adoption of Web3?

Simply put, there are too few decentralized applications (dapps) that are worth using.

Given the current state of Web3 infrastructure, development tools, and software engineering practices, many types of dapps are nearly impossible to implement at present.

In terms of infrastructure, I believe the emergence of AO has filled a significant void. However, the engineering complexity of building large-scale decentralized applications remains daunting.

This complexity prevents us from developing a more diverse array of larger-scale dapps, which often means they would be more impressive and feature-rich, especially with limited resourcesâ€”as is often the case in the initial stages of things.

Don't fall for the fallacy that "smart contracts/blockchain programs should be simple; there's no need to overcomplicate things!"

Such statements often misrepresent the engineering reality.
The reality is not "I don't want to" but "I canâ€™t".

---

[AO](https://ao.arweave.dev/) æ˜¯è¿è¡Œåœ¨ [Arweave](https://www.arweave.org/) ä¸Šçš„è®¡ç®—æœºç³»ç»Ÿï¼Œæ—¨åœ¨å®ç°å¯éªŒè¯çš„æ— é™è®¡ç®—èƒ½åŠ›ã€‚

AOï¼Œæ˜¯ Actor Orientedï¼ˆé¢å‘å‚ä¸è€…ï¼‰çš„ç®€ç§°ã€‚é¡¾åæ€ä¹‰ï¼Œè¿™è¯´æ˜è¿è¡Œåœ¨ AO ä¸Šçš„å»ä¸­å¿ƒåŒ–åº”ç”¨éœ€è¦é‡‡ç”¨ [Actor æ¨¡å‹](https://en.wikipedia.org/wiki/Actor_mode)ä¸ºåŸºç¡€çš„è®¾è®¡å’Œç¼–ç¨‹æ–¹æ³•ã€‚ 

AO is a computing system running on Arweave, aimed at achieving verifiable infinite computational power.

AO stands for Actor Oriented. As the name suggests, this implies that decentralized applications running on AO need to adopt design and programming methods based on the [actor model](https://en.wikipedia.org/wiki/Actor_model).

----

äº‹å®ä¸Šï¼ŒAO å¹¶ä¸æ˜¯æœ€æ—©å°† Actor æ¨¡å‹ç”¨äºåŒºå—é“¾ï¼ˆæˆ–è€…è¯´â€œå»ä¸­å¿ƒåŒ–åŸºç¡€è®¾æ–½â€ï¼‰çš„ã€‚

æ¯”å¦‚ï¼Œ[TON](https://docs.ton.org/learn/overviews/ton-blockchain) çš„æ™ºèƒ½åˆçº¦å°±æ˜¯ä½¿ç”¨ Actor æ¨¡å‹æ„å»ºçš„ã€‚

è¯´åˆ° TONï¼Œæˆ‘ä¸ªäººè§‰å¾—å®ƒå’Œ AO åœ¨æŸäº›æ–¹é¢é¢‡æœ‰ç›¸ä¼¼ä¹‹å¤„ã€‚

å¯¹äºå°šæœªæ·±å…¥äº†è§£ Web3 çš„ Web2 å¼€å‘è€…æ¥è¯´ï¼Œæƒ³è¦è¿…é€Ÿç†è§£ AO æˆ– TON ç›¸å¯¹å…¶ä»–â€œå•ä½“åŒºå—é“¾â€çš„æœ€å¤§ç‰¹è‰²ï¼Œä¸€ä¸ªæ–¹ä¾¿çš„æŠ“æ‰‹æ˜¯ï¼šæŠŠè¿è¡Œåœ¨å®ƒä»¬ä¹‹ä¸Šçš„æ™ºèƒ½åˆçº¦ï¼ˆé“¾ä¸Šç¨‹åºï¼‰æƒ³æˆæ˜¯â€œ[å¾®æœåŠ¡](https://en.wikipedia.org/wiki/Microservices)â€ã€‚è€Œ AO æˆ– TON æ˜¯æ”¯æŒè¿™äº›å¾®æœåŠ¡è¿è¡Œçš„åŸºç¡€è®¾æ–½ï¼Œæ¯”å¦‚ Kafkaã€Kubernetes ç­‰ã€‚


In fact, AO is not the first to apply actor model to blockchain (or "decentralized infrastructure").

For example, smart contracts on [TON](https://docs.ton.org/learn/overviews/ton-blockchain) are built using the Actor model.

Speaking of TON, I personally find it quite similar to AO in some ways.

For Web2 developers who have not yet delved deeply into Web3, a convenient way to quickly grasp the most distinctive features of AO or TON, compared to other monolithic blockchains, is to think of the smart contracts (on-chain programs) running on them as [microservices](https://en.wikipedia.org/wiki/Microservices). AO or TON is the infrastructures that support these microservices, such as Kafka, Kubernetes, and so on.

---

æˆ‘ä¸ªäººéå¸¸æœŸå¾…éå•ä½“åŒºå—é“¾çš„å‘å±•ã€‚ä¸‹é¢æˆ‘æƒ³ä»ä¸€ä¸ªåº”ç”¨å¼€å‘è€…çš„è§†è§’ï¼Œè°ˆè°ˆæˆ‘å¯¹ AO çš„çœ‹æ³•ï¼Œå¯èƒ½å¾ˆå¤šè§‚ç‚¹è¿˜ä¸å¤ªæˆç†Ÿã€‚
ä½†ä½œä¸ºä¸€ä¸ª 20 å¤šå¹´æ¥ä¸»è¦ä¸“æ³¨äºåº”ç”¨å¼€å‘çš„ä¸€åèµ„æ·± [CRUD](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) boyï¼Œä¹Ÿè®¸éƒ¨åˆ†åº”ç”¨å¼€å‘è€…ä¼šå¿ƒæœ‰æˆšæˆšç„‰ï¼Œé‚£å°±è¶³çŸ£ã€‚


Personally, I'm looking forward to the development of non-monolithic blockchains. Below I would like to talk about my views on AO from the perspective of an application developer, and many of my views may be immature.
But as a senior [CRUD](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) boy who has been mainly focusing on application development for more than 20 years, maybe some application developers will share my feelings, and then I will be very satisfied.

---

é‚£ä¹ˆï¼Œå°† Actor æ¨¡å‹åº”ç”¨äºåŒºå—é“¾ï¼ŒçœŸçš„æœ‰å¿…è¦å—ï¼Ÿç­”æ¡ˆæ˜¯è‚¯å®šçš„ã€‚çœ‹çœ‹å·²ç»å–å¾—â€œå¤§è§„æ¨¡é‡‡ç”¨â€çš„ Web2 åº”ç”¨ï¼Œä½ å°±ä¼šæ˜ç™½ã€‚


Is the integration of the Actor model into blockchain technology truly essential? The answer is unequivocally affirmative. One only needs to observe the Web2 applications that have reached "mass adoption" to understand why.

---

å¤ªå¤šçš„æ¶æ„å¸ˆå·²ç»çŸ¥é“å¦‚ä½•å°† Web2 åº”ç”¨â€œæå¤§â€ï¼šå¾®æœåŠ¡æ¶æ„ï¼ˆMSAï¼‰ã€äº‹ä»¶é©±åŠ¨çš„æ¶æ„ï¼ˆEDAï¼‰ã€æ¶ˆæ¯é€šä¿¡æœºåˆ¶ã€æœ€ç»ˆä¸€è‡´æ€§æ¨¡å‹ã€åˆ†ç‰‡â€¦â€¦è¿™äº›ä¸œè¥¿ï¼Œä¸ç®¡å«ä»€ä¹ˆï¼Œæ€»æ˜¯ä¸ Actor æ¨¡å‹å…±ç”Ÿå…±å­˜çš„ã€‚å…¶ä¸­çš„ä¸€äº›æ¦‚å¿µï¼Œç”šè‡³å¯ä»¥è¯´åªæ˜¯ä¸€ä¸ªäº‹ç‰©çš„ä¸åŒæ–¹é¢ã€‚åœ¨ä¸‹é¢çš„è¡Œæ–‡ä¸­ï¼Œæˆ‘ä»¬ä¸å¯¹â€œå¾®æœåŠ¡â€å’Œ Actor åšåŒºåˆ†ï¼Œä½ å¯ä»¥è®¤ä¸ºå®ƒä»¬æ˜¯åŒä¹‰è¯ã€‚

Numerous architects are already versed in making Web2 applications bigger and bigger through strategies such as Microservice Architecture (MSA), Event-Driven Architecture (EDA), messaging mechanisms, and the Eventual Consistency model, Sharding... These things, whatever they may be called, are always symbiotic with the Actor model.  Some of these concepts can even be described as just different aspects of one thing. In the ensuing discussion, we do not differentiate between "Microservice" and "Actor"; they may be regarded as synonymous.

---

ä»Šæ—¥äº’è”ç½‘çš„ç¹è£ï¼Œç¦»ä¸å¼€è¿™äº›æ¶æ„å¸ˆçš„æ™ºæ…§ã€‚ä»–ä»¬ä¸æ–­åœ°æ¢ç´¢ã€å®è·µã€æ€»ç»“ï¼Œæœ€ç»ˆå½¢æˆäº†ä¸€å¥—å®Œæ•´çš„å·¥ç¨‹å®è·µä½“ç³»ã€‚

The flourishing state of today's Internet owes much to the ingenuity of its architects. They have persistently explored, experimented, and reflected, culminating in the establishment of a comprehensive framework of engineering practices.

---

ä½œä¸º Web3 åŸºç¡€è®¾æ–½ï¼ŒAO åšçš„å¾ˆæ£’ã€‚
æœ€å°‘ï¼ŒAO ä½œä¸ºï¼ˆæˆ‘çœ¼ä¸­çš„ï¼‰å½“å‰ Web3 é¢†åŸŸçš„æœ€ä½³å»ä¸­å¿ƒåŒ–æ¶ˆæ¯ä»£ç†ï¼Œå·²ç»å±•ç°å‡ºå·¨å¤§çš„æ½œåŠ›ã€‚

æˆ‘ç›¸ä¿¡ä¼ ç»Ÿ Web2 åº”ç”¨çš„å¼€å‘è€…ç”±æ­¤å¯ä»¥é©¬ä¸Šç†è§£å…¶ä¸­çš„é‡å¤§æ„ä¹‰ï¼š

å€˜è‹¥æ²¡æœ‰ [Kafka](https://kafka.apache.org) æˆ–è€…ç±» Kafka çš„æ¶ˆæ¯ä»£ç†å¯ç”¨ï¼Œä½ èƒ½æƒ³è±¡ç°åœ¨å¾ˆå¤šå¤§å‹çš„äº’è”ç½‘åº”ç”¨â€œç¨‹åºè¦æ€ä¹ˆå†™â€å—ï¼Ÿ


As a piece of Web3 infrastructure, AO has been outstanding.
At the very least, AO has shown great potential as what I consider to be the best decentralized messaging agent in the Web3 space today.

I believe that developers from the traditional Web2 space can immediately grasp the profound implications of this:

Can you imagine how the programming of many of today's large-scale internet applications would be without the availability of [Kafka](https://kafka.apache.org) or Kafka-like message brokers?


----

è™½ç„¶ Actor æ¨¡å‹åœ¨å¾ˆå¤šæ–¹é¢å…·æœ‰ç†è®ºä¸Šçš„ä¼˜åŠ¿ï¼Œä½†æ˜¯ä¸ç®¡æ˜¯ Actor æ¨¡å‹ä¹Ÿå¥½ï¼Œå¾®æœåŠ¡æ¶æ„ä¹Ÿå¥½ï¼Œåœ¨æˆ‘çœ‹æ¥ï¼Œæ›´å¤šæ˜¯å¼€å‘è€…ä¸ºäº†å¼€å‘æŸäº›åº”ç”¨ï¼ˆç‰¹åˆ«æ˜¯å¤§å‹åº”ç”¨ï¼‰æ‰€ä¸å¾—ä¸æ‰¿å—ä¹‹â€œæ¶â€ã€‚

Although the Actor model has theoretical advantages in many respects, whether it's the Actor model or Microservice Architecture (MSA), in my view, they often represent a necessary "evil" that developers must contend with when building certain applications, particularly large-scale ones.

--------

è®©æˆ‘ä»¬ç”¨ä¸€ä¸ªç®€å•çš„ä¾‹å­æ¥å‘éæŠ€æœ¯è¯»è€…è¯´æ˜è¿™ä¸€ç‚¹ã€‚å‡è®¾ä¸–ç•Œä¸Šæ‰€æœ‰é“¶è¡Œéƒ½åŸºäºä¸€ä¸ªâ€œä¸–ç•Œè®¡ç®—æœºâ€æ¥å¼€å±•ä¸šåŠ¡ï¼Œè€Œè¿™ä¸ªä¸–ç•Œè®¡ç®—æœºæ˜¯ä¸€ä¸ªå•ä½“æ¶æ„çš„ç³»ç»Ÿã€‚é‚£ä¹ˆï¼Œå½“å·¥å•†é“¶è¡Œçš„å®¢æˆ·â€œå¼ ä¸‰â€å‘åœ¨æ‹›å•†é“¶è¡Œå¼€è®¾è´¦æˆ·çš„â€œæå››â€æ±‡æ¬¾ 100 å…ƒçš„æ—¶å€™ï¼Œå¼€å‘è€…å¯ä»¥è¿™æ ·ç¼–å†™è½¬è´¦ç¨‹åºçš„ä»£ç ï¼š

1. å¼€å§‹ä¸€ä¸ªäº‹åŠ¡ï¼ˆæˆ–è€…è¯´â€œäº¤æ˜“â€ï¼Œå®ƒä»¬åœ¨è‹±æ–‡ä¸­åŒä¸€ä¸ªè¯ï¼‰ï¼›
2. åœ¨å¼ ä¸‰çš„è´¦æˆ·ä¸Šæ‰£å‡ 100 å…ƒï¼›
3. åœ¨æå››çš„è´¦æˆ·ä¸Šå¢åŠ  100 å…ƒï¼›
4. æäº¤äº‹åŠ¡ã€‚

ä»¥ä¸Šæ­¥éª¤ä¸ç®¡å“ªä¸€æ­¥å‡ºç°é—®é¢˜ï¼Œæ¯”å¦‚è¯´ç¬¬ä¸‰æ­¥ï¼Œåœ¨æå››çš„è´¦æˆ·ä¸Šå¢åŠ é‡‘é¢ï¼Œå› ä¸ºæŸç§åŸå› å¤±è´¥äº†ï¼Œé‚£ä¹ˆæ•´ä¸ªæ“ä½œéƒ½ä¼šè¢«å›æ»šï¼Œå°±åƒä»€ä¹ˆéƒ½æ²¡æœ‰å‘ç”Ÿè¿‡ä¸€æ ·ã€‚
å¯¹äº†ï¼Œç¨‹åºè¿™æ ·å†™ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºé‡‡ç”¨â€œå¼ºä¸€è‡´æ€§â€æ¨¡å‹ã€‚

Let's use a simple example to illustrate this point to the non-technical reader. Imagine all the banks in the world operated on a "World Computer," a monolithic system. In this scenario, when a customer from ICBC named "John Doe" transfers $100 to "Jane Doe," who has an account at China Merchants Bank, a developer might code the transfer process like this:

1. Start a transaction;
2. Deduct $100 from John Doe's account;
3. Credit $100 to Jane Doe's account;
4. Commit the transaction.

If any step encounters an issue, such as step 3 where crediting Jane Doe's account fails for some reason, the entire operation would be rolled back, as if nothing had happened.
By the way, when the program is written this way, we say that it adopts the Strong Consistency model.

--------

å€˜è‹¥è¿™ä¸ªä¸–ç•Œè®¡ç®—æœºæ˜¯ä¸ªé‡‡ç”¨ MSA çš„ç³»ç»Ÿå‘¢ï¼Ÿé‚£ä¹ˆï¼Œç®¡ç†å·¥å•†é“¶è¡Œè´¦æˆ·çš„é‚£ä¸ªå¾®æœåŠ¡ï¼ˆæˆ–è€…è¯´ Actorï¼‰ä¸ç®¡ç†æ‹›å•†é“¶è¡Œè´¦æˆ·çš„é‚£ä¸ªå¾®æœåŠ¡ï¼Œå‡ ä¹ä¸å¤ªå¯èƒ½æ˜¯åŒä¸€ä¸ªã€‚æˆ‘ä»¬å…ˆå‡è®¾å®ƒä»¬ç¡®å®ä¸æ˜¯åŒä¸€ä¸ªï¼Œå‰è€…æˆ‘ä»¬ç§°ä¸º Actor ICBCï¼Œåè€…æˆ‘ä»¬ç§°ä¸º Actor CMBã€‚æ­¤æ—¶ï¼Œå¼€å‘è€…å¯èƒ½éœ€è¦è¿™æ ·ç¼–å†™è½¬è´¦çš„ä»£ç ï¼š

1. Actor ICBC å…ˆè®°å½•å¥½ä»¥ä¸‹ä¿¡æ¯ï¼šâ€œå¼ ä¸‰å‘æå››è½¬è´¦100 å…ƒâ€ï¼›Actor ICBC åœ¨å¼ ä¸‰çš„è´¦æˆ·ä¸Šæ‰£å‡ 100 å…ƒï¼Œå¹¶å‘ Actor CMB å‘é€ä¸€æ¡æ¶ˆæ¯ï¼šâ€œå¼ ä¸‰å‘æå››è½¬è´¦100 å…ƒâ€ï¼›
2. Actor CMB æ”¶åˆ°æ¶ˆæ¯ï¼Œåœ¨æå››çš„è´¦æˆ·ä¸Šå¢åŠ  100 å…ƒï¼Œç„¶åå‘ Actor ICBC å‘é€ä¸€æ¡æ¶ˆæ¯â€œæå››å·²æ”¶åˆ°å¼ ä¸‰æ±‡å…¥çš„ 100 å…ƒâ€ï¼›
3. Actor ICBC æ”¶åˆ°æ¶ˆæ¯ï¼Œè®°å½•å¥½ï¼šâ€œå¼ ä¸‰å‘æå››è½¬è´¦ 100 å…ƒï¼Œå·²æˆåŠŸâ€ã€‚

ä¸Šé¢åªæ˜¯â€œä¸€åˆ‡éƒ½å¥½â€çš„è¿‡ç¨‹ã€‚ä½†æ˜¯ï¼Œå¦‚æœæŸä¸ªæ­¥éª¤ï¼Œæ¯”å¦‚è¯´ç¬¬äºŒä¸ªæ­¥éª¤ï¼Œâ€œåœ¨æå››çš„è´¦æˆ·ä¸Šå¢åŠ  100 å…ƒâ€ï¼Œå‡ºç°äº†é—®é¢˜ï¼Œæ€ä¹ˆåŠï¼Ÿ

What if this World Computer were a system using a Microservice Architecture (MSA)? In that case, the microservice managing the ICBC accounts and the one managing the CMB accounts would almost certainly not be the same. Let's assume they are indeed different; the former is called Actor ICBC, and the latter is called Actor CMB. Under these circumstances, a developer might write the code for the transfer process as follows:

1. Actor ICBC records the following information: "John Doe transfers $100 to Jane Doe."; Actor ICBC deducts 100 yuan from John Doe's account and sends a message to Actor CMB: "John Doe transfers $100 to Jane Doe."
2. Upon receiving the message, Actor CMB adds $100 to Jane Doe's account and then sends a message back to Actor ICBC: "Jane Doe has received the $100 transferred by John Doe."
3. Actor ICBC, upon receiving the confirmation, records: "The transfer of $100 from John Doe to Jane Doe was successful."

The above describes the process when everything goes well. But what if there's a problem at some step, such as the step 2, "adds $100 to Jane Doe's account"?

---

å¼€å‘è€…éœ€è¦é’ˆå¯¹è¿™ä¸ªå¯èƒ½å‘ç”Ÿçš„é—®é¢˜ï¼Œç¼–å†™è¿™æ ·çš„å¤„ç†é€»è¾‘ï¼š

* Actor CMB å‘ Actor ICBC å‘é€ä¸€æ¡æ¶ˆæ¯ï¼šâ€œå¼ ä¸‰å‘æå››è½¬è´¦ 100 å…ƒï¼Œå¤„ç†å¤±è´¥â€ã€‚  
* Actor ICBC æ”¶åˆ°æ¶ˆæ¯ï¼Œåœ¨å¼ ä¸‰çš„è´¦æˆ·ä¸Šå¢åŠ  100 å…ƒï¼Œå¹¶è®°å½•ï¼šâ€œå¼ ä¸‰å‘æå››è½¬è´¦ 100 å…ƒï¼Œå·²å¤±è´¥â€ã€‚

For this possible problem, developers need to write such processing logic:

*  Actor CMB sends a message to Actor ICBC: "John Doe's transfer of $100 to Jane Doe has failed."
* Upon receiving the message, Actor ICBC adds $100 back to John Doe's account and records: "John Doe's transfer of 100 yuan to Jane Doe has failed."

---


ç¨‹åºè¿™æ ·å†™ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºé‡‡ç”¨æœ€ç»ˆä¸€è‡´æ€§æ¨¡å‹ã€‚

When the program is written in this way, we refer to it as adopting the Eventual Consistency model.

ä»¥ä¸Šï¼ŒéæŠ€æœ¯è¯»è€…åº”è¯¥èƒ½ç›´è§‚æ„Ÿå—åˆ°å¼€å‘å•ä½“æ¶æ„çš„åº”ç”¨ä¸å¼€å‘ MSA åº”ç”¨ä¹‹é—´çš„å·¨å¤§å·®å¼‚äº†å§ï¼Ÿ
è¦çŸ¥é“ï¼Œä¸Šé¢æ‰€è¯´çš„è½¬è´¦ç¤ºä¾‹åªæ˜¯ä¸€ä¸ªéå¸¸ç®€å•çš„åº”ç”¨è€Œå·²ï¼Œå¦‚æœæˆ‘ä»¬æŠŠå®ƒç§°ä¹‹ä¸ºåº”ç”¨ï¼Œè€Œä¸æ˜¯åŠŸèƒ½çš„è¯ã€‚å¤§å‹åº”ç”¨é‡Œé¢çš„åŠŸèƒ½å¾€å¾€æ¯”è¿™æ ·çš„ä¾‹å­è¦å¤æ‚çš„å¤ªå¤šã€‚

With the above comparison, non-technical readers should be able to visualize the huge difference between developing monolithic architecture applications and developing MSA applications, right?
It should be noted that the aforementioned transfer example is merely a very simple application, if we choose to call it an application rather than a feature.
The features within large applications are often much more complex than this example.

---

é‡‡ç”¨ MSA æ¶æ„ä¸€ä¸ªå¸¸è§çš„é—®é¢˜æ˜¯â€œè¿™ä¸ªå¾®æœåŠ¡åº”è¯¥å¤šå¤§ï¼Ÿâ€â€”â€”æˆ–è€…æ¢å¥è¯è¯´ï¼Œ"è¿™ä¸ªå¾®æœåŠ¡æ˜¯ä¸æ˜¯å¤ªå¤§äº†ï¼Œåº”è¯¥ä¸€åˆ†ä¸ºäºŒï¼Ÿâ€

å¾ˆä¸å¹¸ï¼Œè¿™ä¸ªé—®é¢˜æ²¡æœ‰æ ‡å‡†ç­”æ¡ˆï¼Œå®ƒæ˜¯ä¸€é—¨è‰ºæœ¯ğŸ˜‚ã€‚å¾®æœåŠ¡è¶Šå°ï¼Œå°±è¶Šå®¹æ˜“é€šè¿‡åˆ›å»ºæ–°å®ä¾‹å¹¶æŒ‰éœ€ç§»åŠ¨å®ƒä»¬æ¥ä¼˜åŒ–ç³»ç»Ÿã€‚ä½†æ˜¯ï¼Œå¾®æœåŠ¡è¶Šå°ï¼Œå¼€å‘äººå‘˜å°±è¶Šéš¾å®æ–½å¤æ‚çš„æµç¨‹ï¼Œæ­£å¦‚ä¸Šé¢å±•ç¤ºçš„é‚£æ ·ã€‚


When adopting a Microservice Architecture (MSA), a common question arises: "How large should a microservice be?" or put another way, "Is this microservice too large and in need of division?"

Unfortunately, there's no definitive answer to this dilemma, it's more of an artğŸ˜‚. The smaller the microservice, the more manageable it becomes to optimize the system by spawning new instances and relocating them as needed. However, the trade-off is that developers may find it more challenging to implement complex processes within tinier services, as illustrated earlier.


---


å¯¹äº†ï¼Œå°†ä¸€ä¸ªåº”ç”¨æ‹†åˆ†ä¸ºå¤šä¸ªå¾®æœåŠ¡ï¼Œä»æ•°æ®åº“è®¾è®¡è§’åº¦çœ‹ï¼Œå³æ‰€è°“çš„â€œåˆ†ç‰‡ï¼ˆShardingï¼‰â€ã€‚å¾®æœåŠ¡æ¶æ„çš„æœ€ä½³å®è·µä¹‹ä¸€ï¼Œå°±æ˜¯æ¯ä¸ªå¾®æœåŠ¡ä»…ä½¿ç”¨ä¸€ä¸ªå±äºè‡ªå·±çš„æœ¬åœ°æ•°æ®åº“ã€‚ç®€å•æ¥è¯´ï¼Œåˆ†ç‰‡å…è®¸æ°´å¹³æ‰©å±•ã€‚å½“æ•°æ®é›†å˜å¾—å¤ªå¤§ï¼Œæ— æ³•é€šè¿‡ä¼ ç»Ÿæ–¹å¼å¤„ç†æ—¶ï¼Œé™¤äº†å°†å®ƒä»¬æ‹†åˆ†æˆæ›´å°çš„ç‰‡æ®µä»¥å¤–ï¼Œåˆ«æ— ä»–æ³•ï¼ˆæ¥è¿›è¡Œæ‰©å±•ï¼‰ã€‚

Incidentally, decomposing an application into multiple microservices is akin to what is termed "sharding" in the realm of database design. It is considered one of the best practices for MSA that each microservice operates exclusively with its own local database. In essence, sharding facilitates horizontal scaling. When datasets grow too voluminous to manage via conventional methods, the only recourse is to segment them into smaller, more manageable fragments.

---


å›åˆ°å¾®æœåŠ¡çš„æ‹†åˆ†é—®é¢˜ã€‚ä¸ºäº†æ›´å¥½åœ°è·µè¡Œè¿™é—¨è‰ºæœ¯ï¼Œæˆ‘ä»¬éœ€è¦æŒæ¡ä¸€äº›æ€ç»´å·¥å…·çš„ä½¿ç”¨ã€‚
DDDï¼ˆ[é¢†åŸŸé©±åŠ¨è®¾è®¡](https://en.wikipedia.org/wiki/Domain-driven_design)ï¼‰çš„ â€œèšåˆï¼ˆAggregateï¼‰â€å°±æ˜¯è¿™æ ·ä¸€ä»¶ä½ å¿…é¡»æ‹¥æœ‰çš„â€œå¤§æ€å™¨â€ã€‚
æˆ‘çš„æ„æ€æ˜¯ï¼Œå®ƒèƒ½å¸®åŠ©ä½ æ‘§æ¯è½¯ä»¶è®¾è®¡ä¸­çš„â€œæ ¸å¿ƒå¤æ‚æ€§â€ã€‚


Returning to the subject of microservice decomposition, to truly master this art, it's crucial to wield certain mental tools adeptly.
The "Aggregate" concept in DDD ([Domain-Driven Design](https://en.wikipedia.org/wiki/Domain-driven_design)) is akin to a WMD (Weapon of Mass Destruction)â€”an indispensable weapon in your arsenal.
I mean, it helps you destroy "core complexity" in software design.

---

æˆ‘è®¤ä¸ºèšåˆæ˜¯ DDD åœ¨æˆ˜æœ¯å±‚é¢æœ€ä¸ºé‡è¦çš„ä¸€ä¸ªæ¦‚å¿µã€‚

ä»€ä¹ˆæ˜¯èšåˆï¼Ÿèšåˆåœ¨å¯¹è±¡ä¹‹é—´ï¼Œç‰¹åˆ«æ˜¯å®ä½“ä¸å®ä½“ä¹‹é—´åˆ’å‡ºè¾¹ç•Œã€‚ä¸€ä¸ªèšåˆä¸€å®šåŒ…å«ä¸”ä»…åŒ…å«ä¸€ä¸ª*èšåˆæ ¹*å®ä½“ï¼Œä»¥åŠå¯èƒ½åŒ…å«ä¸å®šæ•°é‡çš„*èšåˆå†…éƒ¨å®ä½“*ï¼ˆæˆ–è€…å«*éèšåˆæ ¹å®ä½“*ï¼‰ã€‚

I regard the Aggregate as one of the most significant concepts at the tactical level in DDD.

What is an Aggregate? Aggregates establish boundaries among objects, especially between entities. An Aggregate is characterized by a single "Aggregate Root" entity, along with a potentially variable number of "Intra-Aggregate Entities" (or "Non-Aggregate Root Entities").


---

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨èšåˆè¿™ä¸€æ¦‚å¿µå¯¹åº”ç”¨æ‰€æœåŠ¡çš„é¢†åŸŸè¿›è¡Œåˆ†æå’Œå»ºæ¨¡ï¼›ç„¶ååœ¨ç¼–ç çš„æ—¶å€™ï¼Œå°±å¯ä»¥æŒ‰ç…§èšåˆæ¥åˆ‡åˆ†å¾®æœåŠ¡ã€‚
æœ€ç®€å•çš„åšæ³•ï¼Œå°±æ˜¯å°†æ¯ä¸ªèšåˆå®ç°ä¸ºä¸€ä¸ªå¾®æœåŠ¡ã€‚

The concept of Aggregate can be employed to analyze and model the domain that the application serves.
During the coding phase, microservices can be delineated based on these aggregates. 
The most straightforward method is to develop each aggregate as an individual microservice.

---

ä¸è¿‡ï¼Œå³ä½¿ä½ çš„æ‰‹è‰ºå†å¨´ç†Ÿï¼Œè¿™ç§äº‹æƒ…ä½ ä¹Ÿä¸èƒ½ä¿è¯ç¬¬ä¸€æ¬¡å°±åšå¯¹ã€‚
è¿™ä¸ªæ—¶å€™ï¼Œä¸€ä»¶è®©ä½ å¯ä»¥å°½å¿«å¯¹å»ºæ¨¡ç»“æœè¿›è¡ŒéªŒè¯ã€ä¸è¡Œå°±æ¨å€’é‡æ¥çš„å·¥å…·ï¼Œå¯¹ä½ æ¥è¯´å°±å¼¥è¶³çè´µäº†ã€‚

However, even if you are adept in your craft, there's no guarantee of getting it right on the first try.
At such times, a tool that enables you to swiftly validate your modeling resultsâ€”and if necessary, start overâ€”is incredibly precious.


---

è¿˜æœ‰ä»€ä¹ˆä¸œè¥¿å¯èƒ½æ„æˆå¤§å‹ Web2 åº”ç”¨è¿ç§»åˆ° AO ç”Ÿæ€çš„éšœç¢ï¼Ÿæˆ‘æƒ³è°ˆè°ˆè¯­è¨€å’Œç¨‹åºè¿è¡Œæ—¶çš„é—®é¢˜ã€‚

AO æ˜¯ä¸€ä¸ªæ•°æ®åè®®ã€‚ä½ å¯ä»¥è®¤ä¸ºå®ƒæ˜¯ä¸€å¥—å®šä¹‰ AO ç½‘ç»œä¸­çš„å„ä¸ªâ€œ[å•å…ƒ](https://cookbook_ao.g8way.io/concepts/units.html)â€å¦‚ä½•å®ç°åä½œçš„æ¥å£è§„èŒƒã€‚

ç›®å‰ï¼ŒAO çš„å®˜æ–¹å®ç°åŒ…å«äº†ä¸€ä¸ªåŸºäº WASM çš„è™šæ‹Ÿæœºç¯å¢ƒï¼Œä»¥åŠä¸€ä¸ªç¼–è¯‘ä¸ºWASM çš„ Lua è¿è¡Œæ—¶ç¯å¢ƒï¼ˆao-libï¼‰ï¼Œæ—¨åœ¨ç®€åŒ– AO è¿›ç¨‹çš„å¼€å‘ã€‚

Lua æ˜¯ä¸€ç§å°è€Œç¾çš„è¯­è¨€ã€‚

ä¸€èˆ¬è®¤ä¸ºï¼ŒLua çš„ä¼˜åŠ¿åœ¨äºå®ƒçš„è½»é‡çº§å’Œæ˜“äºåµŒå…¥å…¶ä»–è¯­è¨€ï¼Œè¿™ä½¿å¾—å®ƒåœ¨ç‰¹å®šåœºæ™¯ï¼ˆæ¯”å¦‚æ¸¸æˆå¼€å‘ï¼‰ä¸­ç‰¹åˆ«æœ‰ç”¨ã€‚

ä½†æ˜¯ï¼Œå¯¹äºå¼€å‘å¤§å‹äº’è”ç½‘åº”ç”¨æ¥è¯´ï¼ŒLua è¯­è¨€å¹¶ä¸æ˜¯ä¸»æµçš„é€‰æ‹©ã€‚å¤§å‹çš„äº’è”ç½‘åº”ç”¨å¼€å‘é€šå¸¸å€¾å‘äºä½¿ç”¨å¦‚ Javaã€C#ã€PHPã€Pythonã€JavaScriptã€Ruby ç­‰è¯­è¨€ï¼Œå› ä¸ºè¿™äº›è¯­è¨€æä¾›äº†æ›´å…¨é¢çš„ç”Ÿæ€ç³»ç»Ÿå’Œå·¥å…·é“¾ï¼Œä»¥åŠæ›´å¹¿æ³›çš„ç¤¾åŒºæ”¯æŒã€‚

æœ‰äººå¯èƒ½è¦äº‰è®ºï¼Œè¿™äº›è¯­è¨€éƒ½å¯ä»¥ç¼–è¯‘æˆ WASM å­—èŠ‚ç ï¼Œåœ¨ WASM è™šæ‹Ÿæœºé‡Œè¿è¡Œã€‚ä½†æ˜¯äº‹å®ä¸Šï¼Œç›®å‰äº’è”ç½‘åº”ç”¨é‡‡ç”¨ WASM ä½œä¸ºåç«¯çš„è¿è¡Œç¯å¢ƒå¹¶ä¸æ˜¯ä¸€ä¸ªä¸»æµé€‰æ‹©ï¼Œè™½ç„¶ WASM åœ¨ Web å‰ç«¯å¼€å‘é¢†åŸŸçš„è¡¨ç°å¾ˆå¼ºåŠ¿ã€‚æ³¨æ„ï¼Œæ™ºèƒ½åˆçº¦ï¼ˆé“¾ä¸Šç¨‹åºï¼‰æ˜¯ Web3 æ—¶ä»£çš„â€œæ–°åç«¯â€ã€‚


What other factors might pose obstacles to the migration of large Web2 applications to the AO ecosystem? I would like to discuss issues related to programming languages and runtime environments.

AO is a data protocol. Think of it as a set of interface standards that delineate how various [Units](https://cookbook_ao.g8way.io/concepts/units.html) within the AO network collaborate.

The official implementation of AO currently includes a WASM-based virtual machine environment, as well as a Lua runtime environment (ao-lib) that compiles to WASM, designed to allow for the easy development of processes in AO.

Lua is a compact and elegant language.

It is widely recognized that Lua's strengths are its lightweight design and its ease of embedding within other languages, making it particularly valuable in certain contexts, such as game development.

However, Lua is not the preferred language for developing large-scale internet applications. Development of substantial internet applications typically leans towards languages like Java, C#, PHP, Python, JavaScript, Ruby, etc., because these languages provide more extensive ecosystems and toolchains, along with broader community support.

Some might contend that all these languages can be compiled into WASM bytecode and executed within a WASM virtual machine. Yet, in reality, employing WASM as a backend runtime environment for internet applications is not a prevalent choice at present, despite WASM's strong performance in web frontend development. It's important to note that smart contracts (on-chain programs) represent the "new backend" in the Web3 era.





---

æˆ‘ä»¬éƒ½çŸ¥é“ï¼Œå…¬é“¾ä¹‹äº‰ï¼Œå…¶å®æ˜¯äº‰å¤ºåº”ç”¨å¼€å‘è€…çš„æˆ˜äº‰ã€‚

æˆ‘ä»¬ä¹‹å‰å·²ç»è®¨è®ºäº†é‡‡ç”¨å¾®æœåŠ¡æ¶æ„ï¼ˆæˆ–è€…è¯´ Actor æ¨¡å‹ï¼‰çš„ä¼˜åŠ¿ï¼Œä»¥åŠå®ƒä¸ºåº”ç”¨å¼€å‘å¸¦æ¥çš„å¤æ‚æ€§ã€‚æœ‰äº›å¤æ‚æ€§æ˜¯ä¸å¯é¿å…çš„ã€‚

æ¯”å¦‚ï¼Œå³ä½¿åœ¨å·¥ç¨‹åŒ–æ›´æˆç†Ÿçš„ Web2 ç¯å¢ƒä¸­ï¼ŒåŸºäºæ¶ˆæ¯é€šä¿¡æ¥å®ç°â€œæœ€ç»ˆä¸€è‡´æ€§â€å¯¹äºè®¸å¤šå¼€å‘è€…è€Œè¨€å·²ç»æ˜¯ä¸å°çš„æŒ‘æˆ˜ã€‚
åœ¨æ–°ç”Ÿçš„ AO å¹³å°ä¸Šå¼€å‘ Dappï¼Œè¿™ä¸ªæŒ‘æˆ˜ä¼¼ä¹è¿˜è¦æ›´åŠ æ˜æ˜¾â€”â€”å½“ç„¶è¿™æ˜¯å®Œå…¨å¯ä»¥ç†è§£çš„ã€‚
[è¿™ä¸ªé“¾æ¥](https://github.com/dddappp/A-AO-Demo?tab=readme-ov-file#an-ao-dapp-development-demo-with-a-low-code-approach)æ–‡ç« çš„å¼€ç¯‡å°±å±•ç¤ºäº†ä¸€ä¸ªä¾‹å­ã€‚

é‚£ä¹ˆï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ AO è¦å¦‚ä½•èµ¢å¾—å¼€å‘è€…ï¼Ÿ

å½“ç„¶æ˜¯ç»§ç»­å‘å·²ç»è·å¾—â€œå¤§è§„æ¨¡é‡‡ç”¨â€çš„ Web2 å­¦ä¹ ã€‚è¿™ä¸ä»…åŒ…æ‹¬å­¦ä¹ å…¶åŸºç¡€è®¾æ–½ï¼Œè¿˜åŒ…æ‹¬å¼€å‘æ–¹æ³•è®ºã€å¼€å‘å·¥å…·å’Œè½¯ä»¶å·¥ç¨‹å®è·µç­‰å„ä¸ªæ–¹é¢ã€‚


We all understand that the competition among public blockchains is essentially a battle for the hearts and minds of application developers.

We have previously discussed the benefits of adopting a microservices architecture, or the Actor model, and the inherent complexities it introduces to application development. Some complexities are simply unavoidable.

Even within the more mature engineering landscape of Web2, implementing "eventual consistency" through messaging poses a significant challenge for many developers. 
This challenge seems even more daunting when developing Dapps on the nascent AO platformâ€”understandably so.
The opening of [this linked article](https://github.com/dddappp/A-AO-Demo?tab=readme-ov-file#an-ao-dapp-development-demo-with-a-low-code-approach) provides a case in point.

So, how does AO win over developers in this context?

The answer lies in continuing to learn from Web2, which has already achieved mass adoption. This includes not only its infrastructure but also its development methodologies, tools, and software engineering practices.

---

ä½ä»£ç å¼€å‘å¹³å°ç»å¯¹æ˜¯ Web3 é¢†åŸŸå€¼å¾—å¤§åŠ›æŠ•å…¥çš„ä¸€ä¸ªæ–¹å‘ã€‚

æˆ‘é¦–å…ˆæƒ³è¦æ¾„æ¸…ä¸€ä¸‹ Low-Codeï¼ˆä½ä»£ç ï¼‰å’Œ No-Codeï¼ˆæ— ä»£ç ï¼‰çš„åŒºåˆ«â€”â€”å½“ç„¶ï¼Œè¿™åªæ˜¯æˆ‘çš„ä¸ªäººçœ‹æ³•ï¼š

* ä½ä»£ç æ˜¯é’ˆå¯¹ä¸“ä¸šå¼€å‘äººå‘˜çš„ã€‚
    ä¸šç•Œå¯¹ä½ä»£ç å¹³å°åº”å…·å¤‡çš„æ ¸å¿ƒåŠŸèƒ½å·²è¾¾æˆå…±è¯†ï¼ˆäº‹å®ä¸Šçš„æ ‡å‡†ï¼‰ã€‚
    åº•çº¿æ˜¯å®ƒä»¬å¿…é¡»é‡‡ç”¨ "æ¨¡å‹é©±åŠ¨ "çš„æ–¹æ³•ã€‚

* æ— ä»£ç æŒ‡çš„æ˜¯ä¸€å¤§ç±»é¢å‘ "æœ€ç»ˆç”¨æˆ· "çš„å·¥å…·ã€‚
    å¯¹äºä»€ä¹ˆæ˜¯ No-code ä¸šç•Œæ²¡æœ‰ç»Ÿä¸€æ ‡å‡†ã€‚
    å®ƒä»¬å…è®¸ç”¨æˆ·åˆ›å»ºç®€å•çš„åº”ç”¨ç¨‹åºï¼Œå¦‚äº§å“å¹¿å‘Šé¡µã€åœ¨çº¿é—®å·è°ƒæŸ¥ã€ä¸ªäººåšå®¢ç­‰ã€‚
    åªè¦æŸé¡¹å·¥ä½œï¼Œä»¥å‰å¤§å®¶è®¤ä¸ºéœ€è¦å¼€å‘äººå‘˜æ‰èƒ½å®Œæˆï¼Œç°åœ¨å€ŸåŠ©æŸä¸ªå·¥å…·çš„å¸®åŠ©ï¼Œå¯ä»¥ç”±æ™®é€šç”¨æˆ·å®Œæˆäº†ï¼Œè¿™ä¸ªå·¥å…·å°±ä¼šè¢«ç§°ä¹‹ä¸º No-codeã€‚


Low-code development platforms are undoubtedly an area where Web3 should invest heavily.

First, I'd like to clarify the difference between Low-code and No-codeâ€”of course, this is just my personal opinion:

* Low-code is intended for professional developers.
    There is a consensus  (de facto standard)  in the industry on what the core features of a Low-Code platform should have.
    At a minimum, they must adopt a "model-driven" approach.

* No-code refers to a large category of tools for "end-users".
    There is no unified standard for what is considered No-code.
    They allow users to create simple "applications" such as product advertisement pages, online questionnaires, personal blogs, etc.
    Whenever a task, which was previously thought to require a developer, can now be done by a regular user with the help of a tool, that tool will be called No-code.


---

é‚£ä¹ˆï¼Œæˆ‘æ‰€è°ˆè®ºçš„ä½ä»£ç å¹³å°çš„â€œäº‹å®ä¸Šçš„æ ‡å‡†â€æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿä½ å¯ä»¥å‚è€ƒ[è¿™é‡Œ](https://www.dddappp.org/#what-is-a-true-low-code-development-platform)çš„é˜è¿°ã€‚

ä½ å¯èƒ½å¬è¯´è¿‡â€œè¡¨å•é©±åŠ¨â€çš„ä½ä»£ç å¹³å°æˆ–è€…â€œè¡¨æ ¼é©±åŠ¨â€çš„ä½ä»£ç å¹³å°ï¼Œä½†åœ¨è¿™é‡Œï¼Œæˆ‘ç‰¹æŒ‡çš„æ˜¯â€œæ¨¡å‹é©±åŠ¨â€çš„ä½ä»£ç å¹³å°ã€‚ä½ å¯ä»¥å°†æˆ‘çš„æè¿°ç†è§£ä¸ºå¯¹â€œä½ä»£ç å¹³å°â€æ¦‚å¿µçš„ç‹­ä¹‰è§£é‡Šã€‚


So, what do I refer to as the "de facto standard" for low-code platforms? You can refer to [this detailed explanation](https://www.dddappp.org/#what-is-a-true-low-code-development-platform) for more information.

You might have heard of "form-driven" or "table-driven" low-code platforms, but here, I am specifically referring to "model-driven" low-code platforms. You can consider my description as a narrow interpretation of the "low-code platform" concept.


---


ä¼ ç»Ÿåº”ç”¨çš„ä½ä»£ç å¼€å‘å¹³å°å·²ç»è¿›å…¥äº†æˆç†Ÿçš„æ—©æœŸé˜¶æ®µã€‚æœ‰äººå¯èƒ½ä¼šè¯´ï¼šâ€œæˆ‘ä¼¼ä¹æ²¡æœ‰å¬è¯´è¿‡â€˜æ¨¡å‹é©±åŠ¨â€™çš„ Web3 ä½ä»£ç å¼€å‘å¹³å°ã€‚â€
ç¡®å®ï¼Œè¿™æ˜¯ä¸€ä»¶ç›¸å¯¹ç½•è§çš„äº‹ç‰©ã€‚è®©æˆ‘ä»¬æ¥åˆ†æä¸€ä¸‹åŸå› ã€‚

é¦–å…ˆï¼Œä¸ºä»€ä¹ˆä¼ ç»Ÿçš„ä½ä»£ç å¹³å°æ²¡æœ‰è¿›å…¥ Web3 é¢†åŸŸï¼Ÿæˆ‘è®¤ä¸ºï¼Œä¸»è¦æ˜¯å› ä¸ºå®ƒä»¬æ‰€é‡‡ç”¨çš„å»ºæ¨¡èŒƒå¼å¹¶ä¸é€‚ç”¨äº Web3ã€‚

ä¼ ç»Ÿçš„ä¼ä¸šå¹³å°ä½¿ç”¨ E-R æ¨¡å‹å’Œ/æˆ–å…³ç³»æ¨¡å‹ã€‚
ä¾‹å¦‚ï¼Œ[OutSystems](https://www.outsystems.com/) åŒæ—¶ä½¿ç”¨ E-R æ¨¡å‹å’Œå…³ç³»æ¨¡å‹ï¼›
è€Œæœ‰äº›å¹³å°åˆ™åªé‡‡ç”¨å…¶ä¸­ä¸€ç§ã€‚E-R æ¨¡å‹å’Œå…³ç³»æ¨¡å‹åœ¨æ¦‚å¿µä¸Šæ˜¯ç›¸ä¼¼çš„ã€‚
è¿™äº›å¹³å°ç”Ÿæˆçš„ä»£ç å¯ä»¥åœ¨ä¼ ç»Ÿçš„ä¼ä¸šè½¯ä»¶åŸºç¡€è®¾æ–½ï¼ˆå¦‚ SQL æ•°æ®åº“ï¼‰ä¸Šè¿è¡Œã€‚
ä½†å®ƒä»¬å¾ˆéš¾åœ¨ Web3 åŸºç¡€è®¾æ–½å¦‚åŒºå—é“¾ä¸Šè¿è¡Œï¼Œå› ä¸ºåŒºå—é“¾ä¸Šçš„â€œå»ä¸­å¿ƒåŒ–è´¦æœ¬â€ä¸ SQL æ•°æ®åº“å·®å¼‚å¤ªå¤§ã€‚

é‚£ä¹ˆï¼Œç°æœ‰çš„å»ä¸­å¿ƒåŒ–åº”ç”¨â€œä½ä»£ç å¹³å°â€è¡¨ç°å¦‚ä½•å‘¢ï¼Ÿ

å¼€å‘ä¸€ä¸ªçœŸæ­£çš„ä½ä»£ç å¹³å°â€”â€”å°¤å…¶æ˜¯é‡‡ç”¨æ¨¡å‹é©±åŠ¨æ–¹æ³•â€”â€”å¹¶éæ˜“äº‹ã€‚æœ‰äº›äººå¯èƒ½ä¼šè¯•å›¾å›é¿è¿™é¡¹è‰°å·¨çš„å·¥ä½œã€‚
ä½†æ˜¯ï¼Œä¸“ä¸šä½ä»£ç å¹³å°çš„æ ¸å¿ƒåŠŸèƒ½å…·æœ‰å…¶ä»–è§£å†³æ–¹æ¡ˆæ— æ³•æ¯”æ‹Ÿçš„ç‹¬ç‰¹ä»·å€¼ã€‚
ä¾‹å¦‚ï¼Œâ€œå¯é…ç½®çš„æ™ºèƒ½åˆçº¦æ¨¡æ¿â€å¯ä»¥å¸®åŠ©å¼€å‘äººå‘˜æ›´å¿«åœ°å¤åˆ¶â€œç°æˆçš„ä»£ç â€ï¼Œä½†å¯¹äºé‚£äº›åˆ›æ–°åº”ç”¨æ¥è¯´ï¼Œè¿™äº›æ¨¡æ¿å¹¶æ— å¤ªå¤§ç”¨å¤„ã€‚
å¯¹äºå¹³å°å¼€å‘äººå‘˜æ¥è¯´ï¼Œç”¨ä¸åŒçš„è¯­è¨€ï¼ˆå¦‚ Solidityã€Move ç­‰ï¼‰ç¼–å†™å’Œç»´æŠ¤ä¸€ä¸ªé€‚ç”¨äºå¤šä¸ªé“¾çš„â€œæ™ºèƒ½åˆçº¦æ¨¡æ¿â€åº“ä¹Ÿæ˜¯ä¸€ä¸ªå·¨å¤§çš„æŒ‘æˆ˜ã€‚
æ­¤å¤–ï¼Œâ€œæ™ºèƒ½åˆçº¦â€åªæ˜¯åº”ç”¨ç¨‹åºçš„é“¾ä¸Šéƒ¨åˆ†ï¼Œç¨å¾®å¤§ä¸€äº›çš„å»ä¸­å¿ƒåŒ–åº”ç”¨ç¨‹åºé€šå¸¸è¿˜éœ€è¦é“¾ä¸‹éƒ¨åˆ†ã€‚


Traditional low-code development platforms for conventional applications have entered the early stages of maturity. Some might say, "I haven't heard of a 'model-driven' Web3 low-code development platform."
Indeed, such platforms are relatively rare. Let's delve into the reasons.


Firstly, why haven't traditional low-code platforms penetrated the Web3 domain? I believe it's primarily because the modeling paradigms they utilize are not suitable for Web3.

Traditional enterprise platforms employ E-R models and/or relational models.
For example, [OutSystems](https://www.outsystems.com/) uses both E-R models and relational models; some platforms use only one of them. E-R modeling and relational modeling have similar concepts.
The code generated by these platforms can operate on conventional enterprise software infrastructures, like SQL databases.
However, they struggle to function on Web3 infrastructures such as blockchains, where "decentralized ledgers" differ fundamentally from SQL databases.


So, how do the existing decentralized application "low-code platforms" perform?

Developing an authentic low-code platformâ€”particularly one that adopts a model-driven approachâ€”is no simple feat. Some may attempt to shirk this arduous task.
Yet, the core features of a professional low-code platform offer unique values unmatched by other solutions.
For instance, "configurable smart contract templates" can expedite developers' ability to replicate "ready-made code," but they are of little use for innovative applications.
For platform developers, composing and maintaining a library of "smart contract templates" in various languages (such as Solidity, Move, etc.) suitable for multiple chains presents a significant challenge. 
Additionally, the "smart contract" is only the on-chain part of an application; larger decentralized applications usually require an off-chain part.

---

é‚£ä¹ˆï¼Œæ˜¯å¦å­˜åœ¨ä¸€ä¸ªä¸æŠ•æœºå–å·§ã€å‹‡äºç›´é¢æŒ‘æˆ˜çš„â€œçœŸæ­£çš„â€â€”â€”é‡‡ç”¨â€œæ¨¡å‹é©±åŠ¨â€æ–¹æ³•çš„â€”â€”Web3 ä½ä»£ç å¼€å‘å¹³å°ï¼Ÿ

æˆ‘éå¸¸è‡ªè±ªåœ°å®£å¸ƒï¼Œæˆ‘æ‰€åœ¨çš„å›¢é˜Ÿå¼€å‘çš„ [dddappp](https://www.dddappp.org) æ˜¯ä¸€ä¸ªçœŸæ­£çš„å»ä¸­å¿ƒåŒ–åº”ç”¨ä½ä»£ç å¼€å‘å¹³å°ã€‚å®ƒå¾ˆå¯èƒ½æ˜¯ç›®å‰å”¯ä¸€ä¸€ä¸ªé‡‡ç”¨â€œæ¨¡å‹é©±åŠ¨â€æ–¹æ³•çš„ Web3 ä½ä»£ç å¼€å‘å¹³å°ã€‚

So, is there an authentic Web3 low-code development platform that doesn't cut corners and bravely faces challenges head-onâ€”a platform that truly adopts a "model-driven" approach?

I am immensely proud to announce that [dddappp](https://www.dddappp.org), developed by my team, is a genuine decentralized application low-code development platform. It is likely the only Web3 low-code development platform to date that employs a "model-driven" approach.

---

é‚£ä¹ˆï¼Œdddappp åˆ°åº•æœ‰ä½•ç‹¬ç‰¹ä¹‹å¤„ï¼Ÿå®ƒä¸ºä»€ä¹ˆå¯ä»¥åšåˆ°å…¶ä»–å¹³å°ï¼ˆæœ€å°‘æ˜¯æš‚æ—¶ï¼‰æ²¡æœ‰åšåˆ°çš„äº‹æƒ…ï¼Ÿ

å…³é”®æ˜¯ dddappp é‡‡ç”¨çš„å»ºæ¨¡èŒƒå¼ã€‚æˆ‘ä»¬é€‰æ‹©äº† DDD é£æ ¼çš„é¢†åŸŸæ¨¡å‹ã€‚

DDD é£æ ¼çš„é¢†åŸŸæ¨¡å‹æ˜¯ä¸€ä¸ªç›¸å¯¹é«˜å±‚æ¬¡æŠ½è±¡çš„ OOï¼ˆé¢å‘å¯¹è±¡ï¼‰æ¨¡å‹ã€‚
è‡ªåŠ¨åŒ–å·¥å…·å¯ä»¥å¾ˆå®¹æ˜“åœ°å°†è¿™æ ·çš„é«˜å±‚æ¬¡çš„é¢†åŸŸæ¨¡å‹æ˜ å°„åˆ°ä½å±‚æ¬¡çš„å®ç°æ¨¡å‹ï¼Œå¦‚é¢å‘å¯¹è±¡ç¼–ç¨‹æ¨¡å‹ã€å…³ç³»æ•°æ®æ¨¡å‹ç­‰ã€‚


So, what exactly sets dddappp apart? Why can it achieve what other platforms (at least for now) have not?

The key lies in the modeling paradigm adopted by dddappp. We have opted for DDD-style domain models.

DDD-style domain models are object-oriented (OO) models at a relatively high level of abstraction.
Automated tools can readily map such high-level domain models to lower-level implementation models, such as object-oriented programming models, relational data models, and so on.

---

ä»€ä¹ˆæ˜¯â€œé«˜å±‚æ¬¡æŠ½è±¡â€ï¼Ÿ
è¿™ä¹ˆè¯´å§ï¼Œå®ƒå°½å¯èƒ½å¤šåœ°å¸®åŠ©ä½ è¡¨è¿°ä½ å¯¹é¢†åŸŸçš„è®¤çŸ¥â€œæ˜¯ä»€ä¹ˆâ€ï¼Œè€Œä¸æ˜¯æŠ€æœ¯ç»†èŠ‚ä¸Šè§£å†³é—®é¢˜è¦â€œæ€ä¹ˆåšâ€ã€‚


What is "high-level abstraction"?
Put it this way, it assist you in articulating the "what" of your domain knowledge as much as possible, rather than the "how" of solving the problem in technical detail.


---


æœ‰ç»éªŒçš„å¼€å‘è€…é©¬ä¸Šèƒ½ç†è§£è¿™æ˜¯ä¸€ä»¶è¯´èµ·æ¥å®¹æ˜“åšèµ·æ¥éš¾çš„äº‹æƒ…ã€‚
æˆ‘ä»¬èƒ½åšåˆ°è¿™ä¸€ç‚¹ï¼Œå®Œå…¨æ˜¯å› ä¸ºæœºç¼˜å·§åˆï¼Œæˆ‘ä»¬åœ¨è¿™ä¸ªé¢†åŸŸç§¯ç´¯äº†ä¸°å¯Œçš„ç»éªŒâ€”â€”æˆ‘ä»¬ä» 2016 å¹´å°±å¼€å§‹åšè¿™ä¸ªäº‹æƒ…äº†ã€‚
æˆ‘ä»¬ç”šè‡³å†™äº†[ä¸€æœ¬ä¹¦](https://item.jd.com/12834017.html)æ¥å‘å¼€å‘è€…ä»¬åˆ†äº«æˆ‘ä»¬çš„ç»éªŒã€‚

å…³é”®åœ¨äºï¼Œæˆ‘ä»¬å‘æ˜äº†ä¸€ç§ç”¨äºé¢†åŸŸå»ºæ¨¡çš„æå…·è¡¨ç°åŠ›çš„ DSLï¼Œåä¸º DDDMLï¼ˆâ€œé¢†åŸŸé©±åŠ¨è®¾è®¡å»ºæ¨¡è¯­è¨€â€è‹±æ–‡çš„é¦–å­—æ¯ç¼©å†™ï¼‰ã€‚
ä½¿ç”¨å®ƒï¼Œä¸ä»…å¯ä»¥å‡†ç¡®åœ°æè¿°é¢†åŸŸçŸ¥è¯†ï¼Œè¿˜å¯ä»¥è½»æ¾åœ°å°†è¿™äº›æ¨¡å‹æ˜ å°„åˆ°è½¯ä»¶å®ç°ä»£ç ä¸­ã€‚

å¯¹äº†ï¼Œä¸å…¶ä»– "ç«äº‰å¯¹æ‰‹ "ç›¸æ¯”ï¼Œæˆ‘ä»¬çš„ DSL æ›´è´´è¿‘é—®é¢˜é¢†åŸŸå’Œè‡ªç„¶è¯­è¨€ï¼Œæˆ‘ä»¬ç›¸ä¿¡è¿™ä½¿å¾—å®ƒèƒ½å¤Ÿä¸äººå·¥æ™ºèƒ½ï¼ˆAIï¼‰å®Œç¾ç»“åˆã€‚


Experienced developers will immediately understand that this is easier said than done.
We have been able to achieve this because, by a fortunate coincidence, we have amassed extensive experience in this fieldâ€”we've been at it since 2016.
We even wrote a [book](https://item.jd.com/12834017.html) to share our insights with other developers.

The key lies in the expressive domain modeling DSL we've invented, named DDDML (Domain-Driven Design Modeling Language).
With it, you can not only precisely describe domain knowledge but also effortlessly map these models to software implementation code.

Moreover, compared to other "competitors", our DSL is closer to the problem domain and natural language, which we believe allows for seamless integration with artificial intelligence.


---


æˆ‘ä»¬è‡ªå·±ä¸€ç›´æŠŠ DDDML ç§°ä¸ºâ€œDDD åŸç”Ÿ DSLâ€ã€‚

è¿˜è®°å¾—æˆ‘ä¹‹å‰æåˆ°çš„æ¥è‡ª DDD çš„â€œèšåˆâ€æ¦‚å¿µå—ï¼Ÿ
æˆ‘ä»¬ä½¿ç”¨çš„ DSL ä»ä¸€å¼€å§‹å°±æ”¯æŒå®šä¹‰èšåˆï¼Œæ‰“å¼€ä»»ä½•ä¸€ä¸ª DDDML æ¨¡å‹æ–‡ä»¶ï¼Œä½ å‡ ä¹éƒ½èƒ½çœ‹åˆ° `aggregates` è¿™ä¸ªå…³é”®å­—ã€‚


We have always referred to DDDML as the "native DSL for DDD".

Remember the "Aggregate" concept from DDD we mentioned earlier? The DSL we use inherently supports defining aggregates, and you can find the keyword `aggregates` in almost any DDDML model file you open.


---


å¦‚æœä½ ç†Ÿæ‚‰ DDD çš„ç›¸å…³æ¦‚å¿µï¼Œä¼šå¾ˆå®¹æ˜“çœ‹æ˜ç™½ DDDML æ‰€æè¿°çš„æ¨¡å‹ï¼›
å¦‚æœä½ ä¸ç†Ÿæ‚‰ï¼Œé‚£ä¹Ÿä¸è¦ç´§ï¼ŒDDD æ—¢æœ‰ç»å…¸è‘—ä½œçš„ç³»ç»Ÿæ€§çš„è®ºè¿°ï¼Œæ›´æœ‰æ‹¥è¶¸ä»¬ä¸æ—¶ä¿±è¿›çš„å®è·µç»éªŒï¼Œ
åªè¦ä½ æ„¿æ„â€œæ‹¿æ¥â€ï¼Œå®ƒä»¬å‡ ä¹æ˜¯å”¾æ‰‹å¯å¾—ã€‚

If you're familiar with DDD concepts, you'll easily grasp the models described by DDDML;
if you're not, no worriesâ€”DDD is well-documented both in classic literature and through the evolving practical experiences of its advocates.
As long as you're willing to seek them out, they are readily accessible.


---


DDD æ–¹æ³•è®ºçš„å¼ºå¤§åº•è•´å¸¸å¸¸ç»™æˆ‘ä»¬å¸¦æ¥æƒŠå–œã€‚
æˆ‘ä»¬åœ¨å¼€å‘ä¼ ç»Ÿåº”ç”¨ï¼ˆå…¶åç«¯ä¸»è¦ç”± Java æˆ– C# ç¼–å†™ï¼‰æ—¶ï¼Œå°±ä¸€ç›´åœ¨ä½¿ç”¨â€œé¢†åŸŸæ¨¡å‹é©±åŠ¨â€çš„æ–¹æ³•ï¼Œæå¤§æå‡äº†å¼€å‘æ•ˆç‡ã€‚
å½“æˆ‘ä»¬è¿›å…¥ Web3 çš„æ–°å¤©åœ°åï¼Œæˆ‘ä»¬å‘ç°ï¼Œä¸ç”¨ç»™ DDDML å¢åŠ å¤ªå¤šçš„ä¸œè¥¿ï¼Œå°±èƒ½å¤Ÿä½¿ç”¨å®ƒæ¥é©±åŠ¨å»ä¸­å¿ƒåŒ–åº”ç”¨çš„å¼€å‘ã€‚


The profound foundation of the DDD methodology frequently brings us delightful surprises.
In developing traditional applications (whose backends are primarily written in Java or C#), we have consistently employed a "domain model-driven" approach, which has greatly enhanced our development efficiency.
As we stepped into the new realm of Web3, we found that without needing to make many additions to DDDML, it could be effectively used to drive the development of decentralized applications.



---

é‚£ä¹ˆï¼Œdddappp é‡‡ç”¨çš„æŠ€æœ¯æ–¹æ¡ˆèƒ½çœŸæ­£å¸®åŠ©åˆ° AO ç”Ÿæ€çš„å¼€å‘è€…å—ï¼Ÿ
è¯·çœ‹æˆ‘ä»¬æœ€è¿‘å®Œæˆçš„ä¸€ä¸ª[åŸºäº AO çš„æ¦‚å¿µéªŒè¯](https://github.com/dddappp/A-AO-Demo)ã€‚


åœ¨è¿™ç¯‡æ–‡ç« çš„å‰åŠéƒ¨åˆ†ï¼Œæˆ‘ä»¬è°ˆåˆ°äº†ä½¿ç”¨ AO å¼€å‘åº”ç”¨é¢ä¸´çš„ä¸€äº›æŒ‘æˆ˜ã€‚
åœ¨è¿™ä¸ªæ¼”ç¤ºé‡Œé¢ï¼Œæˆ‘ä»¬ç›¸ä¿¡æœ‰äº›é—®é¢˜æˆ‘ä»¬å·²ç»æä¾›äº†éå¸¸æœ‰å¸å¼•åŠ›çš„è§£å†³æ–¹æ¡ˆã€‚
æˆ‘ä»¬æ¼”ç¤ºäº†å¦‚ä½•ä½¿ç”¨ DSL å®šä¹‰èšåˆã€å€¼å¯¹è±¡ã€æœåŠ¡ï¼ˆè¿™äº›éƒ½æ˜¯ DDD çš„æ¦‚å¿µï¼‰ï¼Œå±•ç¤ºäº†ç”Ÿæˆä»£ç çš„å¤§è‡´æ ·è²Œã€‚ä½ å¯ä»¥æƒ³è±¡ä¸€ä¸‹ï¼Œå¦‚æœä¸ç”¨å·¥å…·ï¼Œå¼€å‘äººå‘˜çœŸçš„æ„¿æ„æ‰‹å†™è¿™äº›ä»£ç ï¼Ÿ
ç‰¹åˆ«æ˜¯ï¼Œæˆ‘ä»¬è¿˜æ¼”ç¤ºäº†ç”Ÿæˆçš„ä»£ç å¦‚ä½•ä½¿ç”¨ [SAGA](https://microservices.io/patterns/data/saga.html) æ¨¡å¼ä¼˜é›…åœ°å®ç°â€œæœ€ç»ˆä¸€è‡´æ€§â€çš„å¤„ç†ã€‚

æˆ‘ä»¬æŠŠè¿™ä¸ªæ¼”ç¤ºç§°ä¸º PoCï¼Œä½†æ˜¯å®é™…ä¸Šæˆ‘è®¤ä¸ºå®ƒå·²ç»è¶…è¶Šäº† PoCã€‚å› ä¸ºå®ƒç°åœ¨å°±å¯ä»¥é©¬ä¸Šå¸®åŠ©åˆ° AO ç”Ÿæ€çš„å¼€å‘è€…ã€‚
AO ç”Ÿæ€çš„å¼€å‘è€…ç°åœ¨å°±å¯ä»¥ä½¿ç”¨å®ƒæ¥ç†æ¸…åº”ç”¨çš„è®¾è®¡æ€è·¯ã€ç”Ÿæˆä»£ç ï¼ˆè¿™äº›ä»£ç æœ€å°‘å¯ä»¥ä½œä¸ºå®ç°å‚è€ƒï¼‰ã€æå‡æ•ˆç‡ã€‚
ä»æŸç§ç¨‹åº¦ä¸Šæ¥è¯´ï¼Œè¿™ä¸ªå·¥å…·ä½ å·²ç»å¯ä»¥è¯´å®ƒæ˜¯ä¸€ä¸ª MVPï¼ˆæœ€å°å¯è¡Œäº§å“ï¼‰ã€‚
å› ä¸º MVP çš„å®šä¹‰æ˜¯ï¼Œåªè¦èƒ½å¤Ÿå¸®åŠ©åˆ°æœ€ç»ˆç”¨æˆ·ï¼Œå¯¹æœ€ç»ˆç”¨æˆ·æœ‰ä»·å€¼ï¼Œé‚£å°±å¯ä»¥ç§°ä¹‹ä¸º MVPã€‚æ¯•ç«Ÿï¼Œå¼€å‘è€…å°±æ˜¯ä½ä»£ç å·¥å…·çš„æœ€ç»ˆç”¨æˆ·ã€‚


So, can the technical solution adopted by dddappp genuinely assist developers in the AO ecosystem?
Take a look at our recent [AO-based Proof of Concept](https://github.com/dddappp/A-AO-Demo).

In the first half of this article, we discussed some of the challenges faced when developing applications with AO.
In this demonstration, we believe we have provided very compelling solutions to certain issues.
We showed how to use DSL to define aggregates, value objects, and services (all DDD concepts), and what the generated code generally looks like. Can you imagine, without tools, would developers really be willing to manually write this code?
Especially, we also demonstrated how the generated code can elegantly handle "eventual consistency" with the [SAGA](https://microservices.io/patterns/data/saga.html) pattern.

We refer to this demonstration as a PoC, but in reality, I think it has surpassed just being a PoC. It is already capable of immediately assisting developers within the AO ecosystem.
Developers in the AO ecosystem can now use it to clarify their application design ideas, generate code (which at the very least can serve as a reference for implementation), and enhance efficiency.
To some extent, you could already consider this tool as an MVP (Minimum Viable Product).
Because an MVP is defined as something that provides value to the end-users, and as long as it helps them, it can be considered an MVP. After all, developers are the end-users of low-code tools.

---


æˆ‘ç›¸ä¿¡ï¼Œå¤§å¤šæ•°ç»éªŒä¸°å¯Œçš„åº”ç”¨å¼€å‘è€…éƒ½ä¼šè®¤åŒè¿™ä¸ª PoC çš„è¯´æœåŠ›ï¼šæ¨¡å‹é©±åŠ¨çš„ä½ä»£ç æ–¹å¼ç¡®å®èƒ½è§£å†³å»ä¸­å¿ƒåŒ–åº”ç”¨å¼€å‘è€…çš„â€œç—›ç‚¹â€ã€‚

æˆ‘ä»¬ä¹‹å‰å·²ç»ä¸€æ¬¡åˆä¸€æ¬¡åœ°è¯æ˜äº†è¿™ä¸€ç‚¹ã€‚

æˆ‘ä»¬åˆ©ç”¨ DSL è§£å†³äº† Moveï¼ˆä¸€ç§é™æ€æ™ºèƒ½åˆçº¦è¯­è¨€ï¼‰ç¼ºä¹â€œæ¥å£â€æŠ½è±¡çš„é™åˆ¶ï¼Œå¸®åŠ©å¼€å‘è€…è½»æ¾å®ç°â€œä¾èµ–æ³¨å…¥â€ï¼Œ
è¯¦æƒ…è¯·è§[æ­¤ç¤ºä¾‹](https://github.com/dddappp/sui-interface-demo)ã€‚

æˆ‘ä»¬å¯ä»¥é€šè¿‡ç®€å•çš„å£°æ˜å°† Move åˆçº¦æ‹†åˆ†æˆå¤šä¸ªåŒ…ï¼ˆå³â€œé¡¹ç›®â€ï¼‰ï¼Œè§[æ­¤ç¤ºä¾‹](https://github.com/wubuku/aptos-constantinople)ã€‚
éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¤§å¤šæ•° Move å…¬é“¾å¯¹æ¯æ¬¡å‘å¸ƒçš„åŒ…çš„å¤§å°éƒ½æœ‰é™åˆ¶ã€‚



I believe that most experienced application developers will agree that this PoC is very convincing: the model-driven low-code approach can indeed solve the "pain points" of dapp developers. As we have repeatedly proven.

We have used DSL to overcome the lack of "interface" abstraction in Move, a static smart contract language, facilitating easy "Dependency Injection" for developers;
see [this example](https://github.com/dddappp/sui-interface-demo).

We can split Move contracts into multiple packages (or "projects") with simple declarations, as shown in [this example](https://github.com/wubuku/aptos-constantinople). 
It's important to note that most Sui public chains have size limits for each package released.

---

å¦‚æœä½ è®¤ä¸ºæˆ‘ä»¬åˆ†äº«çš„åªæ˜¯ä¸€äº›â€œç¤ºä¾‹â€ï¼Œæˆ‘ä»¬å¯èƒ½åªæ˜¯åœ¨åˆ¶ä½œä¸€äº›ç©å…·ï¼Œé‚£ä½ å°±å¤§é”™ç‰¹é”™äº†ã€‚

æˆ‘ä»¬æ·±åº¦å‚ä¸äº†ä¸€äº›ä¸¥è‚ƒçš„å•†ä¸šåº”ç”¨çš„å¼€å‘ï¼ˆä¸»è¦é›†ä¸­åœ¨ Move ç”Ÿæ€ï¼‰è¿‡ç¨‹ï¼Œåœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬å‡ ä¹å°±æ˜¯ä¸€ç›´åœ¨â€œåƒè‡ªå·±çš„ç‹—ç²®â€ã€‚
æˆ‘ä»¬å¯ä»¥éå¸¸è‡ªä¿¡åœ°è¯´ï¼Œç›®å‰ï¼Œè‡³å°‘åœ¨åç«¯ï¼ˆæˆ‘æŒ‡çš„æ˜¯é“¾ä¸‹åˆçº¦å’Œé“¾ä¸‹æŸ¥è¯¢æœåŠ¡ï¼Œåè€…æœ‰æ—¶å€™è¢«ç§°ä¸º indexerï¼‰å¼€å‘é¢†åŸŸï¼Œæˆ‘ä»¬å…‘ç°äº† 10 å€å¼€å‘æ•ˆç‡çš„æ‰¿è¯ºã€‚

å¦‚æœä½ è”ç³»æˆ‘ä»¬ï¼Œæˆ‘ä»¬å¯ä»¥å‘ä½ å±•ç¤ºæ›´å¤šç”Ÿäº§çº§çš„æ¡ˆä¾‹ã€‚


If you think that what we've shared are merely "examples," and we might just be creating toys, then you are greatly mistaken.

We have been deeply involved in the development of some serious commercial applications (primarily within the Move ecosystem), where we have consistently been "eating our own dog food."
We can say with confidence that, at present, we have fulfilled our promise of a tenfold increase in development efficiency, especially in the backend area (referring to off-chain contracts and off-chain query services, sometimes known as an "indexer").

If you reach out to us, we can show you more production-level cases.


---

## æ˜¯ä¸æ˜¯å¯ä»¥ææâ€œAppCUâ€å‘¢ï¼Ÿ

## Why not "AppCU"?


è™½ç„¶ Lua å’Œ WASM çš„ç»„åˆå¾ˆå¥½ï¼Œä½†æ˜¯è€å®è¯´ï¼ŒçŸ­æ—¶é—´å†…ï¼Œæˆ‘æ— æ³•æƒ³è±¡ä¾é å®ƒä»¬èƒ½å°†é‚£äº›ç”¨ä¼ ç»Ÿä¸Šä»¥ Javaã€C#ã€PHPã€Python ç­‰è¯­è¨€ç¼–å†™çš„å¤§å‹ Web2 äº’è”ç½‘åº”ç”¨ç¨‹åºï¼ˆå¦‚äºšé©¬é€Šã€æ·˜å®ã€eBayã€Shopee ç­‰ï¼‰è¿ç§»åˆ° AO ä¸Šã€‚

æ­£å¦‚ä¹‹å‰æ‰€è¿°ï¼ŒAO æ˜¯ä¸€ä¸ªæ•°æ®åè®®ã€‚ç†è®ºä¸Šï¼Œä»»ä½•äººéƒ½å¯ä»¥ä½¿ç”¨è‡ªå·±å–œæ¬¢çš„ç¼–ç¨‹è¯­è¨€å¼€å‘è‡ªå·±çš„â€œå®ç°â€ï¼Œå¹¶æ¥å…¥ AO ç½‘ç»œï¼Œä¸å…¶ä»–å•å…ƒè¿›è¡Œäº¤äº’å’Œåä½œã€‚

åœ¨ AO ç½‘ç»œä¸­ï¼Œåº”ç”¨çš„ä¸šåŠ¡é€»è¾‘åœ¨è®¡ç®—å•å…ƒï¼ˆCompute Unitsï¼‰ä¸­æ‰§è¡Œã€‚
å› æ­¤ï¼Œå¯¹äºåº”ç”¨å¼€å‘è€…è€Œè¨€ï¼Œä»–ä»¬æœ€å¸Œæœ›çœ‹åˆ°çš„æ˜¯è®¡ç®—å•å…ƒåœ¨æ”¯æŒçš„å¼€å‘æ ˆæ–¹é¢æ›´åŠ å¤šå…ƒåŒ–å’ŒåŒ…å®¹ã€‚
æ®æˆ‘æ‰€çŸ¥ï¼ŒAO å¼€å‘è€…ç¤¾åŒºå·²ç»åœ¨è¿™ä¸ªæ–¹å‘ä¸ŠåŠªåŠ›ï¼Œä¾‹å¦‚æ”¯æŒåœ¨ AO ä¸Šè¿è¡Œ EVM æ™ºèƒ½åˆçº¦ç­‰ã€‚

ç„¶è€Œï¼Œæˆ‘è®¤ä¸ºè¿™ä¸ªé—®é¢˜ä¹Ÿè®¸å¯ä»¥ä»å¦ä¸€ä¸ªæ–¹å‘å–å¾—çªç ´ã€‚æˆ‘ç›¸ä¿¡ AppCU æ˜¯ä¸€ä¸ªå¥½ä¸»æ„ã€‚
AppCUï¼Œæˆ‘æŒ‡çš„æ˜¯ Application-specific Compute Unitã€‚
ç”¨ Appchainï¼ˆ[Application-specific blockchain](https://www.coinbase.com/learn/crypto-glossary/what-is-an-application-specific-blockchain-appchain)ï¼‰åšä¸ªç±»æ¯”ï¼Œæœ‰åŠ©äºç†è§£æˆ‘çš„æ„æ€ã€‚



Although the combination of Lua and WASM is promising, frankly, it's hard to envision migrating large-scale Web2 internet applicationsâ€”like Amazon, Taobao, eBay, Shopeeâ€”traditionally written in languages such as Java, C#, PHP, Python, etc., to AO in the short term.

As previously mentioned, AO is a data protocol. In theory, anyone can develop their own implementation using their preferred programming language to integrate with the AO network, interacting and collaborating with other units.


Within the AO network, the business logic of applications is executed in Compute Units.
Therefore, for application developers, the most desirable aspect is likely the diversity and inclusiveness of the supported development stacks in Compute Units.
I've heard that the AO developer community is already working in this direction, with things like support for running EVM smart contracts on AO.

However, I think there might be another direction for a breakthrough with this issue. I believe AppCU is a good idea.
AppCU stands for Application-specific Compute Unit here.
An analogy with Appchain ([Application-specific blockchain](https://www.coinbase.com/learn/crypto-glossary/what-is-an-application-specific-blockchain-appchain)) may clarify this concept.


---

ä»é›¶å¼€å§‹æ„å»ºä¸€ä¸ª AppCU å¯¹å¤§å¤šæ•°å¼€å‘è€…æ¥è¯´å¯èƒ½å¹¶ä¸å®¹æ˜“ï¼Œæ„å»ºä¸€ä¸ª Appchain ä¹ŸåŒæ ·å¦‚æ­¤ã€‚å› æ­¤ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä¸€ä¸ªå¾—å¿ƒåº”æ‰‹çš„å·¥å…·æ˜¯å¿…ä¸å¯å°‘çš„ã€‚

æˆ‘æƒ³ï¼Œä¸å¿…å†å¼ºè°ƒ [Cosmos SDK](https://docs.cosmos.network)ï¼ˆç”¨äºæ„å»º Appchain çš„å·¥å…·ï¼‰åœ¨ [Cosmos](https://cosmos.network) ç”Ÿæ€å‘å±•ä¸­æ‰€å‘æŒ¥çš„é‡è¦ä½œç”¨äº†å§ï¼Ÿ

é‚£äº›å°è¯•è¿‡ Cosmos SDK çš„å¼€å‘è€…ï¼Œä¸€å®šä¼šå¯¹è¿™ä¸ªå·¥å…·çš„ä¾¿åˆ©æ€§å’Œå¼ºå¤§åŠŸèƒ½å°è±¡æ·±åˆ»ã€‚å¦‚æœ Cosmos SDK èƒ½å¤Ÿåšåˆ°ï¼Œé‚£ä¹ˆ AO ç”Ÿæ€çš„å¼€å‘è€…ç¤¾åŒºä¹Ÿæ²¡æœ‰ç†ç”±åšä¸åˆ°ã€‚

Cosmos SDK ç¡®å®æ˜¯ä¸€ä¸ªâ€œé«˜æ•ˆç‡â€å·¥å…·ï¼Œä½†ä¸¥æ ¼æ¥è¯´ï¼Œå®ƒå¹¶ä¸æ˜¯ä¸€ä¸ªä½ä»£ç å¹³å°ã€‚æˆ‘ä»¬ç›¸ä¿¡ä½ä»£ç å¹³å°åœ¨æå‡å¼€å‘æ•ˆç‡æ–¹é¢æœ‰ç€æ›´å¤§çš„æ½œåŠ›ã€‚


Building an AppCU from scratch can be a challenging task for most developers, and the same goes for constructing an Appchain. Therefore, having the right tools at hand is indispensable in such endeavors.

I suppose there's no need to reiterate the pivotal role that the [Cosmos SDK](https://docs.cosmos.network) (the tool for building Appchains) has played in the growth of the [Cosmos](https://cosmos.network) ecosystem, is there?

Developers who have experimented with the Cosmos SDK must have been struck by its convenience and power. If the Cosmos SDK can achieve this, then there's no reason the AO ecosystem's developer community can't do the same.

Indeed, the Cosmos SDK is a "high-efficiency" tool, but strictly speaking, it is not a low-code platform. We believe that low-code platforms hold even greater potential for enhancing development efficiency.


---



