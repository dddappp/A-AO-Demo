| Title                               | Description                                                                                                                                 | Author                   | Type              |
| ----------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------ | ----------------- |
| AppCU Low-Code Development Platform | Using domain model-driven approach to develop AppCU, significantly improving AO application development efficiency and reducing complexity. | yangjiefeng at gmail.com | Development Tools |


# Summary

Our low-code development platform allows developers to use familiar general-purpose programming languages (we plan to support Java first) and tools to quickly develop AO decentralized applications by building AppCU (Application-Specific Compute-Unit).

# Motivation

The prosperity of the AO ecosystem depends on developer participation, which in turn depends on the diversity and development efficiency of applications that can be built on AO. We believe AppCU offers a new approach to solving these issues.

To understand AppCU, you can compare it to Appchain (Application-Specific Blockchain). More detailed explanations can be found [here](https://github.com/dddappp/A-AO-Demo/blob/main/doc/WinningOverDevelopersWithLowCodeSolutions.md#why-not-appcu).


# Principles and Feasibility

AO is a data protocol. Think of it as a set of interface standards that define how various [Units](https://cookbook_ao.g8way.io/concepts/units.html) within the AO network collaborate. Currently, the official implementation of AO includes a WASM-based virtual machine environment and a Lua runtime environment (ao-lib) that compiles to WASM, designed to simplify the development of AO processes. In theory, anyone can use their preferred programming language to develop their own "implementation," connect to the AO network, and interact and collaborate with other units.

In the AO network, the business logic of applications is executed in Compute Units. Excluding Compute Units, the rest of AO can be seen as a decentralized message broker systemâ€”think of it as the "Web3 version of Kafka." (Allowing traditional application developers to use their familiar languages and tools to develop microservice architecture applications based on a Kafka-like message broker is a highly attractive proposition.)

Therefore, from the essence of AO, we can easily determine that AppCU has no technical feasibility issues. The key question that follows is whether it is feasible to develop AppCU in a low-code manner and to what extent it can improve development efficiency.

We rarely see low-code platforms for decentralized applications that are "model-driven."

Traditional low-code development platforms for applications have entered an early stage of maturity; why haven't they entered the Web3 field? We believe it is mainly because the modeling paradigms they use are not suitable for developing decentralized applications. Traditional enterprise platforms use E-R models and/or relational models. For example, [OutSystems](https://www.outsystems.com/) uses both E-R models and relational models; some platforms use only one of them. E-R models and relational models are conceptually similar. The code generated by these platforms can run on traditional enterprise software infrastructure (such as SQL databases). However, they are difficult to run on Web3 infrastructure like blockchains because the "decentralized ledger" on the blockchain is too different from SQL databases.

Therefore, the key issue is the modeling paradigm. Our low-code platform chooses the DDD (Domain-Driven Design) style domain model. The DDD domain model is a relatively high-level abstract OO (Object-Oriented) model. Automated tools can easily map such high-level domain models to low-level implementation models, including but not limited to object-oriented programming models, relational data models, etc.

This is a [proof of concept](https://github.com/dddappp/A-AO-Demo) we recently completed for low-code development of AO decentralized applications.

In this demonstration, we show how to use DSL to define aggregates, value objects, services (these are DDD concepts), and the general appearance of AO Lua code that low-code tools can generate. Specifically, we also show how the generated code elegantly implements "eventual consistency" processing using the [SAGA](https://microservices.io/patterns/data/saga.html) pattern. (Can you imagine developers being willing to manually write so much code without the help of tools?)

Although this PoC does not demonstrate how to generate (non-Lua implemented) AppCU, we are confident that it has shown the great potential of low-code methods in improving the development efficiency of AO decentralized applications.

# Reference Implementation

To understand how our low-code approach can help developers solve core complexity issues in software development, allowing them to focus more on implementing the business logic of the domain they serve, you don't need to look at the complex traditional applications we developed using the same approach in the Web2 era. Observing our practices in the Move ecosystem alone is enough to convince you.

For example, we use DSL to solve the limitation of Move (as a static language) lacking "interface" abstraction, helping developers easily implement "dependency injection." For details, see [this example](https://github.com/dddappp/sui-interface-demo).

We can split Move contracts into multiple packages (i.e., "projects") through simple declarations, see [this example](https://github.com/wubuku/aptos-constantinople). Note that most Move public chains have restrictions on the size of each published package.


Outside the Move ecosystem, we have also implemented [PoC for Developing Solana Apps with Low-Code](https://github.com/dddappp/A-Solana-Demo) and [PoC for Developing EVM Apps with Low-Code](https://github.com/wubuku/hello-mud).

We are not just "making some toys." We are deeply involved in the development of some serious commercial applications (mainly focused on the Move ecosystem), during which we have been "eating our own dog food." We can confidently say that at least in the backend (on-chain contracts and off-chain query services, sometimes called indexers) development field, we have delivered on the promise of 10x development efficiency.

We even developed "no-code" applications based on "low-code" (side note: no-code tools are applications for end-users, while low-code is for professional developers). We built a side product called Move Forms at the Aptos Singapore Hackathon, which won second place. (We will continue to build this Web3 native form tool in our "spare time.")

Contact us, and we can show more production-level cases. Our cases include social, DeFi, full-chain games, etc.

# Required Resources

If we have partners familiar with the [aoconnect](https://cookbook_ao.g8way.io/guides/aoconnect/installing-connect.html) implementation joining us, it will greatly help our project.

We will first try to integrate aoconnect into AppCU, likely reusing existing aoconnect functions rather than reimplementing them in other languages (we are relatively familiar with backend "common" languages like Java, C#, etc.). During this process, we may discover areas for improvement in aoconnect. We hope someone can help us fork the repository and make modifications; of course, the improvements will also be fed back to the upstream aoconnect repository.

Even if we find that integrating aoconnect is not the best solution, we can learn the implementation details of aoconnect more quickly from them and avoid detours.
