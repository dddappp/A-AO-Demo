# AES-256-GCM + Shamir 门限分片演示

这是一个完整的 Java Maven 项目示例，演示了现代密码学和秘密分享技术的关键概念和技术实现要点。该项目展示了如何将对称加密与门限秘密分享相结合，实现安全的分布式密钥管理。

## 🎯 演示目标

本项目演示以下三个关键技术点：

1. **AES-256-GCM 加密**：使用高级加密标准（AES）256位密钥结合伽罗瓦计数器模式（GCM），对"数字藏品"明文进行加密，生成随机初始化向量（IV），并强制验证 GCM 认证标签，确保数据完整性和真实性。

2. **Shamir 门限秘密分享**：使用 Shamir's Secret Sharing 算法将 AES 密钥按 **t-of-n** 方案（示例中设为 7-of-10）进行分片，将密钥安全地分发给 10 个独立节点。

3. **分布式密钥重构**：模拟"至少 t 个节点共同同意/出片"的场景，在内存中重构完整密钥，并使用重构的密钥成功解密密文。

## 🔐 技术背景

### AES-256-GCM
- **AES (Advanced Encryption Standard)**：目前最广泛使用的对称加密算法
- **GCM (Galois/Counter Mode)**：提供机密性和完整性保证的认证加密模式
- **256位密钥**：提供极高的安全性，暴力破解在计算上不可行
- **随机IV**：确保每次加密即使使用相同密钥也能产生不同密文

### Shamir's Secret Sharing
- **门限秘密分享算法**：由 Adi Shamir 于 1979 年提出
- **t-of-n 方案**：需要至少 t 个分片才能重构秘密，少于 t 个分片无法获得任何信息
- **信息论安全性**：即使知道 n-1 个分片，也无法推断出原始秘密的任何信息
- **分布式信任**：避免单点故障，提高系统的安全性和可用性

### IV (Initialization Vector)
- **初始化向量**：用于确保每次加密即使使用相同密钥也能产生不同密文
- **随机性要求**：必须是密码学安全的随机数，每次加密都应不同
- **防止重放攻击**：即使明文相同，IV 不同也会产生完全不同的密文
- **GCM 模式要求**：使用 96-bit (12字节) IV，确保加密的安全性和唯一性
- **存储要求**：**不能丢弃**，解密时必须使用相同的 IV

## 🚀 快速开始

### 环境要求
- Java 11 或更高版本
- Maven 3.6+

### 构建项目
```bash
mvn clean package
```

### 运行演示
```bash
java -jar target/demo-1.0-SNAPSHOT.jar
```

## 📁 项目结构

```
AES-Shamir-Demo/
├── pom.xml                          # Maven 项目配置
├── README.md                        # 项目文档（本文件）
└── src/main/java/com/example/demo/
    └── Main.java                    # 演示主程序
```

## 📋 依赖说明

项目使用以下关键依赖：

- **com.codahale:shamir** (0.7.0)：提供 Shamir 秘密分享算法的 Java 实现
- **org.bouncycastle:bcprov-jdk15on** (1.70)：Bouncy Castle 加密库，**可选**（Java 9+ 已内置 AES-GCM 支持）

> **注意**：在 Java 9 及更高版本中，AES-GCM 加密算法已由标准库提供支持。如使用 Java 11+，可注释掉 Bouncy Castle 依赖项。

## 💻 核心代码

核心演示代码位于 [`src/main/java/com/example/demo/Main.java`](src/main/java/com/example/demo/Main.java)，包含完整的 AES-256-GCM 加密和 Shamir 门限分片实现。

项目配置文件：[`pom.xml`](pom.xml)

## 📊 运行输出示例

程序运行后将依次打印以下信息：

1. **密钥生成阶段**：
   - 生成的 AES-256-GCM 密钥（64字符十六进制）
   - 随机生成的 96-bit IV（24字符十六进制）**⚠️ 重要：IV 必须与密文一起保存，用于解密**
   - 待加密的明文内容

2. **加密阶段**：
   - 使用 AES-256-GCM 加密后的密文（包含认证标签）
   - 将 IV 和密文组合成完整的加密数据包（IV在前，密文在后）

3. **分片阶段**：
   - 10 个节点各自持有的密钥分片（每个分片 64字符十六进制）

4. **重构阶段**：
   - 随机选取的 7 个节点及其分片
   - 重构后的完整密钥
   - 重构校验结果（true 表示成功）

5. **解密验证阶段**：
   - 从完整的加密数据包中提取 IV 和密文
   - 使用提取的 IV 和重构密钥成功解密得到原始明文

6. **IV 验证阶段**：
   - 演示使用错误的 IV 会导致 "Tag mismatch" 解密失败

## 🔍 技术要点详解

### 参数配置
- `KEY_SIZE = 256`：AES-256 提供最高安全等级
- `IV_SIZE = 12`：GCM 模式推荐的 96-bit (12字节) IV，**每次加密必须唯一且随机**
- `TAG_SIZE = 128`：GCM 认证标签长度，提供完整性保证
- `N = 10, T = 7`：7-of-10 门限方案，平衡安全性和可用性

### IV 重要性详解
- **无 IV 的问题**：相同明文+相同密钥=相同密文，易被模式分析攻击
- **IV 的作用**：使加密结果随机化，即使明文和密钥相同也能产生不同密文
- **安全要求**：IV 必须是随机的、不可预测的，且在密钥生命周期内不会重复使用
- **在 AES-GCM 中**：IV 用于初始化计数器模式，确保每个加密块都是唯一的
- **存储要求**：**不能丢弃**，解密时必须使用加密时相同的 IV，否则会导致 "Tag mismatch" 错误
- **最佳实践**：IV 通常与密文一起存储，可以明文保存（因为它是公开的随机数）
- **存储格式**：实际应用中通常使用 `IV + 密文` 的格式，将两者组合成单个数据包

### 安全性考虑
- **密钥随机性**：使用 `SecureRandom` 生成密码学安全的随机数
- **IV唯一性**：每次加密使用不同的随机 IV，防止重放攻击
- **认证加密**：GCM 模式同时提供机密性和完整性保护
- **门限安全**：Shamir 算法确保少于 7 个分片无法重构密钥

## 🏗️ 架构意义

此演示展示了分布式系统中密钥管理的最佳实践：

- **去中心化信任**：密钥分片到多个独立节点，避免单点故障
- **访问控制**：需要多方共识才能重构密钥，提高安全性
- **容错性**：系统可以在部分节点失效的情况下继续工作
- **审计跟踪**：每次密钥重构都可以记录参与的节点

## 🎯 应用场景

这种技术组合特别适用于：

- **数字资产管理**：NFT、数字藏品的安全存储和访问控制
- **企业密钥管理**：分布式密钥托管和多方控制
- **区块链系统**：去中心化身份验证和智能合约安全
- **合规要求**：满足金融和政府系统的安全标准

---

此示例完整展示了现代密码学技术的实际应用，代码简洁清晰，易于理解和扩展。所有关键技术点都在内存中完整演示，无需外部依赖即可运行。
