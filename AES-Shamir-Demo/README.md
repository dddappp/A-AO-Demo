# 🔐 保险箱 + 分钥匙系统 - AES-GCM + Shamir 分片演示

想象一下，你有一件贵重的宝物需要安全保存：

1. **保险箱**：用现代加密算法把宝物锁起来
2. **分钥匙**：把保险箱钥匙分成多片，分别保管
3. **多人协作**：需要多人一起才能打开保险箱

这就是这个项目演示的技术！用简单直白的代码展示复杂的密码学概念。

## 🎯 这个项目做什么？

**简单来说**：演示如何安全地保护数据，即使攻击者拿到部分信息也无法破解。

**技术细节**：
- 🔒 **AES-256-GCM**：像保险箱一样保护你的数据
- 🗝️ **Shamir 分片**：把钥匙分成 10 片，收集 7 片就能重组成完整钥匙
- 🤝 **多人协作**：模拟多个人一起保管和恢复秘密的过程

## 🤔 先理解几个基本概念

### 🔑 什么是 AES-256-GCM？
想象你有一把非常坚固的锁（AES）和一个智能锁芯（GCM）：

- **AES-256**：一种加密算法，使用 256 位长的钥匙。非常安全，暴力破解需要宇宙级的时间
- **GCM 模式**：不仅加密数据，还验证数据是否被篡改过
- **随机 IV**：每次上锁时使用的"临时密码"，确保同样的数据每次加密结果都不同

### 🗝️ 什么是 Shamir 分片？
就像把一把钥匙掰成 10 片碎片，藏在不同的地方：

- **分片算法**：把一个秘密（比如密码）拆分成多个碎片
- **门限规则**：比如 7-of-10，表示至少需要 7 片碎片才能恢复完整密码
- **安全特性**：拿到 6 片碎片也无法推测出原始密码

### 🔢 什么是 IV（初始化向量）？
IV 就像保险箱的"临时密码"：

- **作用**：确保同样的数据每次加密结果都不同
- **特点**：随机生成，可以公开保存（不是秘密）
- **重要性**：解密时必须使用相同的 IV，否则无法打开保险箱

> 💡 **新手提示**：IV 不是秘密，但它是打开保险箱的必需"密码"！

## 🚀 快速开始

### 环境要求
- Java 11 或更高版本
- Maven 3.6+

### 构建项目
```bash
mvn clean package
```

### 运行演示
```bash
java -jar target/demo-1.0-SNAPSHOT.jar
```

## 📁 项目结构

```
AES-Shamir-Demo/
├── pom.xml                          # Maven 项目配置
├── README.md                        # 项目文档（本文件）
└── src/main/java/com/example/demo/
    └── Main.java                    # 演示主程序
```

## 📋 依赖说明

项目使用以下关键依赖：

- **com.codahale:shamir** (0.7.0)：提供 Shamir 秘密分享算法的 Java 实现
- **org.bouncycastle:bcprov-jdk15on** (1.70)：Bouncy Castle 加密库，**可选**（Java 9+ 已内置 AES-GCM 支持）

> **注意**：在 Java 9 及更高版本中，AES-GCM 加密算法已由标准库提供支持。如使用 Java 11+，可注释掉 Bouncy Castle 依赖项。

## 💻 核心代码

核心演示代码位于 [`src/main/java/com/example/demo/Main.java`](src/main/java/com/example/demo/Main.java)，包含完整的 AES-256-GCM 加密和 Shamir 门限分片实现。

项目配置文件：[`pom.xml`](pom.xml)

## 🎬 运行程序会看到什么？

程序运行时会一步步展示整个过程，就像电影一样：

### 📋 程序输出解释

1. **🔧 生成工具阶段**：
   ```
   === 步骤1：生成加密工具（AES密钥和IV） ===
   想象一下：我们要建一个保险箱，需要一把钥匙和一个开锁密码。
   ✅ AES密钥已生成: [一长串十六进制字符]
   ✅ 随机IV已生成: [24个十六进制字符]
   📦 要保护的宝物: 示例数字藏品内容
   ```

2. **🔒 加密阶段**：
   ```
   === 步骤2：使用AES-GCM加密宝物 ===
   🔒 加密完成！密文: [加密后的数据]
   📦 完整加密包: [IV+密文的组合数据]
   ```

3. **✂️ 分片阶段**：
   ```
   === 步骤3：将钥匙分成碎片（Shamir分片） ===
   钥匙碎片分布：
     🗝️  碎片#1: [碎片数据]
     🗝️  碎片#2: [碎片数据]
     ...
   ```

4. **🔧 重构阶段**：
   ```
   === 步骤4：收集碎片重组成钥匙 ===
   ✅ 获得碎片#3: [碎片数据]
   ✅ 获得碎片#7: [碎片数据]
   🔧 重构后的钥匙: [重构的密钥]
   🔍 钥匙验证: ✅ 正确！
   ```

5. **🔓 解密阶段**：
   ```
   === 步骤5：用重构钥匙打开保险箱 ===
   📤 提取的IV: [从存储数据中提取的IV]
   📤 提取的密文: [从存储数据中提取的密文]
   🎉 宝物取回成功: 示例数字藏品内容
   ```

6. **⚠️ 安全验证**：
   ```
   === 步骤6：演示错误的密码会导致失败 ===
   ❌ 预期的失败: Tag mismatch
   💡 这证明了IV的重要性！
   ```

## 🛠️ 代码里的重要参数

| 参数 | 值 | 说明 |
|------|-----|------|
| `KEY_SIZE` | 256 | AES 密钥长度，越长越安全 |
| `IV_SIZE` | 12 | IV 长度（96位），GCM 模式要求 |
| `TAG_SIZE` | 128 | 认证标签长度，用于验证数据完整性 |
| `TOTAL_SHARES` | 10 | 钥匙分成 10 片 |
| `REQUIRED_SHARES` | 7 | 最少需要 7 片才能重组成钥匙 |

## ❓ 常见问题解答

### Q: IV 到底存不存？
**A: 必须保存！** IV 不是秘密，但它是解密的必需"密码"。就像保险箱需要正确的密码才能打开。

### Q: 为什么每次加密结果都不同？
**A: 因为 IV 每次都随机生成。** 即使明文和密钥相同，IV 不同就会产生完全不同的密文。

### Q: 分片后安全吗？
**A: 非常安全！** Shamir 算法确保拿到少于 7 片碎片无法推测出原始钥匙。

### Q: 为什么用 "Tag mismatch" 错误？
**A: GCM 模式的安全特性。** 如果 IV 错误，解密过程会检测到数据被篡改，拒绝解密。

## 💼 这有什么实际用处？

### 🔒 企业级应用
- **银行系统**：多位高管共同控制重要操作
- **密码管理**：团队共享密码，但单个成员无法访问
- **数字签名**：多人共同授权重要文件

### 🌐 区块链应用
- **多签钱包**：需要多个人同意才能转账
- **去中心化身份**：分布式存储个人私钥
- **智能合约**：多人协作的去中心化应用

### 📱 个人应用
- **文件保险箱**：重要文件分片存储在多台设备
- **密码恢复**：朋友们帮你恢复忘记的密码
- **数字遗产**：去世后家人可以访问加密的遗产信息

## 🎉 总结

这个项目用**保险箱 + 分钥匙**的比喻，让复杂的密码学概念变得容易理解：

- 🔐 **AES-GCM** = 坚固的保险箱
- 🗝️ **Shamir 分片** = 把钥匙分成碎片
- 👥 **多人协作** = 一起保管和恢复秘密
- 🔢 **IV 保存** = 记住保险箱的密码

现在你不仅能运行代码，还能理解背后的安全原理了！🚀
