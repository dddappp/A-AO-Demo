-- <autogenerated>
--   This file was generated by dddappp code generator.
--   Any changes made to this file manually will be lost next time the file is regenerated.
-- </autogenerated>

local json = require("json")
local messaging = require("messaging")

-- AO 平台全局对象说明：
-- ao: AO 平台的全局发送对象，用于发送消息
-- Handlers: AO 平台的处理器注册对象，用于注册消息处理器

local proxy_contract_template = {}

-- 代理合约模板，用于创建与外部合约交互的代理
function proxy_contract_template.create(config)
    local proxy = {}

    -- 默认配置
    local default_config = {
        name = "GenericProxy",
        version = "1.0.0",

        -- 外部合约配置
        external_config = {
            target = nil,  -- 外部合约 Process ID
            action = nil,  -- 外部合约动作
            response_patterns = {
                success = nil,
                error = nil
            },
            timeout = 300,  -- 默认5分钟超时
            max_retries = 3   -- 最大重试次数
        },

        -- 响应适配器配置
        response_adapter = {},

        -- 补偿处理器配置
        compensation_handler = {},

        -- 自定义处理器
        custom_handlers = {}
    }

    -- 合并配置
    config = config or {}
    for k, v in pairs(default_config) do
        if config[k] == nil then
            config[k] = v
        elseif type(v) == "table" and type(config[k]) == "table" then
            for k2, v2 in pairs(v) do
                if config[k][k2] == nil then
                    config[k][k2] = v2
                end
            end
        end
    end

    proxy.config = config

    -- 待处理请求存储
    local pending_requests = {}

    -- 请求ID生成器（增强安全性）
    local request_id_counter = 0
    local used_request_ids = {}  -- 跟踪已使用的请求ID

    local function generate_request_id()
        request_id_counter = request_id_counter + 1
        local candidate_id

        -- 生成唯一ID，最多重试10次
        for i = 1, 10 do
            candidate_id = string.format("%s_%d_%d_%s",
                config.name,
                request_id_counter,
                os.time(),
                string.sub(tostring(math.random()), 3, 6)  -- 随机数增强唯一性
            )

            if not used_request_ids[candidate_id] then
                used_request_ids[candidate_id] = true
                return candidate_id
            end
        end

        -- 如果仍然冲突，使用更强的随机性
        candidate_id = string.format("%s_%d_%d_%s_%s",
            config.name,
            request_id_counter,
            os.time(),
            tostring(math.random(100000, 999999)),
            tostring(os.clock() * 1000000)
        )
        used_request_ids[candidate_id] = true
        return candidate_id
    end

    -- 🔑 关键优化：高效的pending请求管理
    -- 额外的索引结构，用于高级查询功能（避免for循环遍历）
    local saga_id_index = {}        -- saga_id -> {request_id -> true}  O(1)查找
    local external_target_index = {} -- external_target -> {request_id -> true} O(1)查找
    -- 🔑 新增：按业务参数索引，支持金额匹配搜索
    local amount_index = {}         -- amount -> {request_id -> true} 按金额索引
    local recipient_index = {}      -- recipient -> {request_id -> true} 按接收方索引
    local business_param_index = {} -- {amount, recipient} -> request_id 复合索引

    -- 注册请求到索引（存储时建立索引）
    local function register_request_to_indexes(request_id, request_info)
        -- 按saga_id索引 - O(1)操作
        if request_info.saga_id then
            saga_id_index[request_info.saga_id] = saga_id_index[request_info.saga_id] or {}
            saga_id_index[request_info.saga_id][request_id] = true
        end

        -- 按external_target索引 - O(1)操作
        if request_info.external_target then
            external_target_index[request_info.external_target] = external_target_index[request_info.external_target] or {}
            external_target_index[request_info.external_target][request_id] = true
        end

        -- 🔑 新增：按业务参数索引，支持金额匹配搜索
        if request_info.original_quantity then
            amount_index[request_info.original_quantity] = amount_index[request_info.original_quantity] or {}
            amount_index[request_info.original_quantity][request_id] = true
        end

        if request_info.original_recipient then
            recipient_index[request_info.original_recipient] = recipient_index[request_info.original_recipient] or {}
            recipient_index[request_info.original_recipient][request_id] = true
        end

        -- 复合索引：金额+接收方 -> request_id（唯一匹配）
        if request_info.original_quantity and request_info.original_recipient then
            local composite_key = request_info.original_quantity .. "|" .. request_info.original_recipient
            business_param_index[composite_key] = request_id
        end
    end

    -- 从索引中移除请求（清理时同步更新索引）
    local function remove_request_from_indexes(request_id, request_info)
        -- 从saga_id索引移除 - O(1)操作
        if request_info.saga_id and saga_id_index[request_info.saga_id] then
            saga_id_index[request_info.saga_id][request_id] = nil
            -- 如果该saga没有其他请求，清理索引
            if not next(saga_id_index[request_info.saga_id]) then
                saga_id_index[request_info.saga_id] = nil
            end
        end

        -- 从external_target索引移除 - O(1)操作
        if request_info.external_target and external_target_index[request_info.external_target] then
            external_target_index[request_info.external_target][request_id] = nil
            -- 如果该target没有其他请求，清理索引
            if not next(external_target_index[request_info.external_target]) then
                external_target_index[request_info.external_target] = nil
            end
        end

        -- 🔑 从业务参数索引移除
        if request_info.original_quantity and amount_index[request_info.original_quantity] then
            amount_index[request_info.original_quantity][request_id] = nil
            if not next(amount_index[request_info.original_quantity]) then
                amount_index[request_info.original_quantity] = nil
            end
        end

        if request_info.original_recipient and recipient_index[request_info.original_recipient] then
            recipient_index[request_info.original_recipient][request_id] = nil
            if not next(recipient_index[request_info.original_recipient]) then
                recipient_index[request_info.original_recipient] = nil
            end
        end

        -- 从复合索引移除
        if request_info.original_quantity and request_info.original_recipient then
            local composite_key = request_info.original_quantity .. "|" .. request_info.original_recipient
            if business_param_index[composite_key] == request_id then
                business_param_index[composite_key] = nil
            end
        end
    end

    -- 🔑 高效查询API：按saga_id查找所有相关请求 - O(1)时间复杂度
    function proxy.find_requests_by_saga_id(saga_id)
        return saga_id_index[saga_id] or {}
    end

    -- 🔑 高效查询API：按external_target查找所有相关请求 - O(1)时间复杂度
    function proxy.find_requests_by_external_target(target)
        return external_target_index[target] or {}
    end

    -- 🔑 关键API：按金额查找pending请求 - O(1)时间复杂度
    function proxy.find_requests_by_amount(amount)
        return amount_index[tostring(amount)] or {}
    end

    -- 🔑 关键API：按接收方查找pending请求 - O(1)时间复杂度
    function proxy.find_requests_by_recipient(recipient)
        return recipient_index[recipient] or {}
    end

    -- 🔑 核心API：通过金额+接收方精确匹配查找请求 - O(1)时间复杂度
    function proxy.find_request_by_business_params(quantity, recipient)
        if not quantity or not recipient then return nil end
        local composite_key = tostring(quantity) .. "|" .. recipient
        local request_id = business_param_index[composite_key]
        if request_id then
            return pending_requests[request_id]
        end
        return nil
    end

    -- 🔑 高效查询API：获取某个saga的所有pending请求详情 - O(k)时间复杂度，k为该saga的请求数
    function proxy.get_pending_requests_for_saga(saga_id)
        local request_ids = proxy.find_requests_by_saga_id(saga_id)
        local result = {}

        for request_id in pairs(request_ids) do
            local request_info = pending_requests[request_id]
            if request_info then
                result[request_id] = request_info
            end
        end

        return result
    end

    -- 🔑 高级功能：取消某个saga的所有pending请求
    function proxy.cancel_saga_requests(saga_id, reason)
        local request_ids = proxy.find_requests_by_saga_id(saga_id)
        local cancelled_count = 0

        for request_id in pairs(request_ids) do
            local request_info = pending_requests[request_id]
            if request_info then
                -- 发送取消通知
                local send_status, send_error = pcall(function()
                    ao.send({
                        Target = request_info.from,
                        Tags = {
                            Action = request_info.callback_action,
                            [messaging.X_TAGS.SAGA_ID] = request_info.saga_id,
                            ["X-Cancelled"] = "true"
                        },
                        Data = json.encode({
                            status = "cancelled",
                            reason = reason or "Saga cancelled",
                            saga_id = saga_id,
                            timestamp = os.time()
                        })
                    })
                end)

                if send_status then
                    cancelled_count = cancelled_count + 1
                    -- 清理请求和索引
                    remove_request_from_indexes(request_id, request_info)
                    pending_requests[request_id] = nil
                end
            end
        end

        print(string.format("[%s] Cancelled %d requests for saga: %s",
            config.name, cancelled_count, saga_id))
        return cancelled_count
    end

    -- 清理旧的已使用请求ID（防止内存泄漏）
    local function cleanup_used_request_ids()
        -- 简单实现：定期清理（可以优化为LRU缓存）
        if request_id_counter % 100 == 0 then
            used_request_ids = {}  -- 重置（在生产环境中应该更智能）
        end
    end

    -- 清理过期请求
    local function cleanup_expired_requests()
        local current_time = os.time()
        local to_remove = {}

        for request_id, request_info in pairs(pending_requests) do
            if current_time > request_info.timeout then
                table.insert(to_remove, request_id)
            end
        end

        for _, request_id in ipairs(to_remove) do
            local request_info = pending_requests[request_id]
            if request_info then
                -- 🔑 同步从索引中移除
                remove_request_from_indexes(request_id, request_info)
                pending_requests[request_id] = nil
            end
        end

        return #to_remove
    end

    -- 定期清理任务（每分钟执行一次）
    local last_cleanup = os.time()
    local function periodic_cleanup()
        local current_time = os.time()
        if current_time - last_cleanup > 60 then
            cleanup_expired_requests()
            last_cleanup = current_time
        end
    end

    -- 安全验证函数
    function proxy.validate_caller(msg)
        -- 默认允许所有调用者，子类可以重写此方法实现访问控制
        -- 示例实现：
        -- return msg.From == "AUTHORIZED_PROCESS_ID"
        return true
    end

    function proxy.validate_callback_action(action)
        -- 验证回调动作名称，防止代码注入
        if type(action) ~= "string" then
            return false
        end

        -- 只允许字母、数字、下划线和点号
        return action:match("^[A-Za-z_][A-Za-z0-9_.]*$") ~= nil
    end

    -- 核心代理调用处理器
    function proxy.handle_proxy_call(msg)
        periodic_cleanup()

        -- 安全验证：检查消息来源和权限
        if not proxy.validate_caller(msg) then
            ao.send({
                Target = msg.From,
                Tags = { Action = "ProxyError" },
                Data = json.encode({
                    error = "UNAUTHORIZED_ACCESS",
                    message = "Caller not authorized to use this proxy"
                })
            })
            return
        end

        local request_id = generate_request_id()
        cleanup_used_request_ids()  -- 定期清理已使用的请求ID
        local saga_id = msg.Tags[messaging.X_TAGS.SAGA_ID]
        local callback_action = msg.Tags["X-CallbackAction"]

        -- 验证必需参数
        if not saga_id then
            ao.send({
                Target = msg.From,
                Tags = { Action = "ProxyError" },
                Data = json.encode({
                    error = "MISSING_SAGA_ID",
                    message = "Proxy call must include X-SagaId tag"
                })
            })
            return
        end

        -- 验证 Saga ID 格式（防止注入攻击）
        if type(saga_id) ~= "string" or not saga_id:match("^%d+$") then
            ao.send({
                Target = msg.From,
                Tags = { Action = "ProxyError" },
                Data = json.encode({
                    error = "INVALID_SAGA_ID",
                    message = "Saga ID must be a valid number string"
                })
            })
            return
        end

        if not callback_action then
            ao.send({
                Target = msg.From,
                Tags = { Action = "ProxyError" },
                Data = json.encode({
                    error = "MISSING_CALLBACK_ACTION",
                    message = "Proxy call must include X-CallbackAction tag"
                })
            })
            return
        end

        -- 验证回调动作名称（防止代码注入）
        if not proxy.validate_callback_action(callback_action) then
            ao.send({
                Target = msg.From,
                Tags = { Action = "ProxyError" },
                Data = json.encode({
                    error = "INVALID_CALLBACK_ACTION",
                    message = "Callback action name contains invalid characters"
                })
            })
            return
        end

        -- 验证外部合约配置
        if not config.external_config.target then
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = callback_action,
                    [messaging.X_TAGS.SAGA_ID] = saga_id
                },
                Data = json.encode({
                    error = "EXTERNAL_CONTRACT_NOT_CONFIGURED",
                    message = "External contract target not configured"
                })
            })
            return
        end

        -- 记录请求映射（只存储必要的字段以节省内存）
        local request_info = {
            request_id = request_id,  -- 🔑 添加request_id便于后续处理
            saga_id = saga_id,
            callback_action = callback_action,
            -- 只存储必要的消息字段，避免存储完整消息对象
            from = msg.From,
            response_action = msg.Tags[messaging.X_TAGS.RESPONSE_ACTION],
            no_response_required = msg.Tags[messaging.X_TAGS.NO_RESPONSE_REQUIRED],
            timeout = os.time() + config.external_config.timeout,
            retry_count = 0,
            created_at = os.time(),
            external_target = config.external_config.target,
            external_action = config.external_config.action,
            -- 🔑 关键：存储业务参数用于验证（特别是金额）
            original_quantity = msg.Tags.Quantity,  -- 原始请求的转账金额
            original_recipient = msg.Tags.Recipient,  -- 原始请求的接收方
            original_sender = msg.Tags.Sender or msg.From  -- 原始请求的发送方
        }

        pending_requests[request_id] = request_info
        -- 🔑 同时注册到索引中，实现高效查询
        register_request_to_indexes(request_id, request_info)

        -- 准备发送给外部合约的消息
        local external_tags = {
            Action = config.external_config.action,
            ["X-RequestId"] = request_id
        }

        -- 复制业务相关的标签（排除 Saga 相关标签）
        for tag_name, tag_value in pairs(msg.Tags) do
            if not tag_name:match("^X%-Saga") and
               tag_name ~= "X-CallbackAction" and
               tag_name ~= messaging.X_TAGS.RESPONSE_ACTION and
               tag_name ~= messaging.X_TAGS.NO_RESPONSE_REQUIRED then
                external_tags[tag_name] = tag_value
            end
        end

        -- 发送请求到外部合约
        ao.send({
            Target = config.external_config.target,
            Tags = external_tags,
            Data = msg.Data
        })

        print(string.format("[%s] Proxy call initiated: request_id=%s, saga_id=%s, external_target=%s",
            config.name, request_id, saga_id, config.external_config.target))
    end

    -- 🔑 核心：外部合约响应处理器 - 支持多种查找方式
    function proxy.handle_external_response(msg)
        periodic_cleanup()

        -- 方式1：通过X-RequestId直接查找（最快，O(1)）
        local request_id = msg.Tags["X-RequestId"]
        local request_info = nil

        if request_id then
            -- 直接通过request_id查找
            request_info = pending_requests[request_id]
            if not request_info then
                print(string.format("[%s] Received response for unknown request: %s", config.name, request_id))
                return
            end
        else
            -- 🔑 方式2：通过业务参数匹配查找（当X-RequestId不可用时）
            print(string.format("[%s] X-RequestId not found, trying business parameter matching", config.name))

            -- 提取响应中的业务参数
            local response_quantity = msg.Tags.Quantity
            local response_recipient = msg.Tags.Recipient

            if response_quantity and response_recipient then
                -- 🔑 核心搜索逻辑：通过金额+接收方精确匹配
                request_info = proxy.find_request_by_business_params(response_quantity, response_recipient)

                if request_info then
                    print(string.format("[%s] Found matching request by business params: amount=%s, recipient=%s",
                        config.name, response_quantity, response_recipient))
                else
                    print(string.format("[%s] No matching request found for amount=%s, recipient=%s",
                        config.name, response_quantity, response_recipient))
                    return
                end
            else
                print(string.format("[%s] Cannot match response: missing quantity or recipient in response", config.name))
                return
            end
        end

        -- 🔑 关键验证：匹配转账金额和交易参数
        local validation_result = proxy.validate_transaction_match(msg, request_info)
        if not validation_result.is_valid then
            print(string.format("[%s] Transaction validation failed: %s", config.name, validation_result.error))
            -- 发送验证失败的回调，触发 Saga 补偿
            proxy.send_validation_error_callback(request_info, validation_result, request_id)
            return
        end

            -- 🔑 检查是否重复响应（幂等性保护）
        if proxy.is_duplicate_response(request_info, msg) then
            print(string.format("[%s] Ignoring duplicate response for request: %s",
                config.name, request_id or "matched_by_business_params"))
            return
        end

        -- 🔑 强制内存限制检查
        proxy.enforce_memory_limits()

        -- 🔑 核心：现在我们找到了对应的请求，获取其saga_id来继续Saga流程
        local saga_id = request_info.saga_id
        print(string.format("[%s] Matched response to saga: %s, continuing saga flow",
            config.name, saga_id))

        -- ⚠️ 关键设计决策：代理合约遵循"先缓存后commit"的模式
        -- 不立即处理响应，而是返回一个commit函数给调用方
        -- 只有在整个Saga事务确认成功后，才实际发送回调

        -- 缓存响应结果，等待Saga的最终确认
        local response_cache = {
            request_info = request_info,
            msg = msg,
            response_type = nil,  -- 将在下面判断
            is_success = false,
            validation_result = validation_result
        }

        -- 判断响应类型
        local response_type = msg.Tags.Action
        local is_success = false
        local is_error = false

        if config.external_config.response_patterns.success and
           response_type == config.external_config.response_patterns.success then
            is_success = true
            response_cache.response_type = "success"
            response_cache.is_success = true
        elseif config.external_config.response_patterns.error and
               response_type == config.external_config.response_patterns.error then
            is_error = true
            response_cache.response_type = "error"
            response_cache.is_success = false
        end

        -- 🔑 返回commit函数，而不是立即处理响应
        -- 这遵循了现有代码的"先缓存后commit"模式
        local commit = function()
            -- 只有在调用commit时，才实际发送Saga回调
            proxy.process_cached_response(response_cache)
        end

        -- 同时返回响应适配后的数据，便于调用方验证
        local adapted_response = proxy.adapt_response(msg, is_success and "success" or "error")

        return adapted_response, commit
    end

    -- 🔑 处理缓存的响应（只有在commit时调用）
    function proxy.process_cached_response(response_cache)
        local request_info = response_cache.request_info
        local msg = response_cache.msg
        local response_type = response_cache.response_type
        local is_success = response_cache.is_success
        local request_id = request_info.request_id  -- 从request_info中获取

        -- 转换为 Saga 回调格式
        local callback_data
        local status, adapted_response = pcall(function()
            if is_success then
                return proxy.adapt_response(msg, "success")
            elseif not is_success then
                return proxy.adapt_response(msg, "error")
            else
                -- 未知响应类型，记录但不处理
                print(string.format("[%s] Unknown response type: %s for request: %s",
                    config.name, msg.Tags.Action, request_id))
                return nil
            end
        end)

        if not status then
            -- 响应适配失败，当作错误处理
            print(string.format("[%s] Response adaptation failed: %s", config.name, adapted_response))
            callback_data = {
                error = {
                    status = "adaptation_failed",
                    error_code = "RESPONSE_ADAPTATION_ERROR",
                    error_message = "Internal error occurred while processing external response",
                    timestamp = os.time()
                }
            }
        elseif adapted_response then
            if is_success then
                callback_data = { result = adapted_response }
            else
                callback_data = { error = adapted_response }
            end
        else
            return -- 未知响应类型
        end

        -- 发送回调给 Saga
        local send_status, send_error = pcall(function()
            ao.send({
                Target = request_info.from,
                Tags = {
                    Action = request_info.callback_action,
                    [messaging.X_TAGS.SAGA_ID] = request_info.saga_id
                },
                Data = json.encode(callback_data)
            })
        end)

        if send_status then
            -- 🔑 回调发送成功，标记请求为已处理（幂等性保护）
            proxy.mark_request_processed(request_info)
            print(string.format("[%s] Successfully processed request and sent callback", config.name))
        else
            print(string.format("[%s] Failed to send callback: %s", config.name, send_error))
        end

        -- 清理请求记录
        if request_id then
            remove_request_from_indexes(request_id, request_info)
            pending_requests[request_id] = nil
        end

        print(string.format("[%s] Response processed: request_id=%s, saga_id=%s, type=%s",
            config.name, request_id, request_info.saga_id, response_type))
    end

    -- 🔑 关键方法：验证交易参数匹配
    function proxy.validate_transaction_match(msg, request_info)
        -- 对于转账操作，验证金额、接收方等关键参数
        if request_info.external_action == "Transfer" then
            return proxy.validate_transfer_match(msg, request_info)
        end

        -- 对于铸造操作，验证数量等参数
        if request_info.external_action == "Mint" then
            return proxy.validate_mint_match(msg, request_info)
        end

        -- 默认验证（金额匹配）
        return proxy.validate_basic_match(msg, request_info)
    end

    -- 转账交易的详细验证
    function proxy.validate_transfer_match(msg, request_info)
        local response_quantity = msg.Tags.Quantity
        local response_recipient = msg.Tags.Recipient
        local response_sender = msg.Tags.Sender

        -- 金额必须完全匹配
        if request_info.original_quantity and response_quantity then
            if tostring(request_info.original_quantity) ~= tostring(response_quantity) then
                return {
                    is_valid = false,
                    error = string.format("Amount mismatch: expected %s, got %s",
                        request_info.original_quantity, response_quantity),
                    error_code = "AMOUNT_MISMATCH",
                    expected_amount = request_info.original_quantity,
                    actual_amount = response_quantity
                }
            end
        end

        -- 接收方必须匹配（如果指定了）
        if request_info.original_recipient and response_recipient then
            if request_info.original_recipient ~= response_recipient then
                return {
                    is_valid = false,
                    error = string.format("Recipient mismatch: expected %s, got %s",
                        request_info.original_recipient, response_recipient),
                    error_code = "RECIPIENT_MISMATCH"
                }
            end
        end

        -- 对于 Debit-Notice，验证发送方
        if msg.Tags.Action == "Debit-Notice" and request_info.original_sender then
            -- Token 合约通常在 From 字段返回合约ID，所以这里主要验证业务逻辑
            print(string.format("[%s] Validating debit notice for amount: %s",
                config.name, response_quantity))
        end

        return { is_valid = true }
    end

    -- 铸造操作的验证
    function proxy.validate_mint_match(msg, request_info)
        local response_quantity = msg.Tags.Quantity
        local response_recipient = msg.Tags.Recipient

        -- 铸造数量必须匹配
        if request_info.original_quantity and response_quantity then
            if tostring(request_info.original_quantity) ~= tostring(response_quantity) then
                return {
                    is_valid = false,
                    error = string.format("Mint amount mismatch: expected %s, got %s",
                        request_info.original_quantity, response_quantity),
                    error_code = "MINT_AMOUNT_MISMATCH"
                }
            end
        end

        return { is_valid = true }
    end

    -- 基本参数验证
    function proxy.validate_basic_match(msg, request_info)
        -- 可以根据具体业务需求添加更多验证逻辑
        return { is_valid = true }
    end

    -- 发送验证失败的回调（触发 Saga 补偿）
    function proxy.send_validation_error_callback(request_info, validation_result, current_request_id)
        local callback_data = {
            error = {
                status = "validation_failed",
                error_code = validation_result.error_code or "VALIDATION_FAILED",
                error_message = validation_result.error,
                expected_amount = validation_result.expected_amount,
                actual_amount = validation_result.actual_amount,
                saga_id = request_info.saga_id,
                timestamp = os.time()
            }
        }

        -- 发送带有 X-SagaId 的错误回调，触发 Saga 补偿流程
        local send_status, send_error = pcall(function()
            ao.send({
                Target = request_info.from,
                Tags = {
                    Action = request_info.callback_action,
                    [messaging.X_TAGS.SAGA_ID] = request_info.saga_id,  -- 🔑 关键：包含 Saga ID
                    ["X-Validation-Failed"] = "true"  -- 标记这是验证失败
                },
                Data = json.encode(callback_data)
            })
        end)

        if not send_status then
            print(string.format("[%s] Failed to send validation error callback: %s",
                config.name, send_error))
        else
            print(string.format("[%s] Validation error callback sent for saga_id: %s",
                config.name, request_info.saga_id))
        end

        -- 清理失败的请求记录
        if current_request_id then
            local request_info = pending_requests[current_request_id]
            if request_info then
                -- 🔑 同步从索引中移除
                remove_request_from_indexes(current_request_id, request_info)
                pending_requests[current_request_id] = nil
            end
        end
    end

    -- 🔑 重复响应检测（幂等性保护）
    function proxy.is_duplicate_response(request_info, msg)
        -- 如果请求已经被标记为已处理，认为是重复响应
        if request_info.processed_at then
            return true
        end

        -- 检查是否有相同的业务操作已被处理
        -- 这里可以根据具体业务逻辑扩展更多重复检测规则
        return false
    end

    -- 🔑 标记请求为已处理
    function proxy.mark_request_processed(request_info)
        request_info.processed_at = os.time()
        request_info.status = "completed"
    end

    -- 🔑 内存限制强制执行
    local MAX_PENDING_REQUESTS = 10000
    local FORCE_CLEANUP_THRESHOLD = 8000

    function proxy.enforce_memory_limits()
        local current_count = 0
        for _ in pairs(pending_requests) do
            current_count = current_count + 1
        end

        if current_count > FORCE_CLEANUP_THRESHOLD then
            print(string.format("[%s] Memory limit threshold exceeded (%d/%d), performing cleanup",
                config.name, current_count, MAX_PENDING_REQUESTS))

            -- 先清理过期请求
            local cleaned = cleanup_expired_requests()
            print(string.format("[%s] Cleaned up %d expired requests", config.name, cleaned))

            -- 重新检查计数
            current_count = 0
            for _ in pairs(pending_requests) do
                current_count = current_count + 1
            end

            -- 如果仍然超限，清理最老的请求
            if current_count > MAX_PENDING_REQUESTS then
                local to_cleanup = math.floor(current_count - MAX_PENDING_REQUESTS * 0.9)
                proxy.cleanup_oldest_requests(to_cleanup)
                print(string.format("[%s] Force cleaned up %d oldest requests", config.name, to_cleanup))
            end
        end
    end

    -- 🔑 清理最老的请求（内存保护）
    function proxy.cleanup_oldest_requests(count)
        local requests_by_age = {}

        -- 收集所有请求和它们的创建时间
        for request_id, request_info in pairs(pending_requests) do
            table.insert(requests_by_age, {
                id = request_id,
                created_at = request_info.created_at or 0,
                info = request_info
            })
        end

        -- 按创建时间排序（最老的在前）
        table.sort(requests_by_age, function(a, b) return a.created_at < b.created_at end)

        -- 清理指定数量的最老请求
        local cleaned = 0
        for i = 1, math.min(count, #requests_by_age) do
            local req = requests_by_age[i]
            remove_request_from_indexes(req.id, req.info)
            pending_requests[req.id] = nil
            cleaned = cleaned + 1
        end

        return cleaned
    end

    -- ⚠️ 注意：转账验证已移至专用支付接收合约

    -- 响应适配器
    function proxy.adapt_response(msg, response_type)
        local adapter = config.response_adapter[response_type] or
                       config.response_adapter[msg.Tags.Action]

        if adapter then
            if type(adapter) == "function" then
                return adapter(msg)
            else
                return adapter
            end
        end

        -- 默认适配器
        if response_type == "success" then
            return {
                status = "success",
                data = json.decode(msg.Data or "{}"),
                tags = msg.Tags,
                timestamp = os.time()
            }
        elseif response_type == "error" then
            return {
                status = "error",
                error = msg.Tags.Error or msg.Tags.Message or "UNKNOWN_ERROR",
                data = json.decode(msg.Data or "{}"),
                tags = msg.Tags,
                timestamp = os.time()
            }
        end
    end

    -- 补偿处理器
    function proxy.handle_compensation(msg)
        local compensation_type = msg.Tags["X-CompensationType"]
        local saga_id = msg.Tags[messaging.X_TAGS.SAGA_ID]

        if not compensation_type or not config.compensation_handler[compensation_type] then
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "CompensationError",
                    [messaging.X_TAGS.SAGA_ID] = saga_id
                },
                Data = json.encode({
                    error = "UNSUPPORTED_COMPENSATION_TYPE",
                    compensation_type = compensation_type
                })
            })
            return
        end

        local compensation_data = json.decode(msg.Data or "{}")
        local compensation_request = config.compensation_handler[compensation_type](compensation_data)

        if compensation_request then
            -- 发送补偿请求到外部合约
            ao.send({
                Target = config.external_config.target,
                Tags = {
                    Action = compensation_request.action,
                    ["X-CompensationSagaId"] = saga_id
                },
                Data = json.encode(compensation_request.data or {})
            })

            -- 发送补偿成功确认
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "CompensationCompleted",
                    [messaging.X_TAGS.SAGA_ID] = saga_id
                },
                Data = json.encode({ status = "compensation_initiated" })
            })
        else
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "CompensationError",
                    [messaging.X_TAGS.SAGA_ID] = saga_id
                },
                Data = json.encode({
                    error = "COMPENSATION_REQUEST_FAILED",
                    compensation_type = compensation_type
                })
            })
        end
    end

    -- 状态查询处理器
    function proxy.handle_status_query(msg)
        local stats = {
            name = config.name,
            version = config.version,
            pending_requests_count = 0,
            expired_requests_cleaned = cleanup_expired_requests(),
            uptime = os.time() - (proxy.start_time or os.time())
        }

        for _ in pairs(pending_requests) do
            stats.pending_requests_count = stats.pending_requests_count + 1
        end

        ao.send({
            Target = msg.From,
            Tags = { Action = "ProxyStatus" },
            Data = json.encode(stats)
        })
    end

    -- 注册所有处理器
    function proxy.register_handlers()
        proxy.start_time = os.time()

        -- 代理调用处理器
        Handlers.add(
            config.name .. '_proxy_call',
            Handlers.utils.hasMatchingTag("Action", "ProxyCall"),
            function(msg) proxy.handle_proxy_call(msg) end
        )

        -- 外部响应处理器（通用处理器，处理所有消息）
        Handlers.add(
            config.name .. '_external_response',
            function(msg)
                -- 检查是否包含我们的请求ID
                if msg.Tags["X-RequestId"] then
                    proxy.handle_external_response(msg)
                end
            end
        )

        -- 补偿处理器
        Handlers.add(
            config.name .. '_compensation',
            Handlers.utils.hasMatchingTag("Action", "ProxyCompensation"),
            function(msg) proxy.handle_compensation(msg) end
        )

        -- 状态查询处理器
        Handlers.add(
            config.name .. '_status',
            Handlers.utils.hasMatchingTag("Action", "ProxyStatus"),
            function(msg) proxy.handle_status_query(msg) end
        )

        -- ⚠️ 注意：不再需要验证处理器，转账验证由专用支付接收合约处理

        -- 注册自定义处理器
        for handler_name, handler_config in pairs(config.custom_handlers) do
            Handlers.add(
                config.name .. '_' .. handler_name,
                handler_config.filter or function() return true end,
                handler_config.handler
            )
        end

        print(string.format("[%s] Proxy contract initialized with %d custom handlers",
            config.name, #config.custom_handlers))
    end

    -- 获取待处理请求（调试用）
    function proxy.get_pending_requests()
        return pending_requests
    end

    -- 强制清理所有请求（紧急情况用）
    function proxy.clear_all_requests()
        local count = 0
        for _ in pairs(pending_requests) do
            count = count + 1
        end
        pending_requests = {}
        return count
    end

    return proxy
end

return proxy_contract_template
