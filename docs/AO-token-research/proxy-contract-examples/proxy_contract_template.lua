-- <autogenerated>
--   This file was generated by dddappp code generator.
--   Any changes made to this file manually will be lost next time the file is regenerated.
-- </autogenerated>

local json = require("json")
local messaging = require("messaging")

-- AO å¹³å°å…¨å±€å¯¹è±¡è¯´æ˜ï¼š
-- ao: AO å¹³å°çš„å…¨å±€å‘é€å¯¹è±¡ï¼Œç”¨äºå‘é€æ¶ˆæ¯
-- Handlers: AO å¹³å°çš„å¤„ç†å™¨æ³¨å†Œå¯¹è±¡ï¼Œç”¨äºæ³¨å†Œæ¶ˆæ¯å¤„ç†å™¨

local proxy_contract_template = {}

-- ä»£ç†åˆçº¦æ¨¡æ¿ï¼Œç”¨äºåˆ›å»ºä¸å¤–éƒ¨åˆçº¦äº¤äº’çš„ä»£ç†
function proxy_contract_template.create(config)
    local proxy = {}

    -- é»˜è®¤é…ç½®
    local default_config = {
        name = "GenericProxy",
        version = "1.0.0",

        -- å¤–éƒ¨åˆçº¦é…ç½®
        external_config = {
            target = nil,  -- å¤–éƒ¨åˆçº¦ Process ID
            action = nil,  -- å¤–éƒ¨åˆçº¦åŠ¨ä½œ
            response_patterns = {
                success = nil,
                error = nil
            },
            timeout = 300,  -- é»˜è®¤5åˆ†é’Ÿè¶…æ—¶
            max_retries = 3   -- æœ€å¤§é‡è¯•æ¬¡æ•°
        },

        -- å“åº”é€‚é…å™¨é…ç½®
        response_adapter = {},

        -- è¡¥å¿å¤„ç†å™¨é…ç½®
        compensation_handler = {},

        -- è‡ªå®šä¹‰å¤„ç†å™¨
        custom_handlers = {}
    }

    -- åˆå¹¶é…ç½®
    config = config or {}
    for k, v in pairs(default_config) do
        if config[k] == nil then
            config[k] = v
        elseif type(v) == "table" and type(config[k]) == "table" then
            for k2, v2 in pairs(v) do
                if config[k][k2] == nil then
                    config[k][k2] = v2
                end
            end
        end
    end

    proxy.config = config

    -- å¾…å¤„ç†è¯·æ±‚å­˜å‚¨
    local pending_requests = {}

    -- è¯·æ±‚IDç”Ÿæˆå™¨ï¼ˆå¢å¼ºå®‰å…¨æ€§ï¼‰
    local request_id_counter = 0
    local used_request_ids = {}  -- è·Ÿè¸ªå·²ä½¿ç”¨çš„è¯·æ±‚ID

    local function generate_request_id()
        request_id_counter = request_id_counter + 1
        local candidate_id

        -- ç”Ÿæˆå”¯ä¸€IDï¼Œæœ€å¤šé‡è¯•10æ¬¡
        for i = 1, 10 do
            candidate_id = string.format("%s_%d_%d_%s",
                config.name,
                request_id_counter,
                os.time(),
                string.sub(tostring(math.random()), 3, 6)  -- éšæœºæ•°å¢å¼ºå”¯ä¸€æ€§
            )

            if not used_request_ids[candidate_id] then
                used_request_ids[candidate_id] = true
                return candidate_id
            end
        end

        -- å¦‚æœä»ç„¶å†²çªï¼Œä½¿ç”¨æ›´å¼ºçš„éšæœºæ€§
        candidate_id = string.format("%s_%d_%d_%s_%s",
            config.name,
            request_id_counter,
            os.time(),
            tostring(math.random(100000, 999999)),
            tostring(os.clock() * 1000000)
        )
        used_request_ids[candidate_id] = true
        return candidate_id
    end

    -- ğŸ”‘ å…³é”®ä¼˜åŒ–ï¼šé«˜æ•ˆçš„pendingè¯·æ±‚ç®¡ç†
    -- é¢å¤–çš„ç´¢å¼•ç»“æ„ï¼Œç”¨äºé«˜çº§æŸ¥è¯¢åŠŸèƒ½ï¼ˆé¿å…forå¾ªç¯éå†ï¼‰
    local saga_id_index = {}        -- saga_id -> {request_id -> true}  O(1)æŸ¥æ‰¾
    local external_target_index = {} -- external_target -> {request_id -> true} O(1)æŸ¥æ‰¾
    -- ğŸ”‘ æ–°å¢ï¼šæŒ‰ä¸šåŠ¡å‚æ•°ç´¢å¼•ï¼Œæ”¯æŒé‡‘é¢åŒ¹é…æœç´¢
    local amount_index = {}         -- amount -> {request_id -> true} æŒ‰é‡‘é¢ç´¢å¼•
    local recipient_index = {}      -- recipient -> {request_id -> true} æŒ‰æ¥æ”¶æ–¹ç´¢å¼•
    local business_param_index = {} -- {amount, recipient} -> request_id å¤åˆç´¢å¼•

    -- æ³¨å†Œè¯·æ±‚åˆ°ç´¢å¼•ï¼ˆå­˜å‚¨æ—¶å»ºç«‹ç´¢å¼•ï¼‰
    local function register_request_to_indexes(request_id, request_info)
        -- æŒ‰saga_idç´¢å¼• - O(1)æ“ä½œ
        if request_info.saga_id then
            saga_id_index[request_info.saga_id] = saga_id_index[request_info.saga_id] or {}
            saga_id_index[request_info.saga_id][request_id] = true
        end

        -- æŒ‰external_targetç´¢å¼• - O(1)æ“ä½œ
        if request_info.external_target then
            external_target_index[request_info.external_target] = external_target_index[request_info.external_target] or {}
            external_target_index[request_info.external_target][request_id] = true
        end

        -- ğŸ”‘ æ–°å¢ï¼šæŒ‰ä¸šåŠ¡å‚æ•°ç´¢å¼•ï¼Œæ”¯æŒé‡‘é¢åŒ¹é…æœç´¢
        if request_info.original_quantity then
            amount_index[request_info.original_quantity] = amount_index[request_info.original_quantity] or {}
            amount_index[request_info.original_quantity][request_id] = true
        end

        if request_info.original_recipient then
            recipient_index[request_info.original_recipient] = recipient_index[request_info.original_recipient] or {}
            recipient_index[request_info.original_recipient][request_id] = true
        end

        -- å¤åˆç´¢å¼•ï¼šé‡‘é¢+æ¥æ”¶æ–¹ -> request_idï¼ˆå”¯ä¸€åŒ¹é…ï¼‰
        if request_info.original_quantity and request_info.original_recipient then
            local composite_key = request_info.original_quantity .. "|" .. request_info.original_recipient
            business_param_index[composite_key] = request_id
        end
    end

    -- ä»ç´¢å¼•ä¸­ç§»é™¤è¯·æ±‚ï¼ˆæ¸…ç†æ—¶åŒæ­¥æ›´æ–°ç´¢å¼•ï¼‰
    local function remove_request_from_indexes(request_id, request_info)
        -- ä»saga_idç´¢å¼•ç§»é™¤ - O(1)æ“ä½œ
        if request_info.saga_id and saga_id_index[request_info.saga_id] then
            saga_id_index[request_info.saga_id][request_id] = nil
            -- å¦‚æœè¯¥sagaæ²¡æœ‰å…¶ä»–è¯·æ±‚ï¼Œæ¸…ç†ç´¢å¼•
            if not next(saga_id_index[request_info.saga_id]) then
                saga_id_index[request_info.saga_id] = nil
            end
        end

        -- ä»external_targetç´¢å¼•ç§»é™¤ - O(1)æ“ä½œ
        if request_info.external_target and external_target_index[request_info.external_target] then
            external_target_index[request_info.external_target][request_id] = nil
            -- å¦‚æœè¯¥targetæ²¡æœ‰å…¶ä»–è¯·æ±‚ï¼Œæ¸…ç†ç´¢å¼•
            if not next(external_target_index[request_info.external_target]) then
                external_target_index[request_info.external_target] = nil
            end
        end

        -- ğŸ”‘ ä»ä¸šåŠ¡å‚æ•°ç´¢å¼•ç§»é™¤
        if request_info.original_quantity and amount_index[request_info.original_quantity] then
            amount_index[request_info.original_quantity][request_id] = nil
            if not next(amount_index[request_info.original_quantity]) then
                amount_index[request_info.original_quantity] = nil
            end
        end

        if request_info.original_recipient and recipient_index[request_info.original_recipient] then
            recipient_index[request_info.original_recipient][request_id] = nil
            if not next(recipient_index[request_info.original_recipient]) then
                recipient_index[request_info.original_recipient] = nil
            end
        end

        -- ä»å¤åˆç´¢å¼•ç§»é™¤
        if request_info.original_quantity and request_info.original_recipient then
            local composite_key = request_info.original_quantity .. "|" .. request_info.original_recipient
            if business_param_index[composite_key] == request_id then
                business_param_index[composite_key] = nil
            end
        end
    end

    -- ğŸ”‘ é«˜æ•ˆæŸ¥è¯¢APIï¼šæŒ‰saga_idæŸ¥æ‰¾æ‰€æœ‰ç›¸å…³è¯·æ±‚ - O(1)æ—¶é—´å¤æ‚åº¦
    function proxy.find_requests_by_saga_id(saga_id)
        return saga_id_index[saga_id] or {}
    end

    -- ğŸ”‘ é«˜æ•ˆæŸ¥è¯¢APIï¼šæŒ‰external_targetæŸ¥æ‰¾æ‰€æœ‰ç›¸å…³è¯·æ±‚ - O(1)æ—¶é—´å¤æ‚åº¦
    function proxy.find_requests_by_external_target(target)
        return external_target_index[target] or {}
    end

    -- ğŸ”‘ å…³é”®APIï¼šæŒ‰é‡‘é¢æŸ¥æ‰¾pendingè¯·æ±‚ - O(1)æ—¶é—´å¤æ‚åº¦
    function proxy.find_requests_by_amount(amount)
        return amount_index[tostring(amount)] or {}
    end

    -- ğŸ”‘ å…³é”®APIï¼šæŒ‰æ¥æ”¶æ–¹æŸ¥æ‰¾pendingè¯·æ±‚ - O(1)æ—¶é—´å¤æ‚åº¦
    function proxy.find_requests_by_recipient(recipient)
        return recipient_index[recipient] or {}
    end

    -- ğŸ”‘ æ ¸å¿ƒAPIï¼šé€šè¿‡é‡‘é¢+æ¥æ”¶æ–¹ç²¾ç¡®åŒ¹é…æŸ¥æ‰¾è¯·æ±‚ - O(1)æ—¶é—´å¤æ‚åº¦
    function proxy.find_request_by_business_params(quantity, recipient)
        if not quantity or not recipient then return nil end
        local composite_key = tostring(quantity) .. "|" .. recipient
        local request_id = business_param_index[composite_key]
        if request_id then
            return pending_requests[request_id]
        end
        return nil
    end

    -- ğŸ”‘ é«˜æ•ˆæŸ¥è¯¢APIï¼šè·å–æŸä¸ªsagaçš„æ‰€æœ‰pendingè¯·æ±‚è¯¦æƒ… - O(k)æ—¶é—´å¤æ‚åº¦ï¼Œkä¸ºè¯¥sagaçš„è¯·æ±‚æ•°
    function proxy.get_pending_requests_for_saga(saga_id)
        local request_ids = proxy.find_requests_by_saga_id(saga_id)
        local result = {}

        for request_id in pairs(request_ids) do
            local request_info = pending_requests[request_id]
            if request_info then
                result[request_id] = request_info
            end
        end

        return result
    end

    -- ğŸ”‘ é«˜çº§åŠŸèƒ½ï¼šå–æ¶ˆæŸä¸ªsagaçš„æ‰€æœ‰pendingè¯·æ±‚
    function proxy.cancel_saga_requests(saga_id, reason)
        local request_ids = proxy.find_requests_by_saga_id(saga_id)
        local cancelled_count = 0

        for request_id in pairs(request_ids) do
            local request_info = pending_requests[request_id]
            if request_info then
                -- å‘é€å–æ¶ˆé€šçŸ¥
                local send_status, send_error = pcall(function()
                    ao.send({
                        Target = request_info.from,
                        Tags = {
                            Action = request_info.callback_action,
                            [messaging.X_TAGS.SAGA_ID] = request_info.saga_id,
                            ["X-Cancelled"] = "true"
                        },
                        Data = json.encode({
                            status = "cancelled",
                            reason = reason or "Saga cancelled",
                            saga_id = saga_id,
                            timestamp = os.time()
                        })
                    })
                end)

                if send_status then
                    cancelled_count = cancelled_count + 1
                    -- æ¸…ç†è¯·æ±‚å’Œç´¢å¼•
                    remove_request_from_indexes(request_id, request_info)
                    pending_requests[request_id] = nil
                end
            end
        end

        print(string.format("[%s] Cancelled %d requests for saga: %s",
            config.name, cancelled_count, saga_id))
        return cancelled_count
    end

    -- æ¸…ç†æ—§çš„å·²ä½¿ç”¨è¯·æ±‚IDï¼ˆé˜²æ­¢å†…å­˜æ³„æ¼ï¼‰
    local function cleanup_used_request_ids()
        -- ç®€å•å®ç°ï¼šå®šæœŸæ¸…ç†ï¼ˆå¯ä»¥ä¼˜åŒ–ä¸ºLRUç¼“å­˜ï¼‰
        if request_id_counter % 100 == 0 then
            used_request_ids = {}  -- é‡ç½®ï¼ˆåœ¨ç”Ÿäº§ç¯å¢ƒä¸­åº”è¯¥æ›´æ™ºèƒ½ï¼‰
        end
    end

    -- æ¸…ç†è¿‡æœŸè¯·æ±‚
    local function cleanup_expired_requests()
        local current_time = os.time()
        local to_remove = {}

        for request_id, request_info in pairs(pending_requests) do
            if current_time > request_info.timeout then
                table.insert(to_remove, request_id)
            end
        end

        for _, request_id in ipairs(to_remove) do
            local request_info = pending_requests[request_id]
            if request_info then
                -- ğŸ”‘ åŒæ­¥ä»ç´¢å¼•ä¸­ç§»é™¤
                remove_request_from_indexes(request_id, request_info)
                pending_requests[request_id] = nil
            end
        end

        return #to_remove
    end

    -- å®šæœŸæ¸…ç†ä»»åŠ¡ï¼ˆæ¯åˆ†é’Ÿæ‰§è¡Œä¸€æ¬¡ï¼‰
    local last_cleanup = os.time()
    local function periodic_cleanup()
        local current_time = os.time()
        if current_time - last_cleanup > 60 then
            cleanup_expired_requests()
            last_cleanup = current_time
        end
    end

    -- å®‰å…¨éªŒè¯å‡½æ•°
    function proxy.validate_caller(msg)
        -- é»˜è®¤å…è®¸æ‰€æœ‰è°ƒç”¨è€…ï¼Œå­ç±»å¯ä»¥é‡å†™æ­¤æ–¹æ³•å®ç°è®¿é—®æ§åˆ¶
        -- ç¤ºä¾‹å®ç°ï¼š
        -- return msg.From == "AUTHORIZED_PROCESS_ID"
        return true
    end

    function proxy.validate_callback_action(action)
        -- éªŒè¯å›è°ƒåŠ¨ä½œåç§°ï¼Œé˜²æ­¢ä»£ç æ³¨å…¥
        if type(action) ~= "string" then
            return false
        end

        -- åªå…è®¸å­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿å’Œç‚¹å·
        return action:match("^[A-Za-z_][A-Za-z0-9_.]*$") ~= nil
    end

    -- æ ¸å¿ƒä»£ç†è°ƒç”¨å¤„ç†å™¨
    function proxy.handle_proxy_call(msg)
        periodic_cleanup()

        -- å®‰å…¨éªŒè¯ï¼šæ£€æŸ¥æ¶ˆæ¯æ¥æºå’Œæƒé™
        if not proxy.validate_caller(msg) then
            ao.send({
                Target = msg.From,
                Tags = { Action = "ProxyError" },
                Data = json.encode({
                    error = "UNAUTHORIZED_ACCESS",
                    message = "Caller not authorized to use this proxy"
                })
            })
            return
        end

        local request_id = generate_request_id()
        cleanup_used_request_ids()  -- å®šæœŸæ¸…ç†å·²ä½¿ç”¨çš„è¯·æ±‚ID
        local saga_id = msg.Tags[messaging.X_TAGS.SAGA_ID]
        local callback_action = msg.Tags["X-CallbackAction"]

        -- éªŒè¯å¿…éœ€å‚æ•°
        if not saga_id then
            ao.send({
                Target = msg.From,
                Tags = { Action = "ProxyError" },
                Data = json.encode({
                    error = "MISSING_SAGA_ID",
                    message = "Proxy call must include X-SagaId tag"
                })
            })
            return
        end

        -- éªŒè¯ Saga ID æ ¼å¼ï¼ˆé˜²æ­¢æ³¨å…¥æ”»å‡»ï¼‰
        if type(saga_id) ~= "string" or not saga_id:match("^%d+$") then
            ao.send({
                Target = msg.From,
                Tags = { Action = "ProxyError" },
                Data = json.encode({
                    error = "INVALID_SAGA_ID",
                    message = "Saga ID must be a valid number string"
                })
            })
            return
        end

        if not callback_action then
            ao.send({
                Target = msg.From,
                Tags = { Action = "ProxyError" },
                Data = json.encode({
                    error = "MISSING_CALLBACK_ACTION",
                    message = "Proxy call must include X-CallbackAction tag"
                })
            })
            return
        end

        -- éªŒè¯å›è°ƒåŠ¨ä½œåç§°ï¼ˆé˜²æ­¢ä»£ç æ³¨å…¥ï¼‰
        if not proxy.validate_callback_action(callback_action) then
            ao.send({
                Target = msg.From,
                Tags = { Action = "ProxyError" },
                Data = json.encode({
                    error = "INVALID_CALLBACK_ACTION",
                    message = "Callback action name contains invalid characters"
                })
            })
            return
        end

        -- éªŒè¯å¤–éƒ¨åˆçº¦é…ç½®
        if not config.external_config.target then
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = callback_action,
                    [messaging.X_TAGS.SAGA_ID] = saga_id
                },
                Data = json.encode({
                    error = "EXTERNAL_CONTRACT_NOT_CONFIGURED",
                    message = "External contract target not configured"
                })
            })
            return
        end

        -- è®°å½•è¯·æ±‚æ˜ å°„ï¼ˆåªå­˜å‚¨å¿…è¦çš„å­—æ®µä»¥èŠ‚çœå†…å­˜ï¼‰
        local request_info = {
            request_id = request_id,  -- ğŸ”‘ æ·»åŠ request_idä¾¿äºåç»­å¤„ç†
            saga_id = saga_id,
            callback_action = callback_action,
            -- åªå­˜å‚¨å¿…è¦çš„æ¶ˆæ¯å­—æ®µï¼Œé¿å…å­˜å‚¨å®Œæ•´æ¶ˆæ¯å¯¹è±¡
            from = msg.From,
            response_action = msg.Tags[messaging.X_TAGS.RESPONSE_ACTION],
            no_response_required = msg.Tags[messaging.X_TAGS.NO_RESPONSE_REQUIRED],
            timeout = os.time() + config.external_config.timeout,
            retry_count = 0,
            created_at = os.time(),
            external_target = config.external_config.target,
            external_action = config.external_config.action,
            -- ğŸ”‘ å…³é”®ï¼šå­˜å‚¨ä¸šåŠ¡å‚æ•°ç”¨äºéªŒè¯ï¼ˆç‰¹åˆ«æ˜¯é‡‘é¢ï¼‰
            original_quantity = msg.Tags.Quantity,  -- åŸå§‹è¯·æ±‚çš„è½¬è´¦é‡‘é¢
            original_recipient = msg.Tags.Recipient,  -- åŸå§‹è¯·æ±‚çš„æ¥æ”¶æ–¹
            original_sender = msg.Tags.Sender or msg.From  -- åŸå§‹è¯·æ±‚çš„å‘é€æ–¹
        }

        pending_requests[request_id] = request_info
        -- ğŸ”‘ åŒæ—¶æ³¨å†Œåˆ°ç´¢å¼•ä¸­ï¼Œå®ç°é«˜æ•ˆæŸ¥è¯¢
        register_request_to_indexes(request_id, request_info)

        -- å‡†å¤‡å‘é€ç»™å¤–éƒ¨åˆçº¦çš„æ¶ˆæ¯
        local external_tags = {
            Action = config.external_config.action,
            ["X-RequestId"] = request_id
        }

        -- å¤åˆ¶ä¸šåŠ¡ç›¸å…³çš„æ ‡ç­¾ï¼ˆæ’é™¤ Saga ç›¸å…³æ ‡ç­¾ï¼‰
        for tag_name, tag_value in pairs(msg.Tags) do
            if not tag_name:match("^X%-Saga") and
               tag_name ~= "X-CallbackAction" and
               tag_name ~= messaging.X_TAGS.RESPONSE_ACTION and
               tag_name ~= messaging.X_TAGS.NO_RESPONSE_REQUIRED then
                external_tags[tag_name] = tag_value
            end
        end

        -- å‘é€è¯·æ±‚åˆ°å¤–éƒ¨åˆçº¦
        ao.send({
            Target = config.external_config.target,
            Tags = external_tags,
            Data = msg.Data
        })

        print(string.format("[%s] Proxy call initiated: request_id=%s, saga_id=%s, external_target=%s",
            config.name, request_id, saga_id, config.external_config.target))
    end

    -- ğŸ”‘ æ ¸å¿ƒï¼šå¤–éƒ¨åˆçº¦å“åº”å¤„ç†å™¨ - æ”¯æŒå¤šç§æŸ¥æ‰¾æ–¹å¼
    function proxy.handle_external_response(msg)
        periodic_cleanup()

        -- æ–¹å¼1ï¼šé€šè¿‡X-RequestIdç›´æ¥æŸ¥æ‰¾ï¼ˆæœ€å¿«ï¼ŒO(1)ï¼‰
        local request_id = msg.Tags["X-RequestId"]
        local request_info = nil

        if request_id then
            -- ç›´æ¥é€šè¿‡request_idæŸ¥æ‰¾
            request_info = pending_requests[request_id]
            if not request_info then
                print(string.format("[%s] Received response for unknown request: %s", config.name, request_id))
                return
            end
        else
            -- ğŸ”‘ æ–¹å¼2ï¼šé€šè¿‡ä¸šåŠ¡å‚æ•°åŒ¹é…æŸ¥æ‰¾ï¼ˆå½“X-RequestIdä¸å¯ç”¨æ—¶ï¼‰
            print(string.format("[%s] X-RequestId not found, trying business parameter matching", config.name))

            -- æå–å“åº”ä¸­çš„ä¸šåŠ¡å‚æ•°
            local response_quantity = msg.Tags.Quantity
            local response_recipient = msg.Tags.Recipient

            if response_quantity and response_recipient then
                -- ğŸ”‘ æ ¸å¿ƒæœç´¢é€»è¾‘ï¼šé€šè¿‡é‡‘é¢+æ¥æ”¶æ–¹ç²¾ç¡®åŒ¹é…
                request_info = proxy.find_request_by_business_params(response_quantity, response_recipient)

                if request_info then
                    print(string.format("[%s] Found matching request by business params: amount=%s, recipient=%s",
                        config.name, response_quantity, response_recipient))
                else
                    print(string.format("[%s] No matching request found for amount=%s, recipient=%s",
                        config.name, response_quantity, response_recipient))
                    return
                end
            else
                print(string.format("[%s] Cannot match response: missing quantity or recipient in response", config.name))
                return
            end
        end

        -- ğŸ”‘ å…³é”®éªŒè¯ï¼šåŒ¹é…è½¬è´¦é‡‘é¢å’Œäº¤æ˜“å‚æ•°
        local validation_result = proxy.validate_transaction_match(msg, request_info)
        if not validation_result.is_valid then
            print(string.format("[%s] Transaction validation failed: %s", config.name, validation_result.error))
            -- å‘é€éªŒè¯å¤±è´¥çš„å›è°ƒï¼Œè§¦å‘ Saga è¡¥å¿
            proxy.send_validation_error_callback(request_info, validation_result, request_id)
            return
        end

            -- ğŸ”‘ æ£€æŸ¥æ˜¯å¦é‡å¤å“åº”ï¼ˆå¹‚ç­‰æ€§ä¿æŠ¤ï¼‰
        if proxy.is_duplicate_response(request_info, msg) then
            print(string.format("[%s] Ignoring duplicate response for request: %s",
                config.name, request_id or "matched_by_business_params"))
            return
        end

        -- ğŸ”‘ å¼ºåˆ¶å†…å­˜é™åˆ¶æ£€æŸ¥
        proxy.enforce_memory_limits()

        -- ğŸ”‘ æ ¸å¿ƒï¼šç°åœ¨æˆ‘ä»¬æ‰¾åˆ°äº†å¯¹åº”çš„è¯·æ±‚ï¼Œè·å–å…¶saga_idæ¥ç»§ç»­Sagaæµç¨‹
        local saga_id = request_info.saga_id
        print(string.format("[%s] Matched response to saga: %s, continuing saga flow",
            config.name, saga_id))

        -- âš ï¸ å…³é”®è®¾è®¡å†³ç­–ï¼šä»£ç†åˆçº¦éµå¾ª"å…ˆç¼“å­˜åcommit"çš„æ¨¡å¼
        -- ä¸ç«‹å³å¤„ç†å“åº”ï¼Œè€Œæ˜¯è¿”å›ä¸€ä¸ªcommitå‡½æ•°ç»™è°ƒç”¨æ–¹
        -- åªæœ‰åœ¨æ•´ä¸ªSagaäº‹åŠ¡ç¡®è®¤æˆåŠŸåï¼Œæ‰å®é™…å‘é€å›è°ƒ

        -- ç¼“å­˜å“åº”ç»“æœï¼Œç­‰å¾…Sagaçš„æœ€ç»ˆç¡®è®¤
        local response_cache = {
            request_info = request_info,
            msg = msg,
            response_type = nil,  -- å°†åœ¨ä¸‹é¢åˆ¤æ–­
            is_success = false,
            validation_result = validation_result
        }

        -- åˆ¤æ–­å“åº”ç±»å‹
        local response_type = msg.Tags.Action
        local is_success = false
        local is_error = false

        if config.external_config.response_patterns.success and
           response_type == config.external_config.response_patterns.success then
            is_success = true
            response_cache.response_type = "success"
            response_cache.is_success = true
        elseif config.external_config.response_patterns.error and
               response_type == config.external_config.response_patterns.error then
            is_error = true
            response_cache.response_type = "error"
            response_cache.is_success = false
        end

        -- ğŸ”‘ è¿”å›commitå‡½æ•°ï¼Œè€Œä¸æ˜¯ç«‹å³å¤„ç†å“åº”
        -- è¿™éµå¾ªäº†ç°æœ‰ä»£ç çš„"å…ˆç¼“å­˜åcommit"æ¨¡å¼
        local commit = function()
            -- åªæœ‰åœ¨è°ƒç”¨commitæ—¶ï¼Œæ‰å®é™…å‘é€Sagaå›è°ƒ
            proxy.process_cached_response(response_cache)
        end

        -- åŒæ—¶è¿”å›å“åº”é€‚é…åçš„æ•°æ®ï¼Œä¾¿äºè°ƒç”¨æ–¹éªŒè¯
        local adapted_response = proxy.adapt_response(msg, is_success and "success" or "error")

        return adapted_response, commit
    end

    -- ğŸ”‘ å¤„ç†ç¼“å­˜çš„å“åº”ï¼ˆåªæœ‰åœ¨commitæ—¶è°ƒç”¨ï¼‰
    function proxy.process_cached_response(response_cache)
        local request_info = response_cache.request_info
        local msg = response_cache.msg
        local response_type = response_cache.response_type
        local is_success = response_cache.is_success
        local request_id = request_info.request_id  -- ä»request_infoä¸­è·å–

        -- è½¬æ¢ä¸º Saga å›è°ƒæ ¼å¼
        local callback_data
        local status, adapted_response = pcall(function()
            if is_success then
                return proxy.adapt_response(msg, "success")
            elseif not is_success then
                return proxy.adapt_response(msg, "error")
            else
                -- æœªçŸ¥å“åº”ç±»å‹ï¼Œè®°å½•ä½†ä¸å¤„ç†
                print(string.format("[%s] Unknown response type: %s for request: %s",
                    config.name, msg.Tags.Action, request_id))
                return nil
            end
        end)

        if not status then
            -- å“åº”é€‚é…å¤±è´¥ï¼Œå½“ä½œé”™è¯¯å¤„ç†
            print(string.format("[%s] Response adaptation failed: %s", config.name, adapted_response))
            callback_data = {
                error = {
                    status = "adaptation_failed",
                    error_code = "RESPONSE_ADAPTATION_ERROR",
                    error_message = "Internal error occurred while processing external response",
                    timestamp = os.time()
                }
            }
        elseif adapted_response then
            if is_success then
                callback_data = { result = adapted_response }
            else
                callback_data = { error = adapted_response }
            end
        else
            return -- æœªçŸ¥å“åº”ç±»å‹
        end

        -- å‘é€å›è°ƒç»™ Saga
        local send_status, send_error = pcall(function()
            ao.send({
                Target = request_info.from,
                Tags = {
                    Action = request_info.callback_action,
                    [messaging.X_TAGS.SAGA_ID] = request_info.saga_id
                },
                Data = json.encode(callback_data)
            })
        end)

        if send_status then
            -- ğŸ”‘ å›è°ƒå‘é€æˆåŠŸï¼Œæ ‡è®°è¯·æ±‚ä¸ºå·²å¤„ç†ï¼ˆå¹‚ç­‰æ€§ä¿æŠ¤ï¼‰
            proxy.mark_request_processed(request_info)
            print(string.format("[%s] Successfully processed request and sent callback", config.name))
        else
            print(string.format("[%s] Failed to send callback: %s", config.name, send_error))
        end

        -- æ¸…ç†è¯·æ±‚è®°å½•
        if request_id then
            remove_request_from_indexes(request_id, request_info)
            pending_requests[request_id] = nil
        end

        print(string.format("[%s] Response processed: request_id=%s, saga_id=%s, type=%s",
            config.name, request_id, request_info.saga_id, response_type))
    end

    -- ğŸ”‘ å…³é”®æ–¹æ³•ï¼šéªŒè¯äº¤æ˜“å‚æ•°åŒ¹é…
    function proxy.validate_transaction_match(msg, request_info)
        -- å¯¹äºè½¬è´¦æ“ä½œï¼ŒéªŒè¯é‡‘é¢ã€æ¥æ”¶æ–¹ç­‰å…³é”®å‚æ•°
        if request_info.external_action == "Transfer" then
            return proxy.validate_transfer_match(msg, request_info)
        end

        -- å¯¹äºé“¸é€ æ“ä½œï¼ŒéªŒè¯æ•°é‡ç­‰å‚æ•°
        if request_info.external_action == "Mint" then
            return proxy.validate_mint_match(msg, request_info)
        end

        -- é»˜è®¤éªŒè¯ï¼ˆé‡‘é¢åŒ¹é…ï¼‰
        return proxy.validate_basic_match(msg, request_info)
    end

    -- è½¬è´¦äº¤æ˜“çš„è¯¦ç»†éªŒè¯
    function proxy.validate_transfer_match(msg, request_info)
        local response_quantity = msg.Tags.Quantity
        local response_recipient = msg.Tags.Recipient
        local response_sender = msg.Tags.Sender

        -- é‡‘é¢å¿…é¡»å®Œå…¨åŒ¹é…
        if request_info.original_quantity and response_quantity then
            if tostring(request_info.original_quantity) ~= tostring(response_quantity) then
                return {
                    is_valid = false,
                    error = string.format("Amount mismatch: expected %s, got %s",
                        request_info.original_quantity, response_quantity),
                    error_code = "AMOUNT_MISMATCH",
                    expected_amount = request_info.original_quantity,
                    actual_amount = response_quantity
                }
            end
        end

        -- æ¥æ”¶æ–¹å¿…é¡»åŒ¹é…ï¼ˆå¦‚æœæŒ‡å®šäº†ï¼‰
        if request_info.original_recipient and response_recipient then
            if request_info.original_recipient ~= response_recipient then
                return {
                    is_valid = false,
                    error = string.format("Recipient mismatch: expected %s, got %s",
                        request_info.original_recipient, response_recipient),
                    error_code = "RECIPIENT_MISMATCH"
                }
            end
        end

        -- å¯¹äº Debit-Noticeï¼ŒéªŒè¯å‘é€æ–¹
        if msg.Tags.Action == "Debit-Notice" and request_info.original_sender then
            -- Token åˆçº¦é€šå¸¸åœ¨ From å­—æ®µè¿”å›åˆçº¦IDï¼Œæ‰€ä»¥è¿™é‡Œä¸»è¦éªŒè¯ä¸šåŠ¡é€»è¾‘
            print(string.format("[%s] Validating debit notice for amount: %s",
                config.name, response_quantity))
        end

        return { is_valid = true }
    end

    -- é“¸é€ æ“ä½œçš„éªŒè¯
    function proxy.validate_mint_match(msg, request_info)
        local response_quantity = msg.Tags.Quantity
        local response_recipient = msg.Tags.Recipient

        -- é“¸é€ æ•°é‡å¿…é¡»åŒ¹é…
        if request_info.original_quantity and response_quantity then
            if tostring(request_info.original_quantity) ~= tostring(response_quantity) then
                return {
                    is_valid = false,
                    error = string.format("Mint amount mismatch: expected %s, got %s",
                        request_info.original_quantity, response_quantity),
                    error_code = "MINT_AMOUNT_MISMATCH"
                }
            end
        end

        return { is_valid = true }
    end

    -- åŸºæœ¬å‚æ•°éªŒè¯
    function proxy.validate_basic_match(msg, request_info)
        -- å¯ä»¥æ ¹æ®å…·ä½“ä¸šåŠ¡éœ€æ±‚æ·»åŠ æ›´å¤šéªŒè¯é€»è¾‘
        return { is_valid = true }
    end

    -- å‘é€éªŒè¯å¤±è´¥çš„å›è°ƒï¼ˆè§¦å‘ Saga è¡¥å¿ï¼‰
    function proxy.send_validation_error_callback(request_info, validation_result, current_request_id)
        local callback_data = {
            error = {
                status = "validation_failed",
                error_code = validation_result.error_code or "VALIDATION_FAILED",
                error_message = validation_result.error,
                expected_amount = validation_result.expected_amount,
                actual_amount = validation_result.actual_amount,
                saga_id = request_info.saga_id,
                timestamp = os.time()
            }
        }

        -- å‘é€å¸¦æœ‰ X-SagaId çš„é”™è¯¯å›è°ƒï¼Œè§¦å‘ Saga è¡¥å¿æµç¨‹
        local send_status, send_error = pcall(function()
            ao.send({
                Target = request_info.from,
                Tags = {
                    Action = request_info.callback_action,
                    [messaging.X_TAGS.SAGA_ID] = request_info.saga_id,  -- ğŸ”‘ å…³é”®ï¼šåŒ…å« Saga ID
                    ["X-Validation-Failed"] = "true"  -- æ ‡è®°è¿™æ˜¯éªŒè¯å¤±è´¥
                },
                Data = json.encode(callback_data)
            })
        end)

        if not send_status then
            print(string.format("[%s] Failed to send validation error callback: %s",
                config.name, send_error))
        else
            print(string.format("[%s] Validation error callback sent for saga_id: %s",
                config.name, request_info.saga_id))
        end

        -- æ¸…ç†å¤±è´¥çš„è¯·æ±‚è®°å½•
        if current_request_id then
            local request_info = pending_requests[current_request_id]
            if request_info then
                -- ğŸ”‘ åŒæ­¥ä»ç´¢å¼•ä¸­ç§»é™¤
                remove_request_from_indexes(current_request_id, request_info)
                pending_requests[current_request_id] = nil
            end
        end
    end

    -- ğŸ”‘ é‡å¤å“åº”æ£€æµ‹ï¼ˆå¹‚ç­‰æ€§ä¿æŠ¤ï¼‰
    function proxy.is_duplicate_response(request_info, msg)
        -- å¦‚æœè¯·æ±‚å·²ç»è¢«æ ‡è®°ä¸ºå·²å¤„ç†ï¼Œè®¤ä¸ºæ˜¯é‡å¤å“åº”
        if request_info.processed_at then
            return true
        end

        -- æ£€æŸ¥æ˜¯å¦æœ‰ç›¸åŒçš„ä¸šåŠ¡æ“ä½œå·²è¢«å¤„ç†
        -- è¿™é‡Œå¯ä»¥æ ¹æ®å…·ä½“ä¸šåŠ¡é€»è¾‘æ‰©å±•æ›´å¤šé‡å¤æ£€æµ‹è§„åˆ™
        return false
    end

    -- ğŸ”‘ æ ‡è®°è¯·æ±‚ä¸ºå·²å¤„ç†
    function proxy.mark_request_processed(request_info)
        request_info.processed_at = os.time()
        request_info.status = "completed"
    end

    -- ğŸ”‘ å†…å­˜é™åˆ¶å¼ºåˆ¶æ‰§è¡Œ
    local MAX_PENDING_REQUESTS = 10000
    local FORCE_CLEANUP_THRESHOLD = 8000

    function proxy.enforce_memory_limits()
        local current_count = 0
        for _ in pairs(pending_requests) do
            current_count = current_count + 1
        end

        if current_count > FORCE_CLEANUP_THRESHOLD then
            print(string.format("[%s] Memory limit threshold exceeded (%d/%d), performing cleanup",
                config.name, current_count, MAX_PENDING_REQUESTS))

            -- å…ˆæ¸…ç†è¿‡æœŸè¯·æ±‚
            local cleaned = cleanup_expired_requests()
            print(string.format("[%s] Cleaned up %d expired requests", config.name, cleaned))

            -- é‡æ–°æ£€æŸ¥è®¡æ•°
            current_count = 0
            for _ in pairs(pending_requests) do
                current_count = current_count + 1
            end

            -- å¦‚æœä»ç„¶è¶…é™ï¼Œæ¸…ç†æœ€è€çš„è¯·æ±‚
            if current_count > MAX_PENDING_REQUESTS then
                local to_cleanup = math.floor(current_count - MAX_PENDING_REQUESTS * 0.9)
                proxy.cleanup_oldest_requests(to_cleanup)
                print(string.format("[%s] Force cleaned up %d oldest requests", config.name, to_cleanup))
            end
        end
    end

    -- ğŸ”‘ æ¸…ç†æœ€è€çš„è¯·æ±‚ï¼ˆå†…å­˜ä¿æŠ¤ï¼‰
    function proxy.cleanup_oldest_requests(count)
        local requests_by_age = {}

        -- æ”¶é›†æ‰€æœ‰è¯·æ±‚å’Œå®ƒä»¬çš„åˆ›å»ºæ—¶é—´
        for request_id, request_info in pairs(pending_requests) do
            table.insert(requests_by_age, {
                id = request_id,
                created_at = request_info.created_at or 0,
                info = request_info
            })
        end

        -- æŒ‰åˆ›å»ºæ—¶é—´æ’åºï¼ˆæœ€è€çš„åœ¨å‰ï¼‰
        table.sort(requests_by_age, function(a, b) return a.created_at < b.created_at end)

        -- æ¸…ç†æŒ‡å®šæ•°é‡çš„æœ€è€è¯·æ±‚
        local cleaned = 0
        for i = 1, math.min(count, #requests_by_age) do
            local req = requests_by_age[i]
            remove_request_from_indexes(req.id, req.info)
            pending_requests[req.id] = nil
            cleaned = cleaned + 1
        end

        return cleaned
    end

    -- âš ï¸ æ³¨æ„ï¼šè½¬è´¦éªŒè¯å·²ç§»è‡³ä¸“ç”¨æ”¯ä»˜æ¥æ”¶åˆçº¦

    -- å“åº”é€‚é…å™¨
    function proxy.adapt_response(msg, response_type)
        local adapter = config.response_adapter[response_type] or
                       config.response_adapter[msg.Tags.Action]

        if adapter then
            if type(adapter) == "function" then
                return adapter(msg)
            else
                return adapter
            end
        end

        -- é»˜è®¤é€‚é…å™¨
        if response_type == "success" then
            return {
                status = "success",
                data = json.decode(msg.Data or "{}"),
                tags = msg.Tags,
                timestamp = os.time()
            }
        elseif response_type == "error" then
            return {
                status = "error",
                error = msg.Tags.Error or msg.Tags.Message or "UNKNOWN_ERROR",
                data = json.decode(msg.Data or "{}"),
                tags = msg.Tags,
                timestamp = os.time()
            }
        end
    end

    -- è¡¥å¿å¤„ç†å™¨
    function proxy.handle_compensation(msg)
        local compensation_type = msg.Tags["X-CompensationType"]
        local saga_id = msg.Tags[messaging.X_TAGS.SAGA_ID]

        if not compensation_type or not config.compensation_handler[compensation_type] then
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "CompensationError",
                    [messaging.X_TAGS.SAGA_ID] = saga_id
                },
                Data = json.encode({
                    error = "UNSUPPORTED_COMPENSATION_TYPE",
                    compensation_type = compensation_type
                })
            })
            return
        end

        local compensation_data = json.decode(msg.Data or "{}")
        local compensation_request = config.compensation_handler[compensation_type](compensation_data)

        if compensation_request then
            -- å‘é€è¡¥å¿è¯·æ±‚åˆ°å¤–éƒ¨åˆçº¦
            ao.send({
                Target = config.external_config.target,
                Tags = {
                    Action = compensation_request.action,
                    ["X-CompensationSagaId"] = saga_id
                },
                Data = json.encode(compensation_request.data or {})
            })

            -- å‘é€è¡¥å¿æˆåŠŸç¡®è®¤
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "CompensationCompleted",
                    [messaging.X_TAGS.SAGA_ID] = saga_id
                },
                Data = json.encode({ status = "compensation_initiated" })
            })
        else
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "CompensationError",
                    [messaging.X_TAGS.SAGA_ID] = saga_id
                },
                Data = json.encode({
                    error = "COMPENSATION_REQUEST_FAILED",
                    compensation_type = compensation_type
                })
            })
        end
    end

    -- çŠ¶æ€æŸ¥è¯¢å¤„ç†å™¨
    function proxy.handle_status_query(msg)
        local stats = {
            name = config.name,
            version = config.version,
            pending_requests_count = 0,
            expired_requests_cleaned = cleanup_expired_requests(),
            uptime = os.time() - (proxy.start_time or os.time())
        }

        for _ in pairs(pending_requests) do
            stats.pending_requests_count = stats.pending_requests_count + 1
        end

        ao.send({
            Target = msg.From,
            Tags = { Action = "ProxyStatus" },
            Data = json.encode(stats)
        })
    end

    -- æ³¨å†Œæ‰€æœ‰å¤„ç†å™¨
    function proxy.register_handlers()
        proxy.start_time = os.time()

        -- ä»£ç†è°ƒç”¨å¤„ç†å™¨
        Handlers.add(
            config.name .. '_proxy_call',
            Handlers.utils.hasMatchingTag("Action", "ProxyCall"),
            function(msg) proxy.handle_proxy_call(msg) end
        )

        -- å¤–éƒ¨å“åº”å¤„ç†å™¨ï¼ˆé€šç”¨å¤„ç†å™¨ï¼Œå¤„ç†æ‰€æœ‰æ¶ˆæ¯ï¼‰
        Handlers.add(
            config.name .. '_external_response',
            function(msg)
                -- æ£€æŸ¥æ˜¯å¦åŒ…å«æˆ‘ä»¬çš„è¯·æ±‚ID
                if msg.Tags["X-RequestId"] then
                    proxy.handle_external_response(msg)
                end
            end
        )

        -- è¡¥å¿å¤„ç†å™¨
        Handlers.add(
            config.name .. '_compensation',
            Handlers.utils.hasMatchingTag("Action", "ProxyCompensation"),
            function(msg) proxy.handle_compensation(msg) end
        )

        -- çŠ¶æ€æŸ¥è¯¢å¤„ç†å™¨
        Handlers.add(
            config.name .. '_status',
            Handlers.utils.hasMatchingTag("Action", "ProxyStatus"),
            function(msg) proxy.handle_status_query(msg) end
        )

        -- âš ï¸ æ³¨æ„ï¼šä¸å†éœ€è¦éªŒè¯å¤„ç†å™¨ï¼Œè½¬è´¦éªŒè¯ç”±ä¸“ç”¨æ”¯ä»˜æ¥æ”¶åˆçº¦å¤„ç†

        -- æ³¨å†Œè‡ªå®šä¹‰å¤„ç†å™¨
        for handler_name, handler_config in pairs(config.custom_handlers) do
            Handlers.add(
                config.name .. '_' .. handler_name,
                handler_config.filter or function() return true end,
                handler_config.handler
            )
        end

        print(string.format("[%s] Proxy contract initialized with %d custom handlers",
            config.name, #config.custom_handlers))
    end

    -- è·å–å¾…å¤„ç†è¯·æ±‚ï¼ˆè°ƒè¯•ç”¨ï¼‰
    function proxy.get_pending_requests()
        return pending_requests
    end

    -- å¼ºåˆ¶æ¸…ç†æ‰€æœ‰è¯·æ±‚ï¼ˆç´§æ€¥æƒ…å†µç”¨ï¼‰
    function proxy.clear_all_requests()
        local count = 0
        for _ in pairs(pending_requests) do
            count = count + 1
        end
        pending_requests = {}
        return count
    end

    return proxy
end

return proxy_contract_template
