-- <autogenerated>
--   This file was generated by dddappp code generator.
--   Any changes made to this file manually will be lost next time the file is regenerated.
-- </autogenerated>

local json = require("json")

local response_adapters = {}

-- AO Token 合约响应适配器
response_adapters.ao_token = {}

-- 处理转账相关的 Debit-Notice
function response_adapters.ao_token.debit_notice(msg)
    return {
        status = "debited",
        transaction_type = "transfer",
        quantity = msg.Tags.Quantity,
        recipient = msg.Tags.Recipient,
        sender = msg.From,  -- 通常是发送转账请求的进程
        transaction_id = msg.Tags["Message-Id"] or msg.Id,
        timestamp = msg.Tags.Timestamp or os.time(),
        token_contract = msg.From  -- Token 合约的进程ID
    }
end

-- 处理转账相关的 Credit-Notice
function response_adapters.ao_token.credit_notice(msg)
    return {
        status = "credited",
        transaction_type = "transfer",
        quantity = msg.Tags.Quantity,
        sender = msg.Tags.Sender,
        recipient = msg.From,  -- 接收方的进程ID
        transaction_id = msg.Tags["Message-Id"] or msg.Id,
        timestamp = msg.Tags.Timestamp or os.time(),
        token_contract = msg.Tags.From or msg.From
    }
end

-- 处理铸造相关的 Mint-Confirmation
function response_adapters.ao_token.mint_confirmation(msg)
    return {
        status = "minted",
        transaction_type = "mint",
        quantity = msg.Tags.Quantity,
        recipient = msg.Tags.Recipient or msg.From,
        transaction_id = msg.Tags["Message-Id"] or msg.Id,
        timestamp = msg.Tags.Timestamp or os.time(),
        token_contract = msg.From
    }
end

-- 处理转账错误
function response_adapters.ao_token.transfer_error(msg)
    return {
        status = "failed",
        transaction_type = "transfer",
        error_code = msg.Tags.Error or "TRANSFER_FAILED",
        error_message = msg.Tags["Error-Message"] or msg.Data,
        quantity = msg.Tags.Quantity,
        recipient = msg.Tags.Recipient,
        transaction_id = msg.Tags["Message-Id"] or msg.Id,
        timestamp = os.time(),
        token_contract = msg.From
    }
end

-- 处理余额查询响应
function response_adapters.ao_token.balance_response(msg)
    local balance_data = {}
    local decode_success, decode_result = pcall(function()
        return json.decode(msg.Data or "{}")
    end)

    if decode_success then
        balance_data = decode_result
    else
        print("Failed to decode balance response data: " .. decode_result)
    end

    return {
        status = "balance_retrieved",
        address = msg.Tags.Address or msg.Tags.Target,
        balance = balance_data.balance or balance_data.Balance,
        ticker = balance_data.ticker or balance_data.Ticker,
        denomination = balance_data.denomination or balance_data.Denomination,
        timestamp = os.time(),
        token_contract = msg.From,
        decode_error = decode_success and nil or decode_result
    }
end

-- NFT 合约响应适配器
response_adapters.nft = {}

-- 处理 NFT 铸造确认
function response_adapters.nft.mint_confirmation(msg)
    local metadata = {}
    local decode_success, decode_result = pcall(function()
        return json.decode(msg.Data or "{}")
    end)

    if decode_success then
        metadata = decode_result
    else
        print("Failed to decode NFT mint metadata: " .. decode_result)
    end

    return {
        status = "nft_minted",
        transaction_type = "nft_mint",
        token_id = msg.Tags.TokenId,
        name = msg.Tags.Name,
        creator = msg.From,
        transaction_id = msg.Tags["Message-Id"] or msg.Id,
        timestamp = msg.Tags.Timestamp or os.time(),
        contract = msg.From,
        metadata = metadata,
        decode_error = decode_success and nil or decode_result
    }
end

-- 处理 NFT 转让通知
function response_adapters.nft.transfer_notice(msg)
    return {
        status = "nft_transferred",
        transaction_type = "nft_transfer",
        token_id = msg.Tags.TokenId,
        name = msg.Tags.Name,
        from = msg.Tags.From,
        to = msg.Tags.To,
        transaction_id = msg.Tags["Message-Id"] or msg.Id,
        timestamp = msg.Tags.Timestamp or os.time(),
        contract = msg.From
    }
end

-- 处理 NFT 转让错误
function response_adapters.nft.transfer_error(msg)
    return {
        status = "nft_transfer_failed",
        transaction_type = "nft_transfer",
        token_id = msg.Tags.TokenId,
        error_code = msg.Tags.Error or "TRANSFER_FAILED",
        error_message = msg.Data,
        from = msg.Tags.From,
        to = msg.Tags.To,
        timestamp = os.time(),
        contract = msg.From
    }
end

-- 处理 NFT 信息查询响应
function response_adapters.nft.info_response(msg)
    local nft_data = {}
    local decode_success, decode_result = pcall(function()
        return json.decode(msg.Data or "{}")
    end)

    if decode_success then
        nft_data = decode_result
    else
        print("Failed to decode NFT info data: " .. decode_result)
    end

    return {
        status = "nft_info_retrieved",
        token_id = msg.Tags.TokenId,
        name = nft_data.name,
        description = nft_data.description,
        image = nft_data.image,
        owner = nft_data.owner,
        creator = nft_data.creator,
        attributes = nft_data.attributes,
        transferable = nft_data.transferable,
        timestamp = os.time(),
        contract = msg.From,
        decode_error = decode_success and nil or decode_result
    }
end

-- 通用响应适配器
response_adapters.generic = {}

-- 通用成功响应
function response_adapters.generic.success(msg)
    local data = {}
    local decode_success, decode_result = pcall(function()
        return json.decode(msg.Data or "{}")
    end)

    if decode_success then
        data = decode_result
    else
        print("Failed to decode generic success data: " .. decode_result)
    end

    return {
        status = "success",
        action = msg.Tags.Action,
        data = data,
        tags = msg.Tags,
        timestamp = os.time(),
        source = msg.From,
        decode_error = decode_success and nil or decode_result
    }
end

-- 通用错误响应
function response_adapters.generic.error(msg)
    local data = {}
    local decode_success, decode_result = pcall(function()
        return json.decode(msg.Data or "{}")
    end)

    if decode_success then
        data = decode_result
    else
        print("Failed to decode generic error data: " .. decode_result)
    end

    return {
        status = "error",
        action = msg.Tags.Action,
        error_code = msg.Tags.Error or "GENERIC_ERROR",
        error_message = msg.Tags.Message or msg.Data or "Unknown error",
        data = data,
        tags = msg.Tags,
        timestamp = os.time(),
        source = msg.From,
        decode_error = decode_success and nil or decode_result
    }
end

-- 通用确认响应
function response_adapters.generic.confirmation(msg)
    local data = {}
    local decode_success, decode_result = pcall(function()
        return json.decode(msg.Data or "{}")
    end)

    if decode_success then
        data = decode_result
    else
        print("Failed to decode generic confirmation data: " .. decode_result)
    end

    return {
        status = "confirmed",
        action = msg.Tags.Action,
        transaction_id = msg.Tags["Transaction-Id"] or msg.Tags["Message-Id"] or msg.Id,
        data = data,
        tags = msg.Tags,
        timestamp = msg.Tags.Timestamp or os.time(),
        source = msg.From,
        decode_error = decode_success and nil or decode_result
    }
end

-- 适配器工厂函数
function response_adapters.create_adapter(contract_type, response_mappings)
    return function(msg)
        local action = msg.Tags.Action
        local adapter = response_mappings[action]

        if adapter then
            if type(adapter) == "function" then
                return adapter(msg)
            elseif type(adapter) == "string" then
                -- 如果是字符串，尝试在对应类型的适配器中查找
                local type_adapters = response_adapters[contract_type]
                if type_adapters and type_adapters[adapter] then
                    return type_adapters[adapter](msg)
                end
            end
        end

        -- 默认使用通用适配器
        if action and action:match("Error") then
            return response_adapters.generic.error(msg)
        elseif action and action:match("Confirmation") then
            return response_adapters.generic.confirmation(msg)
        else
            return response_adapters.generic.success(msg)
        end
    end
end

-- 预定义的常用适配器配置
response_adapters.presets = {}

-- AO Token 转账适配器配置
response_adapters.presets.ao_token_transfer = {
    ["Debit-Notice"] = "debit_notice",
    ["Credit-Notice"] = "credit_notice",
    ["Transfer-Error"] = "transfer_error",
    ["Mint-Confirmation"] = "mint_confirmation"
}

-- NFT 操作适配器配置
response_adapters.presets.nft_operations = {
    ["Mint-Confirmation"] = "mint_confirmation",
    ["NFT-Transfer-Notice"] = "transfer_notice",
    ["NFT-Transfer-Error"] = "transfer_error",
    ["NFT-Info"] = "info_response"
}

-- 创建预配置的适配器
response_adapters.presets.ao_token_adapter = response_adapters.create_adapter(
    "ao_token", response_adapters.presets.ao_token_transfer
)

response_adapters.presets.nft_adapter = response_adapters.create_adapter(
    "nft", response_adapters.presets.nft_operations
)

-- 工具函数：自动检测响应类型
function response_adapters.detect_response_type(msg)
    local action = msg.Tags.Action
    local data = msg.Data and json.decode(msg.Data) or {}

    -- 检查是否包含错误信息
    if action and action:match("Error") then
        return "error"
    end

    -- 检查是否包含确认信息
    if action and action:match("Confirmation") or action:match("Notice") then
        return "confirmation"
    end

    -- 检查数据内容
    if data.error then
        return "error"
    elseif data.result then
        return "success"
    end

    return "unknown"
end

-- 工具函数：标准化响应格式
function response_adapters.normalize_response(msg, adapter_type)
    local adapter = response_adapters[adapter_type] or response_adapters.generic
    local response_type = response_adapters.detect_response_type(msg)

    if adapter[response_type] then
        return adapter[response_type](msg)
    else
        return response_adapters.generic.success(msg)
    end
end

-- 工具函数：安全 JSON 解析
function response_adapters.safe_json_decode(data)
    if not data or data == "" then
        return {}, nil
    end

    local success, result = pcall(function()
        return json.decode(data)
    end)

    if success then
        return result, nil
    else
        return {}, result  -- 返回空表和错误信息
    end
end

return response_adapters
