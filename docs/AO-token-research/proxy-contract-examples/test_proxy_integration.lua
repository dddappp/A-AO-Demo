-- <autogenerated>
--   This file was generated by dddappp code generator.
--   Any changes made to this file manually will be lost next time the file is regenerated.
-- </autogenerated>

local json = require("json")

-- 测试代理合约集成
local test_proxy_integration = {}

-- 初始化测试环境
function test_proxy_integration.init()
    -- 加载必要的模块
    local saga_messaging = require("saga_messaging")
    local token_transfer_proxy = require("token_transfer_proxy")
    local payment_service = require("payment_service_with_proxy")

    -- 初始化代理系统
    saga_messaging.init_proxy_system()

    print("Proxy integration test environment initialized")
    return true
end

-- 测试支付服务
function test_proxy_integration.test_payment_service()
    print("\n=== Testing Payment Service with Proxy ===")

    -- 模拟支付请求消息
    local payment_request = {
        From = "CUSTOMER_PROCESS_ID",
        Tags = {
            Action = "PaymentService_ProcessPayment"
        },
        Data = json.encode({
            order_id = "ORDER_12345",
            customer_address = "CUSTOMER_ADDRESS",
            merchant_address = "MERCHANT_ADDRESS",
            amount = 100,
            payment_method = "ao_token"
        })
    }

    -- 这里可以调用实际的支付服务
    -- payment_service.process_payment(payment_request, {}, function() end)

    print("Payment service test initiated (commented out for safety)")
    print("Expected flow:")
    print("1. Payment service creates Saga instance")
    print("2. Saga calls token transfer proxy")
    print("3. Proxy forwards request to AO Token contract")
    print("4. AO Token contract responds with Debit-Notice")
    print("5. Proxy converts response and calls back to Saga")
    print("6. Saga completes payment")

    return true
end

-- 测试代理合约直接调用
function test_proxy_integration.test_proxy_contract_direct()
    print("\n=== Testing Proxy Contract Direct Call ===")

    -- 模拟代理调用消息
    local proxy_call_msg = {
        From = "SAGA_MANAGER_PROCESS_ID",
        Tags = {
            Action = "ProxyCall",
            ["X-SagaId"] = "123",
            ["X-CallbackAction"] = "Test_Callback",
            Recipient = "RECIPIENT_ADDRESS",
            Quantity = "50"
        },
        Data = json.encode({
            Recipient = "RECIPIENT_ADDRESS",
            Quantity = "50"
        })
    }

    print("Direct proxy call test initiated")
    print("Expected flow:")
    print("1. Proxy receives call with X-SagaId")
    print("2. Proxy generates request ID and stores mapping")
    print("3. Proxy sends Transfer request to AO Token contract (without X-SagaId)")
    print("4. AO Token contract processes transfer")
    print("5. Proxy receives Debit-Notice and converts to Saga callback")
    print("6. Proxy cleans up request mapping")

    -- 这里可以实际调用代理合约
    -- token_transfer_proxy.handle_proxy_call(proxy_call_msg)

    return true
end

-- 测试响应转换
function test_proxy_integration.test_response_adapters()
    print("\n=== Testing Response Adapters ===")

    local response_adapters = require("response_adapters")

    -- 测试 Debit-Notice 转换
    local debit_msg = {
        From = "TOKEN_CONTRACT_ID",
        Tags = {
            Action = "Debit-Notice",
            Quantity = "100",
            Recipient = "RECIPIENT_ADDRESS",
            ["Message-Id"] = "TX_123"
        },
        Data = "{}"
    }

    local debit_result = response_adapters.ao_token.debit_notice(debit_msg)
    print("Debit-Notice conversion result:")
    print(json.encode(debit_result))

    -- 测试 Transfer-Error 转换
    local error_msg = {
        From = "TOKEN_CONTRACT_ID",
        Tags = {
            Action = "Transfer-Error",
            Error = "INSUFFICIENT_BALANCE",
            Quantity = "100",
            Recipient = "RECIPIENT_ADDRESS"
        },
        Data = "Insufficient balance for transfer"
    }

    local error_result = response_adapters.ao_token.transfer_error(error_msg)
    print("Transfer-Error conversion result:")
    print(json.encode(error_result))

    return true
end

-- 🔑 关键测试：转账金额匹配和 X-SagaId 关联
function test_proxy_integration.test_amount_matching_and_saga_flow()
    print("\n=== Testing Amount Matching and Saga Flow ===")

    local proxy_contract_template = require("proxy_contract_template")
    local messaging = require("messaging")

    -- 创建代理合约实例
    local proxy_config = {
        name = "TestTokenProxy",
        external_config = {
            target = "TOKEN_CONTRACT_ID",
            action = "Transfer",
            response_patterns = {
                success = "Debit-Notice",
                error = "Transfer-Error"
            },
            timeout = 300
        },
        response_adapter = function(msg)
            -- 简化的适配器用于测试
            return { status = "debited", quantity = msg.Tags.Quantity }
        end
    }

    local proxy = proxy_contract_template.create(proxy_config)

    -- 模拟 Saga 请求（转账 100 个 Token）
    local saga_request_msg = {
        From = "SAGA_MANAGER_ID",
        Tags = {
            Action = "ProxyCall",
            ["X-SagaId"] = "SAGA_12345",  -- 🔑 Saga ID
            ["X-CallbackAction"] = "PaymentService_ProcessPayment_TransferTokens_Callback",
            Quantity = "100",  -- 🔑 原始转账金额
            Recipient = "USER_ADDRESS",
            Sender = "PAYMENT_SERVICE_ID"
        },
        Data = "{}"
    }

    -- 触发代理调用
    print("1. Initiating proxy call with amount: 100")
    proxy.handle_proxy_call(saga_request_msg)

    -- 模拟外部 Token 合约的正确响应（金额匹配）
    local correct_response_msg = {
        From = "TOKEN_CONTRACT_ID",
        Tags = {
            Action = "Debit-Notice",
            ["X-RequestId"] = "REQ_001",  -- 这个ID会在实际运行中生成
            Quantity = "100",  -- ✅ 金额匹配
            Recipient = "USER_ADDRESS",
            ["Message-Id"] = "TX_123"
        },
        Data = "{}"
    }

    print("2. Simulating correct Token contract response (amount matches)")
    proxy.handle_external_response(correct_response_msg)

    -- 模拟外部 Token 合约的错误响应（金额不匹配）
    local mismatch_response_msg = {
        From = "TOKEN_CONTRACT_ID",
        Tags = {
            Action = "Debit-Notice",
            ["X-RequestId"] = "REQ_002",  -- 不同的请求ID
            Quantity = "50",   -- ❌ 金额不匹配！期望100，实际50
            Recipient = "USER_ADDRESS",
            ["Message-Id"] = "TX_124"
        },
        Data = "{}"
    }

    print("3. Simulating incorrect Token contract response (amount mismatch: expected 100, got 50)")
    -- 重新发起请求以测试金额不匹配的情况
    saga_request_msg.Tags["X-SagaId"] = "SAGA_67890"
    proxy.handle_proxy_call(saga_request_msg)
    proxy.handle_external_response(mismatch_response_msg)

    print("✅ Amount matching and Saga flow test completed")
    return true
end

-- 🔑 关键测试：高效pending请求查询
function test_proxy_integration.test_efficient_pending_queries()
    print("\n=== Testing Efficient Pending Request Queries ===")

    local proxy_contract_template = require("proxy_contract_template")
    local messaging = require("messaging")

    -- 创建代理合约实例
    local proxy_config = {
        name = "TestEfficientProxy",
        external_config = {
            target = "TOKEN_CONTRACT_ID",
            action = "Transfer",
            response_patterns = {
                success = "Debit-Notice",
                error = "Transfer-Error"
            },
            timeout = 300
        },
        response_adapter = function(msg) return { status = "success" } end
    }

    local proxy = proxy_contract_template.create(proxy_config)

    -- 模拟多个Saga的多个请求
    local test_data = {
        { saga_id = "SAGA_001", amount = "100", recipient = "USER_A" },
        { saga_id = "SAGA_001", amount = "200", recipient = "USER_B" }, -- 同一个Saga的第二个请求
        { saga_id = "SAGA_002", amount = "300", recipient = "USER_C" },
        { saga_id = "SAGA_003", amount = "150", recipient = "USER_D" },
    }

    print("1. Creating multiple pending requests...")
    for i, data in ipairs(test_data) do
        local saga_request_msg = {
            From = "SAGA_MANAGER_ID",
            Tags = {
                Action = "ProxyCall",
                ["X-SagaId"] = data.saga_id,
                ["X-CallbackAction"] = "Callback_" .. i,
                Quantity = data.amount,
                Recipient = data.recipient
            },
            Data = "{}"
        }

        -- 这里会调用proxy.handle_proxy_call，创建pending请求并建立索引
        proxy.handle_proxy_call(saga_request_msg)
    end

    -- 测试高效查询：按saga_id查找 - O(1)复杂度，不需要遍历
    print("2. Testing O(1) saga_id queries...")
    local saga001_requests = proxy.find_requests_by_saga_id("SAGA_001")
    print(string.format("   SAGA_001 has %d pending requests", count_keys(saga001_requests)))
    assert(count_keys(saga001_requests) == 2, "Should find 2 requests for SAGA_001")

    local saga002_requests = proxy.find_requests_by_saga_id("SAGA_002")
    print(string.format("   SAGA_002 has %d pending requests", count_keys(saga002_requests)))
    assert(count_keys(saga002_requests) == 1, "Should find 1 request for SAGA_002")

    local non_existent_requests = proxy.find_requests_by_saga_id("NON_EXISTENT")
    print(string.format("   NON_EXISTENT has %d pending requests", count_keys(non_existent_requests)))
    assert(count_keys(non_existent_requests) == 0, "Should find 0 requests for non-existent saga")

    -- 测试高效查询：按external_target查找 - O(1)复杂度
    print("3. Testing O(1) external_target queries...")
    local target_requests = proxy.find_requests_by_external_target("TOKEN_CONTRACT_ID")
    print(string.format("   TOKEN_CONTRACT_ID has %d pending requests", count_keys(target_requests)))
    assert(count_keys(target_requests) == 4, "Should find 4 requests for TOKEN_CONTRACT_ID")

    -- 测试获取完整请求详情
    print("4. Testing get_pending_requests_for_saga...")
    local saga001_details = proxy.get_pending_requests_for_saga("SAGA_001")
    print(string.format("   SAGA_001 details contain %d request objects", count_keys(saga001_details)))
    assert(count_keys(saga001_details) == 2, "Should get 2 detailed request objects")

    -- 验证金额信息被正确存储
    local found_100 = false
    local found_200 = false
    for request_id, request_info in pairs(saga001_details) do
        if request_info.original_quantity == "100" then found_100 = true end
        if request_info.original_quantity == "200" then found_200 = true end
    end
    assert(found_100 and found_200, "Should find both 100 and 200 amount requests")

    -- 测试取消功能 - 高效地取消整个Saga的所有请求
    print("5. Testing cancel_saga_requests (efficient bulk cancellation)...")
    local cancelled_count = proxy.cancel_saga_requests("SAGA_001", "Test cancellation")
    print(string.format("   Cancelled %d requests for SAGA_001", cancelled_count))
    assert(cancelled_count == 2, "Should cancel 2 requests for SAGA_001")

    -- 验证取消后的查询结果
    local saga001_after_cancel = proxy.find_requests_by_saga_id("SAGA_001")
    print(string.format("   SAGA_001 has %d pending requests after cancellation", count_keys(saga001_after_cancel)))
    assert(count_keys(saga001_after_cancel) == 0, "Should have 0 requests after cancellation")

    print("✅ Efficient pending request queries test completed")
    return true
end

-- 🔑 核心测试：通过金额匹配搜索pending请求并触发Saga流程
function test_proxy_integration.test_amount_matching_saga_flow()
    print("\n=== Testing Amount Matching and Saga Flow Triggering ===")

    local proxy_contract_template = require("proxy_contract_template")
    local messaging = require("messaging")

    -- 创建代理合约实例
    local proxy_config = {
        name = "TestAmountMatchingProxy",
        external_config = {
            target = "TOKEN_CONTRACT_ID",
            action = "Transfer",
            response_patterns = {
                success = "Debit-Notice",
                error = "Transfer-Error"
            },
            timeout = 300
        },
        response_adapter = function(msg) return { status = "debited", quantity = msg.Tags.Quantity } end
    }

    local proxy = proxy_contract_template.create(proxy_config)

    -- 模拟两个不同的转账请求
    local requests = {
        { saga_id = "SAGA_001", amount = "100", recipient = "USER_A", callback = "Callback_A" },
        { saga_id = "SAGA_002", amount = "200", recipient = "USER_B", callback = "Callback_B" },
        { saga_id = "SAGA_003", amount = "100", recipient = "USER_C", callback = "Callback_C" }, -- 相同金额不同接收方
    }

    print("1. Creating pending requests with business parameters...")
    for i, req in ipairs(requests) do
        local saga_request_msg = {
            From = "SAGA_MANAGER_ID",
            Tags = {
                Action = "ProxyCall",
                ["X-SagaId"] = req.saga_id,
                ["X-CallbackAction"] = req.callback,
                Quantity = req.amount,
                Recipient = req.recipient
            },
            Data = "{}"
        }

        -- 创建pending请求，这会建立业务参数索引
        proxy.handle_proxy_call(saga_request_msg)
        print(string.format("   Created request: saga=%s, amount=%s, recipient=%s",
            req.saga_id, req.amount, req.recipient))
    end

    -- 测试通过金额查找
    print("\n2. Testing amount-based search...")
    local amount_100_requests = proxy.find_requests_by_amount("100")
    print(string.format("   Found %d requests with amount=100", count_keys(amount_100_requests)))
    assert(count_keys(amount_100_requests) == 2, "Should find 2 requests with amount 100")

    -- 测试精确匹配：金额+接收方
    print("\n3. Testing exact business parameter matching...")
    local exact_match = proxy.find_request_by_business_params("100", "USER_A")
    assert(exact_match ~= nil, "Should find exact match for amount=100, recipient=USER_A")
    assert(exact_match.saga_id == "SAGA_001", "Should match correct saga")
    print("   ✅ Exact match found: saga=SAGA_001 for amount=100, recipient=USER_A")

    -- 🔑 核心演示：模拟外部响应（不包含X-RequestId），通过金额匹配找到对应请求
    print("\n4. 🔑 Core Demo: External response matching by amount...")

    -- 模拟Token合约响应 - 注意：不包含X-RequestId！
    local external_response = {
        From = "TOKEN_CONTRACT_ID",
        Tags = {
            Action = "Debit-Notice",
            Quantity = "100",        -- 🔑 通过金额匹配
            Recipient = "USER_A",    -- 🔑 通过接收方匹配
            ["Message-Id"] = "TX_123"
        },
        Data = "{}"
    }

    print("   Simulating external response WITHOUT X-RequestId:")
    print("   - Amount: 100")
    print("   - Recipient: USER_A")
    print("   - Expected to match: SAGA_001")

    -- 调用响应处理器 - 这会通过业务参数匹配找到对应的pending请求
    proxy.handle_external_response(external_response)

    -- 验证：对应的请求应该已经被处理和清理
    local after_match = proxy.find_request_by_business_params("100", "USER_A")
    assert(after_match == nil, "Request should be cleaned up after successful matching")
    print("   ✅ Request successfully matched and cleaned up")

    -- 验证其他请求仍然存在
    local saga002_still_exists = proxy.find_request_by_business_params("200", "USER_B")
    assert(saga002_still_exists ~= nil, "Other requests should still exist")
    print("   ✅ Other requests remain untouched")

    -- 🔑 最终验证：通过金额找到X-SagaId并继续流程
    print("\n5. 🔑 Final Verification: Finding X-SagaId through amount matching...")

    -- 模拟另一个响应，通过金额找到对应的Saga
    local another_response = {
        From = "TOKEN_CONTRACT_ID",
        Tags = {
            Action = "Debit-Notice",
            Quantity = "200",        -- 这个金额对应SAGA_002
            Recipient = "USER_B",
            ["Message-Id"] = "TX_456"
        },
        Data = "{}"
    }

    -- 通过业务参数查找对应的请求信息
    local matched_request = proxy.find_request_by_business_params("200", "USER_B")
    assert(matched_request ~= nil, "Should find the request")
    assert(matched_request.saga_id == "SAGA_002", "Should find correct saga")

    print("   ✅ Found X-SagaId through amount matching:")
    print(string.format("      Amount: 200 → Saga ID: %s", matched_request.saga_id))
    print(string.format("      Callback Action: %s", matched_request.callback_action))

    -- 模拟完整的响应处理
    proxy.handle_external_response(another_response)

    -- 验证Saga流程被正确触发（请求被清理）
    local final_check = proxy.find_request_by_business_params("200", "USER_B")
    assert(final_check == nil, "Saga flow should be triggered and request cleaned up")

    print("   ✅ Saga flow successfully triggered through amount matching!")

    print("\n✅ Amount matching saga flow test completed")
    return true
end

-- 🔑 边界情况测试：重复消息、内存限制、幂等性
function test_proxy_integration.test_boundary_cases_and_safety()
    print("\n=== Testing Boundary Cases and Safety Measures ===")

    local proxy_contract_template = require("proxy_contract_template")
    local messaging = require("messaging")

    -- 创建代理合约实例
    local proxy_config = {
        name = "TestBoundaryCasesProxy",
        external_config = {
            target = "TOKEN_CONTRACT_ID",
            action = "Transfer",
            response_patterns = {
                success = "Debit-Notice",
                error = "Transfer-Error"
            },
            timeout = 300
        },
        response_adapter = function(msg) return { status = "success" } end
    }

    local proxy = proxy_contract_template.create(proxy_config)

    -- 测试1：重复消息处理（幂等性）
    print("1. Testing duplicate message handling...")
    local saga_request_msg = {
        From = "SAGA_MANAGER_ID",
        Tags = {
            Action = "ProxyCall",
            ["X-SagaId"] = "SAGA_DUPLICATE_TEST",
            ["X-CallbackAction"] = "Callback_Duplicate",
            Quantity = "500",
            Recipient = "USER_DUPLICATE"
        },
        Data = "{}"
    }

    -- 创建初始请求
    proxy.handle_proxy_call(saga_request_msg)

    -- 模拟第一次响应
    local first_response = {
        From = "TOKEN_CONTRACT_ID",
        Tags = {
            Action = "Debit-Notice",
            ["X-RequestId"] = "REQ_001",
            Quantity = "500",
            Recipient = "USER_DUPLICATE"
        },
        Data = "{}"
    }

    print("   Sending first response...")
    proxy.handle_external_response(first_response)

    -- 模拟重复响应（相同的请求ID）
    print("   Sending duplicate response (same request ID)...")
    proxy.handle_external_response(first_response)  -- 应该被忽略

    -- 测试2：内存限制
    print("\n2. Testing memory limits...")
    -- 创建大量请求来测试内存限制
    for i = 1, 50 do
        local bulk_request = {
            From = "SAGA_MANAGER_ID",
            Tags = {
                Action = "ProxyCall",
                ["X-SagaId"] = "SAGA_BULK_" .. i,
                ["X-CallbackAction"] = "Callback_Bulk_" .. i,
                Quantity = tostring(100 + i),
                Recipient = "USER_BULK_" .. i
            },
            Data = "{}"
        }
        proxy.handle_proxy_call(bulk_request)
    end

    print("   Created 50 requests, testing memory enforcement...")
    proxy.enforce_memory_limits()  -- 应该触发清理

    -- 测试3：业务参数不完整的情况
    print("\n3. Testing incomplete business parameters...")
    local incomplete_response = {
        From = "TOKEN_CONTRACT_ID",
        Tags = {
            Action = "Debit-Notice",
            Quantity = "300"  -- 缺少Recipient
        },
        Data = "{}"
    }

    print("   Sending response with incomplete parameters...")
    proxy.handle_external_response(incomplete_response)  -- 应该被拒绝

    -- 测试4：无匹配请求的情况
    print("\n4. Testing no matching request...")
    local no_match_response = {
        From = "TOKEN_CONTRACT_ID",
        Tags = {
            Action = "Debit-Notice",
            Quantity = "999999",  -- 不存在的金额
            Recipient = "NON_EXISTENT_USER"
        },
        Data = "{}"
    }

    print("   Sending response with no matching request...")
    proxy.handle_external_response(no_match_response)  -- 应该被记录但忽略

    print("\n✅ Boundary cases and safety measures test completed")
    return true
end

-- 辅助函数：计算table中key的数量
function count_keys(tbl)
    local count = 0
    for _ in pairs(tbl) do
        count = count + 1
    end
    return count
end

-- 测试 Saga 工具函数
function test_proxy_integration.test_saga_tools()
    print("\n=== Testing Saga Tools ===")

    local saga_messaging = require("saga_messaging")

    -- 注册测试代理合约
    local test_proxy = saga_messaging.register_proxy_contract("test_proxy", {
        name = "TestProxy",
        external_config = {
            target = "TEST_EXTERNAL_CONTRACT",
            action = "TestAction"
        }
    })

    print("Test proxy registered successfully")

    -- 测试获取代理合约
    local retrieved_proxy = saga_messaging.get_proxy_contract("test_proxy")
    assert(retrieved_proxy == test_proxy, "Proxy retrieval failed")

    print("Proxy retrieval test passed")

    return true
end

-- 运行所有测试
function test_proxy_integration.run_all_tests()
    print("Starting Proxy Integration Tests...")

    local results = {}

    results.init = test_proxy_integration.init()
    results.adapters = test_proxy_integration.test_response_adapters()
    results.amount_matching = test_proxy_integration.test_amount_matching_and_saga_flow()  -- 🔑 新增关键测试
    results.efficient_queries = test_proxy_integration.test_efficient_pending_queries()  -- 🔑 新增高效查询测试
    results.core_amount_saga = test_proxy_integration.test_amount_matching_saga_flow()  -- 🔑 核心：金额匹配触发Saga流程
    results.boundary_cases = test_proxy_integration.test_boundary_cases_and_safety()  -- 🔑 边界情况和安全测试
    results.payment = test_proxy_integration.test_payment_service()
    results.proxy_direct = test_proxy_integration.test_proxy_contract_direct()
    results.saga_tools = test_proxy_integration.test_saga_tools()

    print("\n=== Test Results ===")
    local all_passed = true
    for test_name, result in pairs(results) do
        local status = result and "PASS" or "FAIL"
        print(string.format("%-15s: %s", test_name, status))
        if not result then
            all_passed = false
        end
    end

    print("\nOverall result: " .. (all_passed and "ALL TESTS PASSED" or "SOME TESTS FAILED"))

    return all_passed
end

-- 导出测试模块
return test_proxy_integration
