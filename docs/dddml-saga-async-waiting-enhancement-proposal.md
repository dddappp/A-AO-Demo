# DDDML Sagaå¼‚æ­¥ç­‰å¾…æœºåˆ¶å¢å¼ºå»ºè®®ä¹¦

## æ‰§è¡Œæ‘˜è¦

### é—®é¢˜é™ˆè¿°
å½“å‰DDDMLè§„èŒƒä¸æ”¯æŒæè¿°Sagaæ­¥éª¤"ç­‰å¾…å¤–éƒ¨è¾“å…¥"çš„åœºæ™¯ï¼Œå¯¼è‡´å¼€å‘è€…æ— æ³•ä½¿ç”¨DDDMLé«˜æ•ˆå¼€å‘æ¶‰åŠç”¨æˆ·äº¤äº’ã€å¤–éƒ¨ç³»ç»Ÿé›†æˆç­‰å¼‚æ­¥ä¸šåŠ¡æµç¨‹ã€‚

**å…¸å‹ä¸šåŠ¡åœºæ™¯**ï¼ˆè¯¦è§é™„ä»¶ï¼šexternal-contract-saga-integration.mdï¼‰ï¼š
- **åŠè‡ªåŠ¨åŒ–ç”µå•†æ”¯ä»˜**ï¼šæ³¨å†Œæ”¯ä»˜æ„å‘ â†’ ç­‰å¾…ç”¨æˆ·è½¬è´¦ â†’ éªŒè¯æ”¯ä»˜ â†’ æ›´æ–°è®¢å• â†’ é€šçŸ¥å•†å®¶
- **è·¨åˆçº¦åº“å­˜è°ƒæ•´**ï¼šéªŒè¯è¯·æ±‚ â†’ ç­‰å¾…ç»ç†å®¡æ‰¹ â†’ æ‰§è¡Œåº“å­˜å˜æ›´ â†’ æ›´æ–°è´¢åŠ¡è®°å½•
- **å¤–éƒ¨Tokené›†æˆ**ï¼šå‘èµ·è½¬è´¦ â†’ ç­‰å¾…Tokenåˆçº¦ç¡®è®¤ â†’ ç»§ç»­ä¸šåŠ¡æµç¨‹

### æ ¸å¿ƒå‘ç°
ç»è¿‡æ·±å…¥åˆ†æç°æœ‰DDDML Sagaå®ç°ï¼Œæˆ‘ä»¬å‘ç°ï¼š
- AOç¼–ç¨‹æ¨¡å‹ç¡®å®æ˜¯å¼‚æ­¥æ¶ˆæ¯é©±åŠ¨çš„
- DDDMLå½“å‰ç”Ÿæˆçš„Sagaä»£ç å·²ç»æ˜¯æ¶ˆæ¯é©±åŠ¨çš„
- **é—®é¢˜æœ¬è´¨æ˜¯DDDMLè§„èŒƒç¼ºå°‘æè¿°"ç­‰å¾…å¤–éƒ¨äº‹ä»¶"çš„è¯­æ³•**

### è§£å†³æ–¹æ¡ˆ
æ‰©å±•DDDML for AOè§„èŒƒï¼Œæ·»åŠ `waitForEvent`æ­¥éª¤ç±»å‹ï¼Œä½¿ä»£ç ç”Ÿæˆå™¨èƒ½å¤Ÿç”Ÿæˆç›¸åº”çš„å¼‚æ­¥äº‹ä»¶å¤„ç†ä»£ç ã€‚

### å…³é”®ä¼˜åŠ¿
- **å®Œå…¨å‘åå…¼å®¹**ï¼šç°æœ‰Sagaå®šä¹‰100%å…¼å®¹
- **æ¶æ„ä¸€è‡´æ€§**ï¼šä¿æŒDDDMLçš„è®¾è®¡å“²å­¦
- **åŒºå—é“¾å‹å¥½**ï¼šåŸºäºæ¶ˆæ¯é©±åŠ¨çš„è¶…æ—¶æœºåˆ¶ï¼Œæ— éœ€ä¸»åŠ¨å®šæ—¶å™¨
- **ç”Ÿäº§å°±ç»ª**ï¼šåŒ…å«ç›‘æ§ã€å®‰å…¨ã€æ€§èƒ½ä¼˜åŒ–

### å®æ–½å»ºè®®
- æ€»å¼€å‘å‘¨æœŸï¼š5ä¸ªæœˆ
- åˆ†é˜¶æ®µå®æ–½ï¼šæ¦‚å¿µéªŒè¯ â†’ æ ¸å¿ƒå¼€å‘ â†’ ä¼˜åŒ– â†’ å‘å¸ƒ
- é¢„æœŸROIï¼š6ä¸ªæœˆå†…å›æ”¶æŠ•èµ„ï¼Œ3å¹´å†…æ”¶ç›Š5-10å€

### ä¸šåŠ¡ä»·å€¼
- æå‡å¼€å‘æ•ˆç‡30%ä»¥ä¸Š
- å‡å°‘ä»£ç è¡Œæ•°40%ä»¥ä¸Š
- é™ä½bugç‡50%ä»¥ä¸Š
- å¼€å¯å…¨æ–°å¼‚æ­¥ä¸šåŠ¡åœºæ™¯

---

**æ–‡æ¡£çŠ¶æ€**ï¼šå»ºè®®ä¹¦ - ç­‰å¾…å®æ–½å†³ç­–
**å»ºè®®ä¼˜å…ˆçº§**ï¼šé«˜
**é¢„è®¡æ”¶ç›Š**ï¼šæ˜¾è‘—
**å®æ–½å¤æ‚åº¦**ï¼šä¸­ç­‰

## æ ¸å¿ƒç†å¿µ

### é—®é¢˜æœ¬è´¨

AOçš„ç¼–ç¨‹æ¨¡å‹æœ¬èº«å°±æ˜¯å¼‚æ­¥æ¶ˆæ¯é©±åŠ¨çš„ï¼Œå½“å‰DDDMLç”Ÿæˆçš„Sagaä»£ç ä¹Ÿå·²ç»æ˜¯æ¶ˆæ¯é©±åŠ¨çš„ï¼ˆ`invokeParticipant`å‘é€å¼‚æ­¥æ¶ˆæ¯ï¼Œ`onReply`å¤„ç†å¼‚æ­¥å“åº”ï¼‰ã€‚**é—®é¢˜çš„æœ¬è´¨åœ¨äºDDDMLè§„èŒƒç¼ºå°‘æè¿°"ç­‰å¾…å¤–éƒ¨è¾“å…¥"çš„è¯­æ³•ã€‚**

### è§£å†³æ–¹å‘

è¿™æ˜¯ä¸€ä¸ª**è§„èŒƒæ‰©å±•é—®é¢˜**ï¼Œè€Œä¸æ˜¯æ¶æ„é‡æ„é—®é¢˜ã€‚é€šè¿‡æ‰©å±•DDDML for AOè§„èŒƒï¼Œæ·»åŠ `waitForEvent`æ­¥éª¤ç±»å‹ï¼Œå°±èƒ½ä¼˜é›…åœ°å®ç°external-contract-saga-integration.mdä¸­æè¿°çš„ä¸šåŠ¡åœºæ™¯ã€‚

### è®¾è®¡åŸåˆ™

1. **æ·±å…¥ç†è§£ç°æœ‰æœºåˆ¶**ï¼šå……åˆ†ç†è§£å½“å‰DDDML Sagaçš„å·¥ä½œæ–¹å¼
2. **è¯†åˆ«æ‰©å±•ç‚¹**ï¼šæ‰¾åˆ°å¯ä»¥ä¼˜é›…æ·»åŠ å¤–éƒ¨äº‹ä»¶ç­‰å¾…æ”¯æŒçš„åˆ‡å…¥ç‚¹
3. **ç¡®ä¿å…¼å®¹æ€§**ï¼šæ–°åŠŸèƒ½ä¸ç°æœ‰æœºåˆ¶æ— ç¼é›†æˆï¼Œ100%å‘åå…¼å®¹
4. **ä¿æŒç®€æ´æ€§**ï¼šå¤ç”¨ç°æœ‰è¯­æ³•å…ƒç´ ï¼ˆå¦‚`exportVariables`ï¼‰ï¼Œé¿å…å‘æ˜æ–°æ¦‚å¿µ

## waitForEventè¯­æ³•è§„èŒƒæ¦‚è§ˆ

ä¸ºä¾¿äºDDDMLå·¥å…·å›¢é˜Ÿå¿«é€Ÿç†è§£ï¼Œè¿™é‡Œå…ˆç»™å‡º`waitForEvent`æ­¥éª¤ç±»å‹çš„å®Œæ•´è¯­æ³•è§„èŒƒã€‚è¯¦ç»†è®¾è®¡è€ƒé‡å’Œå®ç°ç»†èŠ‚è§åç»­ç« èŠ‚ã€‚

### è¯­æ³•å®šä¹‰

```yaml
steps:
  WaitForPayment:
    waitForEvent: "PaymentCompleted"       # å¿…éœ€ï¼šå£°æ˜ç­‰å¾…çš„æˆåŠŸäº‹ä»¶ç±»å‹
    onSuccess:                             # å¯é€‰ï¼šå¤„ç†æˆåŠŸäº‹ä»¶ï¼ˆåŒ…æ‹¬è¿‡æ»¤é€»è¾‘ï¼‰
      Lua: |
        -- è¿‡æ»¤å’Œä¸šåŠ¡å¤„ç†é€»è¾‘
        if event.Amount >= context.ExpectedAmount then
          return true  -- è¿”å›trueç»§ç»­Sagaï¼Œfalseå¿½ç•¥äº‹ä»¶
        else
          return false
        end
    exportVariables:                       # å¯é€‰ï¼šæ˜ å°„äº‹ä»¶æ•°æ®åˆ°Sagaä¸Šä¸‹æ–‡
      ActualAmount:
        extractionPath: ".Amount"
      TransactionId:
        extractionPath: ".TransactionId"
    failureEvent: "PaymentFailed"          # å¯é€‰ï¼šå£°æ˜å¤±è´¥äº‹ä»¶ç±»å‹
    onFailure:                             # å¯é€‰ï¼šå¤„ç†å¤±è´¥äº‹ä»¶
      Lua: "-- å¤„ç†å¤±è´¥é€»è¾‘ï¼Œè¿”å›'compensate'è§¦å‘è¡¥å¿"
    maxWaitTime: "30m"                     # å¯é€‰ï¼šæœ€å¤§ç­‰å¾…æ—¶é—´ï¼ˆåŒºå—é“¾å‹å¥½ï¼Œå¤–éƒ¨ç›‘æ§ï¼‰
    withCompensation: "RefundPayment"      # å¯é€‰ï¼šè¡¥å¿å‡½æ•°ï¼ˆä½¿ç”¨PascalCaseï¼‰
    compensationArguments:                 # å¯é€‰ï¼šè¡¥å¿å‚æ•°
      TransactionId: "TransactionId"       # ä½¿ç”¨PascalCaseå‘½å
```

### å…³é”®è®¾è®¡å†³ç­–

1. **å¤ç”¨ç°æœ‰è¯­æ³•**ï¼š`exportVariables`ã€`withCompensation`ç­‰ä¸ç°æœ‰Sagaæ­¥éª¤ä¸€è‡´
2. **å‘½åä¸€è‡´æ€§**ï¼š`onSuccess`/`onFailure`éµå¾ª`onReply`æ¨¡å¼
3. **åŒºå—é“¾å‹å¥½**ï¼š`maxWaitTime`å£°æ˜å¼ï¼Œè¶…æ—¶ç”±å¤–éƒ¨ç›‘æ§è§¦å‘
4. **çµæ´»è¿‡æ»¤**ï¼š`onSuccess`ä¸­å®ç°ä»»æ„å¤æ‚çš„ä¸šåŠ¡éªŒè¯é€»è¾‘

### DDDMLå‘½åè§„èŒƒè¯´æ˜

åŸºäºç°æœ‰DDDMLè§„èŒƒï¼ˆå‚è€ƒ`dddml/a-ao-demo.yaml`ï¼‰ï¼Œæœ¬ææ¡ˆéµå¾ªä»¥ä¸‹å‘½åçº¦å®šï¼š

1. **DDDMLå…³é”®å­—**ï¼šä½¿ç”¨`camelCase`
   - ç°æœ‰å…³é”®å­—ï¼š`invokeParticipant`ã€`invokeLocal`ã€`onReply`ã€`prepareRequest`ã€`exportVariables`ã€`withCompensation`
   - æ–°å¢å…³é”®å­—ï¼š`waitForEvent`ã€`onSuccess`ã€`onFailure`ã€`failureEvent`ã€`maxWaitTime`

2. **ä¸šåŠ¡å¯¹è±¡åï¼ˆYAML keyï¼‰**ï¼šä½¿ç”¨`PascalCase`
   - ç¤ºä¾‹ï¼š`InOutId`ã€`MovementQuantity`ã€`ProductId`
   - æ­¥éª¤åï¼š`GetInventoryItem`ã€`CreateSingleLineInOut`ã€`WaitForPayment`
   - exportVariablesçš„å˜é‡åï¼š`ActualAmount`ã€`TransactionId`

3. **å­—ç¬¦ä¸²å€¼/äº‹ä»¶å**ï¼šæ— ä¸¥æ ¼é™åˆ¶
   - å¯ä»¥æ˜¯`"payment_completed"`æˆ–`"PaymentCompleted"`
   - æ ¹æ®ä¸šåŠ¡è¯­ä¹‰å’Œå›¢é˜Ÿåå¥½é€‰æ‹©
   - æœ¬æ–‡æ¡£ç¤ºä¾‹ä¸­å¯èƒ½æ··ç”¨ä¸¤ç§é£æ ¼

### ä»£ç ç”Ÿæˆç­–ç•¥

DDDMLå·¥å…·ç”Ÿæˆï¼š
- `trigger_local_saga_event(saga_id, event_type, event_data)` API
- Sagaç­‰å¾…çŠ¶æ€ç®¡ç†ä»£ç 
- äº‹ä»¶è¿‡æ»¤å’Œæ•°æ®æ˜ å°„é€»è¾‘

å¼€å‘è€…ç¼–å†™ï¼š
- ä»£ç†åˆçº¦ä¸šåŠ¡é€»è¾‘
- è°ƒç”¨`trigger_local_saga_event()`å‘å¸ƒæœ¬åœ°äº‹ä»¶

## DDDML Sagaç°æœ‰å®ç°æ·±åº¦åˆ†æ

ä¸ºäº†è®¾è®¡å‡ºå…¼å®¹ä¸”ä¼˜é›…çš„æ‰©å±•æ–¹æ¡ˆï¼Œæˆ‘ä»¬å¿…é¡»å…ˆå½»åº•ç†è§£ç°æœ‰DDDML Sagaçš„å®ç°æœºåˆ¶ã€‚è¿™ä¸ä»…ä»…æ˜¯æŠ€æœ¯ç»†èŠ‚ï¼Œæ›´æ˜¯è®¾è®¡å†³ç­–çš„åŸºç¡€ã€‚

### ç°æœ‰DDDML Sagaç¤ºä¾‹å®Œæ•´åˆ†æ

#### 1. YAMLå®šä¹‰ç»“æ„åˆ†æ

åŸºäº`a-ao-demo.yaml`çš„å®Œæ•´Sagaå®šä¹‰ï¼š

```yaml
services:
  InventoryService:
    requiredComponents:
      InventoryItem: InventoryItem
      InOut: InOutService
    methods:
      ProcessInventorySurplusOrShortage:
        parameters:
          ProductId: number
          Location: string
          Quantity: number
        steps:  # æ­¥éª¤å®šä¹‰ç»“æ„
          GetInventoryItem:  # æ­¥éª¤åä½œä¸ºkeyï¼ˆéæ•°ç»„ï¼‰
            prepareRequest:
              Lua: "-- TODO"
            invokeParticipant: "InventoryItem.GetInventoryItem"
            onReply:
              Lua: "-- TODO"
          CreateSingleLineInOut:
            invokeParticipant: "InOut.CreateSingleLineInOut"
            exportVariables:
              InOutId: ".InOutId"
              InOutVersion: ".Version"
            withCompensation: "InOut.VoidInOut"
            compensationArguments:
              InOutId: "InOutId"
              Version: "InOutVersion"
          DoSomethingLocally:
            invokeLocal: ""  # é»˜è®¤å‡½æ•°å
            withCompensation: ""  # é»˜è®¤è¡¥å¿å‡½æ•°å
          AddInventoryItemEntry:
            invokeParticipant: "InventoryItem.AddInventoryItemEntry"
            arguments:
              Version: "ItemVersion"
          DoSomethingElseLocally:
            invokeLocal: ""
            withCompensation: ""
          CompleteInOut:
            invokeParticipant: "InOut.CompleteInOut"
            arguments:
              InOutId: "InOutId"
              Version: "InOutVersion"
          ReturnResult:
            expression:
              Lua: "{ in_out_id = context.in_out_id }"
```

**å…³é”®å‘ç°**ï¼š
- `steps`æ˜¯å¯¹è±¡ç»“æ„ï¼Œä¸æ˜¯æ•°ç»„
- æ¯ä¸ªæ­¥éª¤éƒ½æœ‰å”¯ä¸€çš„åç§°ä½œä¸ºkey
- æ”¯æŒå¤šç§æ­¥éª¤ç±»å‹ï¼š`invokeParticipant`ã€`invokeLocal`ã€`expression`
- æ”¯æŒè¡¥å¿å®šä¹‰ï¼š`withCompensation`ã€`compensationArguments`
- æ”¯æŒæ•°æ®æµï¼š`exportVariables`ã€`arguments`

#### 2. ç”Ÿæˆä»£ç ç»“æ„åˆ†æ

DDDMLå·¥å…·ä»YAMLå®šä¹‰ç”Ÿæˆä»¥ä¸‹å…³é”®ä»£ç ï¼š

##### æœåŠ¡å…¥å£å‡½æ•°
```lua
function inventory_service.process_inventory_surplus_or_shortage(msg, env, response)
    -- 1. è§£æè¯·æ±‚
    local cmd = json.decode(msg.Data)
    local context = cmd

    -- 2. åˆ›å»ºSagaå®ä¾‹
    local saga_instance, commit = saga.create_saga_instance(
        ACTIONS.PROCESS_INVENTORY_SURPLUS_OR_SHORTAGE,
        target, tags, context, original_message, 0
    )

    -- 3. å‡†å¤‡ç¬¬ä¸€ä¸ªæ­¥éª¤çš„è¯·æ±‚
    local request = process_inventory_surplus_or_shortage_prepare_get_inventory_item_request(context)

    -- 4. è®¾ç½®Sagaæ¶ˆæ¯æ ‡ç­¾
    tags[messaging.X_TAGS.SAGA_ID] = tostring(saga_id)
    tags[messaging.X_TAGS.RESPONSE_ACTION] = callback_action

    -- 5. å‘é€æ¶ˆæ¯å¹¶æäº¤SagaçŠ¶æ€
    messaging.commit_send_or_error(status, request, commit, target, tags)
end
```

##### å›è°ƒå‡½æ•°æ¨¡å¼
æ¯ä¸ªæ­¥éª¤ç”Ÿæˆå¯¹åº”çš„å›è°ƒå‡½æ•°ï¼š

```lua
function inventory_service.process_inventory_surplus_or_shortage_get_inventory_item_callback(msg, env, response)
    -- 1. éªŒè¯æ­¥éª¤çŠ¶æ€
    local saga_id = tonumber(msg.Tags[messaging.X_TAGS.SAGA_ID])
    local saga_instance = saga.get_saga_instance_copy(saga_id)
    if (saga_instance.current_step ~= 1 or saga_instance.compensating) then
        error(ERRORS.INVALID_MESSAGE)
    end

    -- 2. å¤„ç†å“åº”
    local data = json.decode(msg.Data)
    if (data.error) then
        rollback_saga_instance_respond_original_requester(saga_instance, data.error)
        return
    end

    -- 3. æ‰§è¡Œæœ¬åœ°ä¸šåŠ¡é€»è¾‘
    local context = saga_instance.context
    process_inventory_surplus_or_shortage_on_get_inventory_item_reply(context, data.result)

    -- 4. å‡†å¤‡ä¸‹ä¸€ä¸ªæ­¥éª¤
    local target = in_out_config.get_target()
    local tags = { Action = in_out_config.get_create_single_line_in_out_action() }
    local request = { /* ä¸‹ä¸€ä¸ªæ­¥éª¤çš„è¯·æ±‚æ•°æ® */ }

    -- 5. å‰è¿›åˆ°ä¸‹ä¸€ä¸ªæ­¥éª¤
    local commit = saga.move_saga_instance_forward(saga_id, 1, target, tags, context)
    tags[messaging.X_TAGS.SAGA_ID] = tostring(saga_id)
    tags[messaging.X_TAGS.RESPONSE_ACTION] = next_callback_action

    messaging.commit_send_or_error(status, request, commit, target, tags)
end
```

#### 3. Sagaè¿è¡Œæ—¶çŠ¶æ€ç®¡ç†

åŸºäº`saga.lua`çš„Sagaå®ä¾‹ç»“æ„ï¼š

```lua
local saga_instance = {
    saga_id = saga_id,              -- Sagaå”¯ä¸€æ ‡è¯†
    saga_type = saga_type,          -- Sagaç±»å‹æ ‡è¯†
    current_step = 1,              -- å½“å‰æ‰§è¡Œæ­¥éª¤ï¼ˆæ•°å­—ç´¢å¼•ï¼‰
    compensating = false,          -- æ˜¯å¦æ­£åœ¨è¡¥å¿
    completed = false,             -- æ˜¯å¦å·²å®Œæˆ
    participants = {},             -- å‚ä¸è€…è®°å½•
    compensations = {},            -- è¡¥å¿è®°å½•
    context = context,             -- ä¸šåŠ¡ä¸Šä¸‹æ–‡æ•°æ®
    original_message = original_message, -- åŸå§‹è¯·æ±‚æ¶ˆæ¯
}
```

**çŠ¶æ€ç®¡ç†æœºåˆ¶**ï¼š
- `current_step`ï¼šä¸¥æ ¼çš„æ•°å­—é€’å¢ï¼Œä»1å¼€å§‹
- `participants`ï¼šè®°å½•æ¯ä¸ªæ­¥éª¤çš„å‚ä¸è€…ä¿¡æ¯
- `compensations`ï¼šè®°å½•è¡¥å¿é€»è¾‘
- `context`ï¼šåœ¨æ­¥éª¤é—´ä¼ é€’ä¸šåŠ¡æ•°æ®

#### 4. æ­¥éª¤æ‰§è¡Œé¡ºåºæ˜ å°„

YAMLä¸­çš„å‘½åæ­¥éª¤å¦‚ä½•æ˜ å°„åˆ°è¿è¡Œæ—¶çš„æ•°å­—æ­¥éª¤ï¼š

| YAMLæ­¥éª¤å             | è¿è¡Œæ—¶æ­¥éª¤å· | è¯´æ˜               |
| ---------------------- | ------------ | ------------------ |
| GetInventoryItem       | 1            | æŸ¥è¯¢åº“å­˜é¡¹         |
| CreateSingleLineInOut  | 2            | åˆ›å»ºå‡ºå…¥åº“å•       |
| DoSomethingLocally     | 3            | æœ¬åœ°ä¸šåŠ¡é€»è¾‘1      |
| AddInventoryItemEntry  | 4            | æ·»åŠ åº“å­˜é¡¹æ¡ç›®     |
| DoSomethingElseLocally | 5            | æœ¬åœ°ä¸šåŠ¡é€»è¾‘2      |
| CompleteInOut          | 6            | å®Œæˆå‡ºå…¥åº“å•       |
| ReturnResult           | -            | è¿”å›ç»“æœï¼ˆéæ­¥éª¤ï¼‰ |

#### 5. æ¶ˆæ¯æµå’Œå¼‚æ­¥å¤„ç†

**æ¶ˆæ¯æ ‡ç­¾åè®®**ï¼š
```lua
tags = {
    [messaging.X_TAGS.SAGA_ID] = tostring(saga_id),                    -- Sagaå®ä¾‹ID
    [messaging.X_TAGS.RESPONSE_ACTION] = callback_action,              -- å›è°ƒåŠ¨ä½œ
    Action = service_action,                                           -- ä¸šåŠ¡åŠ¨ä½œ
}
```

**å¼‚æ­¥å›è°ƒæ¨¡å¼**ï¼š
1. å‘é€è¯·æ±‚æ¶ˆæ¯åˆ°å¤–éƒ¨æœåŠ¡
2. æœåŠ¡å¼‚æ­¥å¤„ç†å¹¶å›å¤
3. é€šè¿‡`X-SagaId`å’Œ`X-ResponseAction`è·¯ç”±å›æ­£ç¡®çš„Sagaå®ä¾‹å’Œå›è°ƒå‡½æ•°
4. å›è°ƒå‡½æ•°å¤„ç†å“åº”å¹¶å†³å®šä¸‹ä¸€æ­¥åŠ¨ä½œ

#### 6. é”™è¯¯å¤„ç†å’Œè¡¥å¿æœºåˆ¶

**é”™è¯¯åˆ†ç±»**ï¼š
- **ä¸šåŠ¡é”™è¯¯**ï¼šå¤–éƒ¨æœåŠ¡è¿”å›`{error: "message"}`ï¼Œè§¦å‘å›æ»š
- **æœ¬åœ°é”™è¯¯**ï¼š`invokeLocal`å‡½æ•°æŠ›å‡ºå¼‚å¸¸ï¼Œè§¦å‘è¡¥å¿
- **æ¶ˆæ¯é”™è¯¯**ï¼šæ­¥éª¤çŠ¶æ€ä¸åŒ¹é…ï¼ŒæŠ›å‡º`INVALID_MESSAGE`

**è¡¥å¿æ‰§è¡Œ**ï¼š
- åŸºäº`compensating`æ ‡å¿—æ”¹å˜æ‰§è¡Œæ–¹å‘
- é€†åºæ‰§è¡Œå·²è®°å½•çš„è¡¥å¿é€»è¾‘
- æ”¯æŒéƒ¨åˆ†è¡¥å¿ï¼ˆ`rollback_saga_instance`çš„å‚æ•°æ§åˆ¶ï¼‰

#### 7. ä¸šåŠ¡é€»è¾‘å®ç°æ¨¡å¼

åŸºäº`inventory_service_local.lua`çš„ä¸šåŠ¡é€»è¾‘ç»“æ„ï¼š

```lua
-- è¯·æ±‚å‡†å¤‡å‡½æ•°
function process_inventory_surplus_or_shortage_prepare_get_inventory_item_request(context)
    -- å‡†å¤‡å‘é€ç»™å¤–éƒ¨æœåŠ¡çš„è¯·æ±‚æ•°æ®
    return {
        product_id = context.product_id,
        location = context.location
    }
end

-- å“åº”å¤„ç†å‡½æ•°
function process_inventory_surplus_or_shortage_on_get_inventory_item_reply(context, result)
    -- å¤„ç†å¤–éƒ¨æœåŠ¡å“åº”
    context.item_version = result.version
    -- ä¸šåŠ¡é€»è¾‘å¤„ç†...
end

-- æœ¬åœ°ä¸šåŠ¡å‡½æ•°
function process_inventory_surplus_or_shortage_do_something_locally(context)
    -- æœ¬åœ°ä¸šåŠ¡é€»è¾‘ï¼Œè¿”å›ç»“æœå’Œcommitå‡½æ•°
    return result, function() /* commité€»è¾‘ */ end
end

-- è¡¥å¿å‡½æ•°
function process_inventory_surplus_or_shortage_compensate_do_something_locally(context)
    -- è¡¥å¿é€»è¾‘
    return result, function() /* commité€»è¾‘ */ end
end
```

### ç°æœ‰å®ç°çš„ä¼˜åŠ¿å’Œé™åˆ¶

#### ä¼˜åŠ¿
1. **ä¸¥æ ¼çš„ç¡®å®šæ€§**ï¼š`current_step`ç¡®ä¿æ‰§è¡Œé¡ºåºçš„ç¡®å®šæ€§
2. **å®Œæ•´çš„è¡¥å¿æ”¯æŒ**ï¼šé€†åºè¡¥å¿ç¡®ä¿æ•°æ®ä¸€è‡´æ€§
3. **å¼‚æ­¥æ¶ˆæ¯é©±åŠ¨**ï¼šå¤©ç„¶æ”¯æŒAOçš„å¼‚æ­¥ç¼–ç¨‹æ¨¡å‹
4. **çŠ¶æ€æŒä¹…åŒ–**ï¼šSagaçŠ¶æ€åœ¨AOä¸­æŒä¹…ä¿å­˜
5. **é”™è¯¯éš”ç¦»**ï¼šå•ä¸ªæ­¥éª¤å¤±è´¥ä¸å½±å“å…¶ä»–Sagaå®ä¾‹

#### é™åˆ¶
1. **ä¸æ”¯æŒç­‰å¾…å¤–éƒ¨äº‹ä»¶**ï¼šåªèƒ½ç­‰å¾…é¢„å®šä¹‰çš„å›è°ƒå“åº”
2. **æ­¥éª¤é¡ºåºå›ºå®š**ï¼šæ— æ³•æ ¹æ®å¤–éƒ¨æ¡ä»¶åŠ¨æ€è°ƒæ•´æ‰§è¡Œé¡ºåº
3. **æ— æ¡ä»¶åˆ†æ”¯**ï¼šä¸æ”¯æŒåŸºäºä¸šåŠ¡é€»è¾‘çš„æ¡ä»¶æ‰§è¡Œ
4. **æ‰©å±•æ€§æœ‰é™**ï¼šæ·»åŠ æ–°æ­¥éª¤ç±»å‹éœ€è¦ä¿®æ”¹ä»£ç ç”Ÿæˆå™¨

### å¯¹waitForEventæ‰©å±•çš„å¯ç¤º

åŸºäºå¯¹ç°æœ‰å®ç°çš„æ·±å…¥ç†è§£ï¼Œæˆ‘ä»¬å¯ä»¥æ›´å‡†ç¡®åœ°è®¾è®¡`waitForEvent`æ‰©å±•ï¼š

1. **ä¿æŒcurrent_stepè¯­ä¹‰**ï¼šwaitForEventæ­¥éª¤ä»ç„¶å ç”¨æ•°å­—æ­¥éª¤ç´¢å¼•
2. **æ‰©å±•æ¶ˆæ¯å¤„ç†**ï¼šæ·»åŠ ä¸“é—¨çš„äº‹ä»¶è§¦å‘æ¶ˆæ¯å¤„ç†å™¨
3. **å¢å¼ºçŠ¶æ€ç®¡ç†**ï¼šåœ¨Sagaå®ä¾‹ä¸­æ·»åŠ ç­‰å¾…çŠ¶æ€å­—æ®µ
4. **å…¼å®¹è¡¥å¿æœºåˆ¶**ï¼šç¡®ä¿ç­‰å¾…æ­¥éª¤çš„è¡¥å¿é€»è¾‘ä¸å…¶ä»–æ­¥éª¤ä¸€è‡´

ç°åœ¨æˆ‘ä»¬å¯¹ç°æœ‰DDDML Sagaå®ç°æœ‰äº†å…¨é¢çš„ç†è§£ï¼Œè¿™ä¸ºæå‡ºå‡†ç¡®çš„æ”¹è¿›å»ºè®®å¥ å®šäº†åŸºç¡€ã€‚

## é‡æ–°å®¡è§†DDDML Sagaçš„å¼‚æ­¥èƒ½åŠ›

### å½“å‰Sagaå·²ç»æ˜¯å¼‚æ­¥çš„

è®©æˆ‘ä»¬é‡æ–°å®¡è§†DDDML Sagaçš„å¼‚æ­¥ç‰¹æ€§ï¼š

```yaml
# å½“å‰DDDML Sagaæ­¥éª¤å®šä¹‰ï¼ˆå·²ç»æ˜¯å¼‚æ­¥çš„ï¼‰
steps:
  GetInventoryItem:
    invokeParticipant: "InventoryItem.GetInventoryItem"
    onReply: "handle_inventory_response"  # å¼‚æ­¥å›è°ƒï¼
  CreateSingleLineInOut:
    invokeParticipant: "InOut.CreateSingleLineInOut"
    exportVariables:
      InOutId: ".InOutId"
    withCompensation: "InOut.VoidInOut"
    compensationArguments:
      InOutId: "InOutId"
```

**å…³é”®ç‚¹**ï¼š
- `invokeParticipant`å‘é€å¼‚æ­¥æ¶ˆæ¯
- `onReply`å®šä¹‰å¼‚æ­¥å“åº”å¤„ç†
- `withCompensation`å®šä¹‰è¡¥å¿é€»è¾‘
- è¿™å·²ç»æ˜¯å®Œæ•´çš„å¼‚æ­¥æ¶ˆæ¯é©±åŠ¨æ¨¡å¼ï¼

### AOå¹³å°çš„æ¶ˆæ¯é©±åŠ¨æœ¬è´¨

AOçš„ç¼–ç¨‹æ¨¡å‹ç¡®å®æ˜¯å¼‚æ­¥æ¶ˆæ¯é©±åŠ¨çš„ï¼š
- æ‰€æœ‰åˆçº¦é€šä¿¡éƒ½æ˜¯é€šè¿‡å¼‚æ­¥æ¶ˆæ¯
- æ¶ˆæ¯å¤„ç†æ˜¯äº‹ä»¶é©±åŠ¨çš„
- çŠ¶æ€æ›´æ–°æ˜¯æ¶ˆæ¯è§¦å‘çš„

DDDML Sagaåªæ˜¯åœ¨è¿™ä¸ªå¼‚æ­¥åŸºç¡€ä¸Šæ·»åŠ äº†ç¼–æ’é€»è¾‘ã€‚

### å½“å‰æœºåˆ¶çš„å±€é™æ€§ä¸æ‰©å±•éœ€æ±‚

**å½“å‰DDDML Sagaæœºåˆ¶çš„å±€é™æ€§**ï¼š

è™½ç„¶DDDML Sagaå·²ç»æ˜¯å¼‚æ­¥æ¶ˆæ¯é©±åŠ¨çš„ï¼Œä½†å®ƒåªèƒ½å¤„ç†**é¢„å®šä¹‰çš„æœåŠ¡è°ƒç”¨å“åº”**ã€‚å…·ä½“æ¥è¯´ï¼š

```yaml
# âœ… å½“å‰æ”¯æŒï¼šç­‰å¾…é¢„å®šä¹‰çš„æœåŠ¡å“åº”
steps:
  Step1:
    invokeParticipant: "InventoryItem.GetInventoryItem"  # å‘é€æŸ¥è¯¢è¯·æ±‚
    onReply: "handle_response"                           # ç­‰å¾…å¹¶å¤„ç†å“åº”
```

**å®é™…ä¸šåŠ¡åœºæ™¯çš„éœ€æ±‚**ï¼š

è®¸å¤šç°å®ä¸šåŠ¡åœºæ™¯éœ€è¦ç­‰å¾…**ä»»æ„å¤–éƒ¨äº‹ä»¶**ï¼Œè€Œä¸ä»…ä»…æ˜¯é¢„å®šä¹‰çš„æœåŠ¡å“åº”ï¼š

```yaml
# âŒ å½“å‰ä¸æ”¯æŒï¼šç­‰å¾…ä»»æ„å¤–éƒ¨äº‹ä»¶
steps:
  Step2:
    waitForEvent: "payment_completed"     # ç­‰å¾…æ”¯ä»˜å®Œæˆäº‹ä»¶
    eventFilter: "amount >= expected_amount"
    # åŒºå—é“¾å‹å¥½ï¼šæœ€å¤§ç­‰å¾…æ—¶é—´
    maxWaitTime: "30m"
```

**ä¸ºä»€ä¹ˆéœ€è¦æ‰©å±•DDDMLè§„èŒƒï¼Ÿ**

1. **ä¸šåŠ¡åœºæ™¯é©±åŠ¨**ï¼šç”µå•†æ”¯ä»˜ã€ç”¨æˆ·å®¡æ‰¹ã€å¤–éƒ¨ç³»ç»Ÿé›†æˆç­‰åœºæ™¯éƒ½éœ€è¦ç­‰å¾…å¤–éƒ¨äº‹ä»¶
2. **æ¶æ„ä¸€è‡´æ€§**ï¼šæ—¢ç„¶AOå·²ç»æ˜¯æ¶ˆæ¯é©±åŠ¨çš„ï¼Œä¸ºä»€ä¹ˆä¸èƒ½ä¼˜é›…åœ°æ”¯æŒä»»æ„å¤–éƒ¨äº‹ä»¶ï¼Ÿ
3. **å¼€å‘æ•ˆç‡**ï¼šé¿å…å¼€å‘è€…ç»•è¿‡DDDML Sagaæœºåˆ¶ï¼Œä½¿ç”¨åŸç”ŸAOæ¶ˆæ¯å¤„ç†

**æ‰©å±•çš„ç›®æ ‡**ï¼š
- åœ¨ä¿æŒç°æœ‰Sagaæœºåˆ¶ä¸å˜çš„å‰æä¸‹
- ä¼˜é›…åœ°æ·»åŠ å¯¹å¤–éƒ¨äº‹ä»¶çš„ç­‰å¾…æ”¯æŒ
- å……åˆ†åˆ©ç”¨ç°æœ‰çš„DDDMLè¯­æ³•å…ƒç´ 
- å®Œå…¨å…¼å®¹åŒºå—é“¾çš„ç¡®å®šæ€§ç‰¹æ€§

è¿™ç¡®å®æ˜¯ä¸€ä¸ª**è§„èŒƒæ‰©å±•é—®é¢˜**ï¼Œè€Œä¸æ˜¯æ¶æ„é‡æ„é—®é¢˜ï¼

## DDDMLè§„èŒƒæ‰©å±•çš„å¯è¡Œæ€§åˆ†æ

### å½“å‰Sagaçš„å¼‚æ­¥èƒ½åŠ›

ç»è¿‡é‡æ–°å®¡è§†ï¼Œå½“å‰DDDML Sagaç¡®å®å·²ç»æ˜¯å¼‚æ­¥çš„ï¼š

1. **æ¶ˆæ¯é©±åŠ¨**ï¼š`invokeParticipant`å‘é€å¼‚æ­¥æ¶ˆæ¯
2. **å›è°ƒå¤„ç†**ï¼š`onReply`å¤„ç†å¼‚æ­¥å“åº”
3. **çŠ¶æ€æŒä¹…åŒ–**ï¼šSagaçŠ¶æ€åœ¨æ¶ˆæ¯å¤„ç†é—´ä¿æŒ

### æ‰©å±•waitForEventçš„å¯è¡Œæ€§

ç»è¿‡æ·±å…¥åˆ†æç°æœ‰DDDML Sagaå®ç°å’ŒåŒºå—é“¾ç¯å¢ƒçº¦æŸï¼Œæˆ‘ä»¬è®¤ä¸ºæ‰©å±•æ”¯æŒ`waitForEvent`æ­¥éª¤ç±»å‹æ˜¯å®Œå…¨å¯è¡Œçš„ã€‚ä»¥ä¸‹æ˜¯è¯¦ç»†çš„è®¾è®¡è€ƒé‡å’Œå†³ç­–ä¾æ®ï¼š

#### è¯­æ³•è®¾è®¡å“²å­¦ï¼šå……åˆ†åˆ©ç”¨ç°æœ‰DDDMLè¯­æ³•å…ƒç´ 

**æ ¸å¿ƒè®¾è®¡åŸåˆ™**ï¼šé¿å…å‘æ˜ä¸å¿…è¦çš„æ–°è¯­æ³•ï¼Œå……åˆ†åˆ©ç”¨DDDMLç°æœ‰çš„æˆç†Ÿè¯­æ³•æœºåˆ¶ã€‚

```yaml
# âŒ è¿‡åº¦è®¾è®¡çš„æ—§æ–¹æ¡ˆï¼ˆå·²è¢«æ‘’å¼ƒï¼‰
steps:
  WaitForPayment:
    waitForEvent: "payment_completed"
    eventDataMapping:                      # âŒ æ–°å‘æ˜è¯­æ³•
      actual_amount: ".data.amount"   # âŒ ä¸å¿…è¦çš„å¤æ‚æ€§
      transaction_id: ".data.transaction_id"
    expectedEvents: ["payment_completed", "payment_failed"]  # âŒ é‡å¤å£°æ˜
    timeout: "30m"                         # âŒ ä¸»åŠ¨è¶…æ—¶æœºåˆ¶
    onTimeout: "cancel_order"              # âŒ å¤æ‚è¡¥å¿é€»è¾‘

# âœ… é‡‡çº³ç”¨æˆ·å»ºè®®ï¼šç§»é™¤eventFilterï¼Œä½¿ç”¨onSuccessä¿æŒä¸€è‡´æ€§
steps:
  WaitForPayment:
    waitForEvent: "payment_completed"      # ç­‰å¾…æˆåŠŸäº‹ä»¶
    # eventFilter: "amount >= expected_amount and order_id == context.order_id"
    # NOTE ä¸ä½¿ç”¨ eventFilterï¼Œè€Œæ˜¯ä½¿ç”¨ onSuccess æ¥å¤„ç†æˆåŠŸäº‹ä»¶ï¼ŒåŒ…æ‹¬å¯ä»¥æ‰§è¡Œè¿‡æ»¤é€»è¾‘
    onSuccess:
      Lua: "-- å¤„ç†æ”¯ä»˜æˆåŠŸé€»è¾‘"              # æ”¶åˆ°æˆåŠŸäº‹ä»¶æ—¶æ‰§è¡Œæœ¬åœ°ä»£ç 
    exportVariables:                       # ä½¿ç”¨ç°æœ‰è¯­æ³•æ˜ å°„äº‹ä»¶æ•°æ®
      actual_amount:
        extractionPath: ".data.amount"
      transaction_id:
        extractionPath: ".data.transaction_id"
      payment_timestamp:
        extractionPath: ".data.completed_at"
    failureEvent: "payment_failed"         # å£°æ˜å¤±è´¥äº‹ä»¶åï¼ˆä¸€è‡´æ€§å‘½åï¼‰
    onFailure:                             # æ”¶åˆ°å¤±è´¥äº‹ä»¶æ—¶æ‰§è¡Œæœ¬åœ°ä»£ç ï¼ˆéµå¾ªonReplyæ¨¡å¼ï¼‰
      Lua: "-- å¤„ç†æ”¯ä»˜å¤±è´¥é€»è¾‘"
    maxWaitTime: "30m"                     # åŒºå—é“¾å‹å¥½ï¼šæœ€å¤§ç­‰å¾…æ—¶é—´
    withCompensation: "refund_payment"     # ç°æœ‰è¡¥å¿è¯­æ³•
```

#### ä¸ºä»€ä¹ˆè¿™ä¹ˆè®¾è®¡ï¼Ÿè¯¦ç»†è€ƒé‡

##### 1. ç§»é™¤`eventDataMapping`ï¼Œæ”¹ç”¨`exportVariables`

**ç†ç”±åˆ†æ**ï¼š
- **è¯­æ³•ä¸€è‡´æ€§**ï¼š`exportVariables`å·²ç»æ˜¯DDDMLä¸­æˆç†Ÿçš„è¯­æ³•ï¼Œç”¨äºä»å“åº”ä¸­æå–æ•°æ®åˆ°Sagaä¸Šä¸‹æ–‡
- **é¿å…å‘æ˜æ–°è¯­æ³•**ï¼šæ²¡æœ‰å¿…è¦ä¸ºäº‹ä»¶æ•°æ®æ˜ å°„å‘æ˜å…¨æ–°çš„è¯­æ³•å…ƒç´ 
- **åŠŸèƒ½ç­‰ä»·æ€§**ï¼š`exportVariables`çš„`extractionPath`åŠŸèƒ½å®Œå…¨å¯ä»¥æ»¡è¶³äº‹ä»¶æ•°æ®æ˜ å°„çš„éœ€æ±‚
- **å­¦ä¹ æˆæœ¬**ï¼šå¼€å‘è€…ä¸éœ€è¦å­¦ä¹ æ–°çš„è¯­æ³•æ¦‚å¿µ

**å…·ä½“å®ç°**ï¼š
```yaml
exportVariables:
  actual_amount:
    extractionPath: ".data.amount"    # ä»äº‹ä»¶æ•°æ®ä¸­æå–
  transaction_id:
    extractionPath: ".data.transaction_id"
```

##### 2. ç§»é™¤`eventFilter`ï¼Œä½¿ç”¨`onSuccess`ä¿æŒä¸€è‡´æ€§

**eventFilterè¯­ä¹‰çš„å›°å¢ƒ**ï¼š
æˆ‘ä»¬æœ€åˆè€ƒè™‘`eventFilter`æœ‰ä¸¤ä¸ªé€‰é¡¹ï¼š
1. **è¿‡æ»¤æ‰€æœ‰äº‹ä»¶**ï¼šç»Ÿä¸€å¤„ç†æˆåŠŸå’Œå¤±è´¥äº‹ä»¶çš„è¿‡æ»¤
2. **åªè¿‡æ»¤æˆåŠŸäº‹ä»¶**ï¼šä¸“é—¨è¿‡æ»¤æˆåŠŸäº‹ä»¶

**é—®é¢˜åˆ†æ**ï¼š
- é€‰é¡¹1ï¼šè¯­ä¹‰ä¸æ¸…æ™°ï¼Œç”¨æˆ·å®¹æ˜“å›°æƒ‘"ä¸ºä»€ä¹ˆå¤±è´¥äº‹ä»¶ä¹Ÿéœ€è¦è¿‡æ»¤ï¼Ÿ"
- é€‰é¡¹2ï¼šè™½ç„¶è¯­ä¹‰æ¸…æ™°ï¼Œä½†æ‰“ç ´äº†DDDMLçš„`onXxx`å¤„ç†æ¨¡å¼

**æ‚¨çš„æ´å¯Ÿ**ï¼š
æ‚¨æŒ‡å‡ºä½¿ç”¨`onSuccess`å¤„ç†æˆåŠŸäº‹ä»¶ï¼ˆåŒ…æ‹¬è¿‡æ»¤é€»è¾‘ï¼‰æ›´æœ‰ä¸€è‡´æ€§ï¼

**æœ€ç»ˆè®¾è®¡å†³ç­–**ï¼š
- ç§»é™¤ç‹¬ç«‹çš„`eventFilter`å…³é”®å­—ï¼ˆè¯­ä¹‰ä¸æ¸…ï¼‰
- ä½¿ç”¨`onSuccess`å¤„ç†æˆåŠŸäº‹ä»¶ï¼ŒåŒ…æ‹¬è¿‡æ»¤é€»è¾‘
- ä¿ç•™`exportVariables`ç”¨äºæ•°æ®æ˜ å°„
- å®Œç¾ç¬¦åˆDDDMLç°æœ‰çš„ `å£°æ˜` + `onXxxå¤„ç†` æ¨¡å¼

##### 3. åŒºå—é“¾å‹å¥½çš„è¶…æ—¶æœºåˆ¶è®¾è®¡

**æ ¸å¿ƒé—®é¢˜**ï¼šAOåŒºå—é“¾æ²¡æœ‰ä¸»åŠ¨å®šæ—¶å™¨æœºåˆ¶ï¼Œæ‰€æœ‰æ“ä½œéƒ½å¿…é¡»é€šè¿‡æ¶ˆæ¯é©±åŠ¨ã€‚

**ä¼ ç»ŸWeb2æ€è·¯çš„å±€é™æ€§**ï¼š
```yaml
# âŒ é”™è¯¯çš„ä¼ ç»Ÿæ€è·¯
timeout: "30m"              # å‡è®¾ç³»ç»Ÿå¯ä»¥ä¸»åŠ¨è§¦å‘è¶…æ—¶
onTimeout: "cancel_order"   # å‡è®¾æœ‰å†…ç½®çš„è¶…æ—¶è¡¥å¿æœºåˆ¶
```

**åŒºå—é“¾å‹å¥½çš„æ­£ç¡®è®¾è®¡**ï¼š
```yaml
# âœ… åŒºå—é“¾å‹å¥½çš„è®¾è®¡
maxWaitTime: "30m"          # å£°æ˜æœ€å¤§ç­‰å¾…æ—¶é—´
# è¶…æ—¶è¡¥å¿é€šè¿‡å¤–éƒ¨ç›‘æ§ç³»ç»Ÿè§¦å‘ï¼Œä¸åœ¨Sagaå†…éƒ¨å¤„ç†
```

**å®æ–½æœºåˆ¶**ï¼š
1. **å¤–éƒ¨ç›‘æ§**ï¼šç‹¬ç«‹çš„ç›‘æ§è¿›ç¨‹å®šæœŸæ£€æŸ¥Sagaç­‰å¾…çŠ¶æ€
2. **çŠ¶æ€æŸ¥è¯¢**ï¼šç›‘æ§è¿›ç¨‹æŸ¥è¯¢`waiting_state.started_at`å’Œ`maxWaitTime`
3. **è¡¥å¿è§¦å‘**ï¼šå½“å‘ç°è¶…æ—¶ï¼Œå‘Sagaå‘é€`Saga_TimeoutTriggered`æ¶ˆæ¯
4. **è¢«åŠ¨å“åº”**ï¼šSagaæ¥æ”¶è¡¥å¿æ¶ˆæ¯ï¼Œæ‰§è¡Œè¡¥å¿é€»è¾‘

**ä¸ºä»€ä¹ˆè¿™ä¹ˆè®¾è®¡**ï¼š
- **åŒºå—é“¾ç¡®å®šæ€§**ï¼šé¿å…è¿ååŒºå—é“¾çš„ç¡®å®šæ€§ç‰¹æ€§
- **æ¶ˆæ¯é©±åŠ¨**ï¼šæ‰€æœ‰æ“ä½œéƒ½é€šè¿‡æ¶ˆæ¯æœºåˆ¶å®Œæˆ
- **å¤–éƒ¨æ§åˆ¶**ï¼šè¶…æ—¶è¡¥å¿é€»è¾‘ç”±å¤–éƒ¨ç³»ç»Ÿæ§åˆ¶ï¼Œæ›´çµæ´»
- **é”™è¯¯å‡å°‘**ï¼šé¿å…å¤æ‚çš„å†…ç½®è¶…æ—¶è¡¥å¿é€»è¾‘å‡ºé”™

##### 4. å…³äºå¤±è´¥äº‹ä»¶å¤„ç†çš„æ·±åº¦è€ƒé‡

**ç”¨æˆ·çš„æ·±åˆ»æ´å¯Ÿ**ï¼š
> å…³äº timeout äº‹ä»¶çš„å¤„ç†å¿…é¡»éå¸¸éå¸¸è°¨æ…ï¼åœ¨ timeout å‘ç”Ÿçš„æ—¶å€™ï¼Œå¿…é¡»è¦å°å¿ƒéªŒè¯æ”¯ä»˜è¿‡ç¨‹çš„æœ€ç»ˆç»“æœï¼Œç¡®ä¿æ”¯ä»˜æ˜¯çœŸçš„å¤±è´¥äº†ï¼Œè€Œä¸æ˜¯å¤„äº"å¤„ç†ä¸­"ä¹‹ç±»çš„ä¸­é—´çŠ¶æ€ã€‚

**è®¾è®¡è€ƒé‡**ï¼š
1. **çŠ¶æ€ä¸ç¡®å®šæ€§**ï¼šåœ¨ AO çš„æ¶ˆæ¯é©±åŠ¨ç¯å¢ƒä¸‹ï¼Œæ”¶åˆ°ä¸€ä¸ª"è¶…æ—¶"äº‹ä»¶å¹¶ä¸æ„å‘³ç€"å¤±è´¥"
2. **ä¸­é—´çŠ¶æ€é£é™©**ï¼šæ”¯ä»˜å¯èƒ½è¿˜åœ¨å¤„ç†ä¸­ï¼Œåªæ˜¯æš‚æ—¶æ²¡æœ‰å®Œæˆ
3. **è¿‡åº¦è¡¥å¿é£é™©**ï¼šå¦‚æœè¡¥å¿äº†å®é™…ä¸Šè¿˜åœ¨è¿›è¡Œçš„æ“ä½œï¼Œä¼šé€ æˆæ•°æ®ä¸ä¸€è‡´

**ç®€åŒ–å†³ç­–**ï¼š
- **å•ä¸€å¤±è´¥äº‹ä»¶**ï¼šåªæ”¯æŒ`onFailureEvent`ï¼Œä¸åŒºåˆ†timeoutå’Œæ™®é€šå¤±è´¥
- **å¤–éƒ¨éªŒè¯**ï¼šè¶…æ—¶è¡¥å¿çš„ä¸šåŠ¡é€»è¾‘éªŒè¯äº¤ç»™å¤–éƒ¨ç³»ç»Ÿå¤„ç†
- **ä¿å®ˆç­–ç•¥**ï¼šå®å¯ç­‰å¾…æ›´ä¹…ï¼Œä¹Ÿä¸è¦é”™è¯¯è¡¥å¿

**å®æ–½å»ºè®®**ï¼š
```lua
-- å¤–éƒ¨ç›‘æ§ç³»ç»Ÿä¸­çš„è¶…æ—¶å¤„ç†é€»è¾‘
function check_and_handle_timeout(saga_id)
    local saga = get_saga_instance(saga_id)

    if not saga.waiting_state then
        return false  -- ä¸åœ¨ç­‰å¾…çŠ¶æ€
    end

    -- æ£€æŸ¥æ˜¯å¦çœŸçš„è¶…æ—¶
    local wait_time = os.time() - saga.waiting_state.started_at
    if wait_time > saga.waiting_state.max_wait_time_seconds then
        -- è¿›ä¸€æ­¥éªŒè¯æ”¯ä»˜çŠ¶æ€ï¼ˆæŸ¥è¯¢æ”¯ä»˜ç½‘å…³ï¼‰
        local payment_status = check_payment_status(saga.context.transaction_id)

        if payment_status == "completed" then
            -- æ”¯ä»˜å·²å®Œæˆï¼Œä½†äº‹ä»¶è¿˜æ²¡åˆ°è¾¾ï¼Œç­‰å¾…æ›´ä¹…
            return false
        elseif payment_status == "failed" then
            -- æ”¯ä»˜çœŸçš„å¤±è´¥äº†ï¼Œè§¦å‘è¡¥å¿
            trigger_saga_compensation(saga_id, "payment_failed")
            return true
        else
            -- çŠ¶æ€ä¸ç¡®å®šï¼Œç»§ç»­ç­‰å¾…
            return false
        end
    end

    return false
end
```

#### å®æ–½å¯è¡Œæ€§è¯„ä¼°

**æŠ€æœ¯å¯è¡Œæ€§ï¼šé«˜**
- âœ… AOå¹³å°åŸç”Ÿæ”¯æŒå¼‚æ­¥æ¶ˆæ¯å¤„ç†
- âœ… ç°æœ‰DDDMLä»£ç ç”Ÿæˆå™¨æ¶æ„æ”¯æŒæ‰©å±•
- âœ… SagaçŠ¶æ€æ¨¡å‹å¯ä»¥å‘åå…¼å®¹åœ°æ‰©å±•

**åŒºå—é“¾å…¼å®¹æ€§ï¼šé«˜**
- âœ… ä¸è¿ååŒºå—é“¾ç¡®å®šæ€§ç‰¹æ€§
- âœ… æ¶ˆæ¯é©±åŠ¨çš„è¶…æ—¶è¡¥å¿æœºåˆ¶
- âœ… å¤–éƒ¨ç›‘æ§ç³»ç»Ÿå¯ä»¥ç‹¬ç«‹æ‰©å±•

**å¼€å‘å¤æ‚åº¦ï¼šä¸­**
- âœ… ä¸»è¦ä¿®æ”¹ä»£ç ç”Ÿæˆå™¨å’Œè¿è¡Œæ—¶åº“
- âœ… ä¸éœ€è¦ä¿®æ”¹åŒºå—é“¾æ ¸å¿ƒåè®®
- âœ… æµ‹è¯•è¦†ç›–ç‡å¯ä»¥è¾¾åˆ°è¾ƒé«˜æ°´å¹³

**ç”¨æˆ·é‡‡ç”¨éš¾åº¦ï¼šä½**
- âœ… åˆ©ç”¨ç°æœ‰DDDMLè¯­æ³•æ¦‚å¿µ
- âœ… ç®€åŒ–çš„APIè®¾è®¡
- âœ… æ¸…æ™°çš„æ–‡æ¡£å’Œç¤ºä¾‹

#### æ¨èå®æ–½æ–¹æ¡ˆ

åŸºäºä»¥ä¸Šåˆ†æï¼Œæˆ‘ä»¬æ¨èé‡‡ç”¨**ç”¨æˆ·å»ºè®®çš„ç®€åŒ–è®¾è®¡æ–¹æ¡ˆ**ï¼š

1. **æ ¸å¿ƒè¯­æ³•å…ƒç´ **ï¼šåªä¿ç•™å¿…è¦çš„å…³é”®å­—
2. **ç°æœ‰è¯­æ³•å¤ç”¨**ï¼šå……åˆ†åˆ©ç”¨`exportVariables`ç­‰æˆç†Ÿè¯­æ³•
3. **åŒºå—é“¾å‹å¥½**ï¼šé¿å…ä¸»åŠ¨å®šæ—¶å™¨ï¼Œä½¿ç”¨å¤–éƒ¨ç›‘æ§è§¦å‘è¡¥å¿
4. **ç®€åŒ–é”™è¯¯å¤„ç†**ï¼šç»Ÿä¸€å¤±è´¥äº‹ä»¶å¤„ç†é€»è¾‘

è¿™ä¸ªæ–¹æ¡ˆæ—¢ä¿æŒäº†åŠŸèƒ½çš„å®Œæ•´æ€§ï¼Œåˆå¤§å¤§é™ä½äº†å®ç°çš„å¤æ‚åº¦å’Œå‡ºé”™é£é™©ï¼Œæ˜¯ä¸€ä¸ªåŠ¡å®ä¸”å¯è¡Œçš„è§£å†³æ–¹æ¡ˆã€‚

### æ¶æ„å…¼å®¹æ€§

å…³é”®é—®é¢˜æ˜¯ï¼š**è¿™æ˜¯å¦ä¸ç°æœ‰çš„SagaçŠ¶æ€æ¨¡å‹å…¼å®¹ï¼Ÿ**

#### æ½œåœ¨æŒ‘æˆ˜
1. **current_stepè¯­ä¹‰**ï¼šwaitForEventæ­¥éª¤å¦‚ä½•æ˜ å°„åˆ°æ•°å­—æ­¥éª¤ï¼Ÿ
2. **è¡¥å¿ç¡®å®šæ€§**ï¼šç­‰å¾…æœŸé—´çš„è¡¥å¿é€»è¾‘å¦‚ä½•å¤„ç†ï¼Ÿ
3. **çŠ¶æ€ä¸€è‡´æ€§**ï¼šç­‰å¾…çŠ¶æ€å¦‚ä½•ä¸ç¡®å®šæ€§æ¨¡å‹å…±å­˜ï¼Ÿ

#### è¡¥å¿æœºåˆ¶é›†æˆè¯´æ˜

**åŒºå—é“¾ç¯å¢ƒä¸‹waitForEventæ­¥éª¤çš„è¡¥å¿å¤„ç†**ï¼š

1. **è¶…æ—¶è¡¥å¿**ï¼šå¤–éƒ¨ç›‘æ§ç³»ç»Ÿå®šæœŸæ£€æŸ¥Sagaç­‰å¾…çŠ¶æ€ï¼Œå½“å‘ç°è¶…æ—¶ï¼Œå‘Sagaå‘é€`Saga_TimeoutTriggered`æ¶ˆæ¯ï¼Œè§¦å‘è¡¥å¿
2. **ä¸»åŠ¨å–æ¶ˆ**ï¼šå½“Sagaå› å…¶ä»–æ­¥éª¤å¤±è´¥éœ€è¦å›æ»šæ—¶ï¼Œå¦‚æœå½“å‰æ­£åœ¨ç­‰å¾…ï¼Œåˆ™ï¼š
   - æ¸…é™¤ç­‰å¾…çŠ¶æ€
   - è®°å½•ç­‰å¾…æ­¥éª¤çš„è¡¥å¿ä¿¡æ¯ï¼ˆå¦‚æœå®šä¹‰äº†`withCompensation`ï¼‰
   - ç»§ç»­æ­£å¸¸çš„é€†åºè¡¥å¿æµç¨‹
3. **ç­‰å¾…æ­¥éª¤æœ¬èº«çš„è¡¥å¿**ï¼šwaitForEventæ­¥éª¤å¯ä»¥å®šä¹‰`withCompensation`ï¼Œåœ¨Sagaå›æ»šæ—¶æ‰§è¡Œç›¸åº”çš„æ¸…ç†é€»è¾‘

**å…³é”®è®¾è®¡å†³ç­–**ï¼š
- waitForEventæ­¥éª¤ä»ç„¶å ç”¨ä¸€ä¸ª`current_step`æ•°å­—ç´¢å¼•
- åœ¨participantsæ•°ç»„ä¸­ä¿ç•™ä½ç½®ï¼Œç¡®ä¿æ•°ç»„ç»“æ„çš„è¿ç»­æ€§
- è¡¥å¿æ—¶æ ¹æ®`current_step`é€†åºæ‰§è¡Œï¼ŒåŒ…æ‹¬ç­‰å¾…æ­¥éª¤çš„è¡¥å¿é€»è¾‘

#### å¯èƒ½çš„è§£å†³æ–¹æ¡ˆ

ç»è¿‡æ·±å…¥æ€è€ƒï¼Œæ‰©å±•DDDMLè§„èŒƒæ”¯æŒ`waitForEvent`æ˜¯å¯è¡Œçš„ï¼š

##### 1. æ‰©å±•çŠ¶æ€æ¨¡å‹
```lua
local saga_instance = {
    -- ç°æœ‰å­—æ®µä¿æŒä¸å˜
    saga_id = saga_id,
    current_step = 2,        -- ä»ç„¶æ˜¯ç¡®å®šæ€§çš„æ•°å­—æ­¥éª¤
    compensating = false,

    -- æ–°å¢ï¼šç­‰å¾…çŠ¶æ€æ‰©å±•
    waiting_state = {
        is_waiting = true,                    -- å½“å‰æ˜¯å¦åœ¨ç­‰å¾…
        event_type = "payment_completed",     -- ç­‰å¾…çš„äº‹ä»¶ç±»å‹
        step_name = "WaitForPayment",         -- å¯¹åº”çš„æ­¥éª¤å
        started_at = os.time(),
        timeout_at = os.time() + 1800,        -- 30åˆ†é’Ÿåè¶…æ—¶
        event_filter = "amount >= expected_amount",
        retry_policy = { max_retries = 3 }
    },

    -- ç°æœ‰å­—æ®µ
    participants = {},
    compensations = {},
    context = context,
}
```

**å…³é”®ç‚¹**ï¼š
- `current_step`ä»ç„¶ä¿æŒç¡®å®šæ€§è¯­ä¹‰
- `waiting_state`ä½œä¸ºæ‰©å±•å­—æ®µï¼Œä¸ç ´åç°æœ‰é€»è¾‘
- ç­‰å¾…æ­¥éª¤ä»ç„¶å ç”¨ä¸€ä¸ª`current_step`æ•°å­—ç´¢å¼•

##### 2. æ­¥éª¤è¯­ä¹‰æ‰©å±•
```yaml
# DDDMLè§„èŒƒæ‰©å±•ï¼ˆä¸€è‡´æ€§å‘½åï¼‰
steps:
  Step1:
    invokeParticipant: "Service.Action"  # æ™®é€šæ­¥éª¤

  WaitForPayment:                        # ç­‰å¾…æ­¥éª¤ï¼ˆä¸€è‡´æ€§è®¾è®¡ï¼‰
    waitForEvent: "payment_completed"      # ç­‰å¾…æˆåŠŸäº‹ä»¶
    onSuccess:                             # æ”¶åˆ°æˆåŠŸäº‹ä»¶æ—¶æ‰§è¡Œæœ¬åœ°ä»£ç ï¼ˆåŒ…æ‹¬è¿‡æ»¤é€»è¾‘ï¼‰
      Lua: |
        -- è¿‡æ»¤å’Œå¤„ç†é€»è¾‘
        if event.data.amount >= context.expected_amount and 
           event.data.order_id == context.order_id then
          return true  -- ç»§ç»­Sagaæ‰§è¡Œ
        else
          return false -- è¿‡æ»¤å¤±è´¥ï¼Œå¿½ç•¥æ­¤äº‹ä»¶
        end
    exportVariables:                       # ä½¿ç”¨ç°æœ‰è¯­æ³•æ˜ å°„äº‹ä»¶æ•°æ®
      actual_amount: ".data.amount"
      transaction_id: ".data.transaction_id"
    failureEvent: "payment_failed"         # å£°æ˜å¤±è´¥äº‹ä»¶åï¼ˆä¸€è‡´æ€§å‘½åï¼‰
    onFailure:                             # æ”¶åˆ°å¤±è´¥äº‹ä»¶æ—¶æ‰§è¡Œæœ¬åœ°ä»£ç ï¼ˆéµå¾ªonReplyæ¨¡å¼ï¼‰
      Lua: "-- å¤„ç†æ”¯ä»˜å¤±è´¥é€»è¾‘"
    maxWaitTime: "30m"                     # åŒºå—é“¾å‹å¥½ï¼šæœ€å¤§ç­‰å¾…æ—¶é—´
    withCompensation: "refund_payment"     # è¡¥å¿é€»è¾‘

  Step3:
    invokeLocal: "process_payment"       # åç»­æ­¥éª¤
```

##### 3. è¡¥å¿é€»è¾‘é€‚é…ï¼ˆä¸€è‡´æ€§è®¾è®¡ï¼‰
ç­‰å¾…æ­¥éª¤çš„è¡¥å¿é€»è¾‘ï¼š
- **å¤±è´¥è¡¥å¿**ï¼šå½“æ¥æ”¶åˆ°`failureEvent`å£°æ˜çš„äº‹ä»¶æ—¶ï¼Œæ¸…é™¤ç­‰å¾…çŠ¶æ€å¹¶æ‰§è¡Œè¡¥å¿
- **ä¸»åŠ¨å–æ¶ˆ**ï¼šSagaå›æ»šæ—¶ï¼Œæ¸…é™¤ç­‰å¾…çŠ¶æ€å¹¶æ‰§è¡Œç›¸åº”è¡¥å¿
- **çŠ¶æ€ä¸€è‡´æ€§**ï¼šç¡®ä¿ç­‰å¾…æ­¥éª¤çš„è¡¥å¿ä¸æ™®é€šæ­¥éª¤çš„è¡¥å¿é€»è¾‘ä¸€è‡´

**å‘½åä¸€è‡´æ€§è€ƒé‡**ï¼š
- `onSuccess` å’Œ `onFailure` å®Œå…¨éµå¾ªDDDMLç°æœ‰çš„ `onReply` æ¨¡å¼
- `waitForEvent` å’Œ `failureEvent` åªå£°æ˜äº‹ä»¶ç±»å‹ï¼Œä¸æ¶‰åŠå¤„ç†é€»è¾‘
- ç§»é™¤äº†å¤æ‚çš„ä¸»åŠ¨è¶…æ—¶æœºåˆ¶ï¼Œé‡‡ç”¨å¤–éƒ¨ç›‘æ§è§¦å‘çš„è¢«åŠ¨è¡¥å¿æ–¹å¼

**æœ€ç»ˆå‘½åæ¨¡å¼ï¼ˆæ‚¨çš„å»ºè®®å®Œå…¨æ­£ç¡®ï¼‰**ï¼š
- `waitForEvent: "success_event"` - å£°æ˜ç­‰å¾…çš„æˆåŠŸäº‹ä»¶ç±»å‹
- `onSuccess:` - å¤„ç†æˆåŠŸäº‹ä»¶ï¼ˆåŒ…æ‹¬è¿‡æ»¤ã€æ•°æ®æ˜ å°„ç­‰ï¼‰âœ…
- `failureEvent: "failure_event"` - å£°æ˜å¤±è´¥äº‹ä»¶ç±»å‹
- `onFailure:` - å¤„ç†å¤±è´¥äº‹ä»¶
- **å®Œå…¨ç¬¦åˆDDDMLçš„ `å£°æ˜` + `onXxxå¤„ç†` æ¨¡å¼ï¼**

**æ„Ÿè°¢æ‚¨çš„æ´å¯Ÿ**ï¼š
æ‚¨çš„å»ºè®®å®Œç¾è§£å†³äº†`eventFilter`è¯­ä¹‰ä¸æ¸…çš„é—®é¢˜ã€‚é€šè¿‡`onSuccess`å¤„ç†æˆåŠŸäº‹ä»¶ï¼Œæ—¢ä¿æŒäº†ä¸€è‡´æ€§ï¼Œåˆæä¾›äº†çµæ´»çš„è¿‡æ»¤åŠŸèƒ½ã€‚è¿™ä¸ªè®¾è®¡æ¯”æˆ‘æœ€åˆçš„`eventFilter`æ–¹æ¡ˆä¼˜é›…å¾—å¤šï¼

### å®ç°å¯è¡Œæ€§è¯„ä¼°

#### æŠ€æœ¯å¯è¡Œæ€§ï¼šé«˜
- AOå¹³å°åŸç”Ÿæ”¯æŒå¼‚æ­¥æ¶ˆæ¯
- å½“å‰DDDMLä»£ç ç”Ÿæˆå™¨æ¶æ„æ”¯æŒæ‰©å±•
- SagaçŠ¶æ€æ¨¡å‹å¯ä»¥å‘åå…¼å®¹åœ°æ‰©å±•

#### æ¶æ„å…¼å®¹æ€§ï¼šä¸­
- éœ€è¦æ‰©å±•SagaçŠ¶æ€æ¨¡å‹
- éœ€è¦ä¿®æ”¹æ¶ˆæ¯å¤„ç†é€»è¾‘
- éœ€è¦ç¡®ä¿å‘åå…¼å®¹æ€§

#### å¼€å‘å¤æ‚åº¦ï¼šä¸­
- éœ€è¦ä¿®æ”¹ä»£ç ç”Ÿæˆå™¨
- éœ€è¦æ‰©å±•è¿è¡Œæ—¶åº“
- éœ€è¦å®Œå–„çš„æµ‹è¯•è¦†ç›–

### æ¨èå®æ–½æ–¹æ¡ˆ

åŸºäºä»¥ä¸Šåˆ†æï¼Œ**æ‰©å±•DDDMLè§„èŒƒæ”¯æŒwaitForEventæ˜¯å¯è¡Œçš„**ï¼Œè¿™ç¡®å®æ˜¯ä¸€ä¸ªè§„èŒƒæ”¹è¿›é—®é¢˜ï¼Œè€Œä¸æ˜¯æ¶æ„é™åˆ¶ã€‚

## åŸºäºæ·±å…¥åˆ†æçš„æ”¹è¿›å»ºè®®

åŸºäºå¯¹ç°æœ‰DDDML Sagaå®ç°çš„å…¨é¢åˆ†æï¼Œæˆ‘ä»¬å¯ä»¥æå‡ºä¸€ä¸ªæ›´å‡†ç¡®å’Œå¯è¡Œçš„`waitForEvent`æ‰©å±•æ–¹æ¡ˆã€‚è¿™ä¸ªæ–¹æ¡ˆå……åˆ†è€ƒè™‘äº†ç°æœ‰æ¶æ„çš„çº¦æŸå’Œä¼˜åŠ¿ã€‚

### é‡æ–°è®¾è®¡çš„waitForEventæ‰©å±•æ–¹æ¡ˆ

#### 1. æ‰©å±•DDDMLè§„èŒƒè¯­æ³•

```yaml
# æ‰©å±•åçš„DDDMLè§„èŒƒï¼Œä¿æŒä¸ç°æœ‰stepsç»“æ„å…¼å®¹
services:
  EcommercePaymentService:
    methods:
      ProcessOrderPayment:
        parameters:
          order_id: number
          customer_id: string
          expected_amount: number
        steps:
          # æ­¥éª¤1ï¼šæ³¨å†Œæ”¯ä»˜æ„å‘ï¼ˆç°æœ‰è¯­æ³•ï¼Œä¿æŒä¸å˜ï¼‰
          RegisterPaymentIntent:
            invokeLocal: "register_payment_intent"
            description: "åˆå§‹åŒ–æ”¯ä»˜æµç¨‹ï¼Œæ³¨å†Œæ”¯ä»˜ç›‘å¬å™¨"

          # æ­¥éª¤2ï¼šç­‰å¾…æ”¯ä»˜å®Œæˆï¼ˆæ–°å¢waitForEventè¯­æ³•ï¼‰
          WaitForPayment:
            waitForEvent: "payment_completed"                    # ç­‰å¾…æˆåŠŸäº‹ä»¶
            onSuccess:                                           # å¤„ç†æˆåŠŸäº‹ä»¶ï¼ˆåŒ…æ‹¬è¿‡æ»¤é€»è¾‘ï¼‰
              Lua: |
                -- è¿‡æ»¤å’Œå¤„ç†é€»è¾‘
                if event.data.amount >= context.expected_amount and 
                   event.data.order_id == context.order_id then
                  return true  -- ç»§ç»­Sagaæ‰§è¡Œ
                else
                  return false -- è¿‡æ»¤å¤±è´¥ï¼Œå¿½ç•¥æ­¤äº‹ä»¶
                end
            exportVariables:                                     # ä½¿ç”¨ç°æœ‰è¯­æ³•æ˜ å°„äº‹ä»¶æ•°æ®
              actual_amount: ".data.amount"
              transaction_id: ".data.transaction_id"
              payment_timestamp: ".data.completed_at"
            failureEvent: "payment_failed"                       # å£°æ˜å¤±è´¥äº‹ä»¶
            onFailure:                                           # å¤„ç†å¤±è´¥äº‹ä»¶
              Lua: "-- å¤„ç†æ”¯ä»˜å¤±è´¥é€»è¾‘"
            maxWaitTime: "30m"                                   # æœ€å¤§ç­‰å¾…æ—¶é—´ï¼ˆåŒºå—é“¾å‹å¥½ï¼‰
            withCompensation: "refund_payment"                   # ç­‰å¾…æ­¥éª¤çš„è¡¥å¿é€»è¾‘
            compensationArguments:                               # è¡¥å¿å‚æ•°
              transaction_id: "transaction_id"

          # æ­¥éª¤3-5ï¼šæ”¯ä»˜æˆåŠŸåçš„å¤„ç†ï¼ˆç°æœ‰è¯­æ³•ï¼Œä¿æŒä¸å˜ï¼‰
          UpdateOrderStatus:
            invokeLocal: "update_order_status"
            arguments:
              status: "'paid'"
              payment_tx_id: "transaction_id"

          NotifyMerchant:
            invokeParticipant: "MerchantService.NotifyMerchant"
            arguments:
              order_id: "order_id"
              amount: "actual_amount"

          UpdateLoyaltyPoints:
            invokeLocal: "update_loyalty_points"
            arguments:
              customer_id: "customer_id"
              points: "calculate_points(actual_amount)"
```

#### 2. ä»£ç ç”Ÿæˆç­–ç•¥

åŸºäºç°æœ‰ä»£ç ç”Ÿæˆæ¨¡å¼çš„æ‰©å±•ï¼š

##### ç”Ÿæˆçš„äº‹ä»¶ç›‘å¬å¤„ç†å™¨
```lua
-- ç”Ÿæˆåœ¨æœåŠ¡æ–‡ä»¶ä¸­çš„äº‹ä»¶å¤„ç†å™¨
-- æ³¨æ„ï¼šä½¿ç”¨ç°æœ‰çš„æ¶ˆæ¯è·¯ç”±æœºåˆ¶ï¼Œè€Œä¸æ˜¯å…¨å±€äº‹ä»¶ç›‘å¬å™¨
Handlers.add(
  "saga_event_triggered",
  Handlers.utils.hasMatchingTag("Action", "Saga_EventTriggered"),
  function(msg)
    local result = { success = false, error = nil }

    -- éªŒè¯å¿…éœ€æ ‡ç­¾
    local saga_id_str = msg.Tags["X-SagaId"]
    local event_type = msg.Tags["X-EventType"]
    local event_id = msg.Tags["X-EventId"]

    if not saga_id_str or not event_type or not event_id then
      result.error = "MISSING_REQUIRED_TAGS"
      messaging.respond(false, result, msg)
      return
    end

    local saga_id = tonumber(saga_id_str)
    if not saga_id then
      result.error = "INVALID_SAGA_ID"
      messaging.respond(false, result, msg)
      return
    end

    -- è·å–Sagaå®ä¾‹
    local saga_instance = saga.get_saga_instance(saga_id)
    if not saga_instance then
      result.error = "SAGA_INSTANCE_NOT_FOUND"
      messaging.respond(false, result, msg)
      return
    end

    -- éªŒè¯æ˜¯å¦æ­£åœ¨ç­‰å¾…æ­¤äº‹ä»¶ç±»å‹
    if not saga_instance.waiting_state or
       not saga_instance.waiting_state.is_waiting or
       saga_instance.waiting_state.event_type ~= event_type then
      result.error = "UNEXPECTED_EVENT_TYPE"
      messaging.respond(false, result, msg)
      return
    end

    -- æ£€æŸ¥äº‹ä»¶æ˜¯å¦å·²è¢«å¤„ç†ï¼ˆå¹‚ç­‰æ€§ï¼‰
    if saga.is_event_already_processed(saga_id, event_id) then
      result.error = "EVENT_ALREADY_PROCESSED"
      messaging.respond(false, result, msg)
      return
    end

    -- æ£€æŸ¥ç­‰å¾…æ—¶é—´æ˜¯å¦è¶…è¿‡æœ€å¤§ç­‰å¾…æ—¶é—´ï¼ˆåŒºå—é“¾å‹å¥½æ£€æŸ¥ï¼‰
    local current_time = os.time()
    local wait_time = current_time - saga_instance.waiting_state.started_at
    if wait_time > saga_instance.waiting_state.max_wait_time_seconds then
      -- ç­‰å¾…æ—¶é—´å·²è¶…è¿‡æœ€å¤§å€¼ï¼Œä½†ä¸ä¸»åŠ¨è§¦å‘è¡¥å¿
      -- å¤–éƒ¨ç›‘æ§ç³»ç»Ÿä¼šå®šæœŸæ£€æŸ¥å¹¶å‘é€è¶…æ—¶è¡¥å¿æ¶ˆæ¯
      result.error = "SAGA_WAIT_EXCEEDED"
      messaging.respond(false, result, msg)
      return
    end

    -- è§£æå¹¶éªŒè¯äº‹ä»¶æ•°æ®
    local event_data = {}
    local decode_success, decode_result = pcall(function()
      return json.decode(msg.Data or "{}")
    end)

    if not decode_success then
      result.error = "INVALID_EVENT_DATA_JSON"
      messaging.respond(false, result, msg)
      return
    end

    event_data = decode_result

    -- æ‰§è¡Œäº‹ä»¶è¿‡æ»¤ï¼ˆå¦‚æœå®šä¹‰äº†ï¼‰
    if saga_instance.waiting_state.event_filter then
      local filter_success, filter_result = saga.evaluate_event_filter(
        saga_instance.waiting_state.event_filter,
        event_data,
        saga_instance.context
      )

      if not filter_success then
        result.error = "EVENT_FILTER_ERROR"
        result.details = { error = filter_result }
        messaging.respond(false, result, msg)
        return
      end

      if not filter_result then
        result.error = "EVENT_FILTER_NOT_MATCHED"
        messaging.respond(false, result, msg)
        return
      end
    end

    -- æ ‡è®°äº‹ä»¶ä¸ºå·²å¤„ç†ï¼ˆåŸå­æ“ä½œï¼‰
    saga.mark_event_processed(saga_id, event_id)

    -- äº‹ä»¶éªŒè¯é€šè¿‡ï¼Œå¼€å§‹ç»§ç»­Sagaæ‰§è¡Œ
    local continue_success, continue_result = saga.continue_from_wait_event(
      saga_id, event_type, event_data, msg
    )

    if continue_success then
      result.success = true
      result.continued_step = continue_result.next_step
      messaging.respond(true, result, msg)
    else
      result.error = continue_result.error or "CONTINUE_FAILED"
      messaging.respond(false, result, msg)
    end
  end
)
```

##### ç”Ÿæˆçš„ç­‰å¾…æ­¥éª¤å¤„ç†ä»£ç 
```lua
-- åœ¨Sagaå›è°ƒå‡½æ•°ä¸­å¤„ç†waitForEventæ­¥éª¤
function inventory_service.process_inventory_surplus_or_shortage_wait_for_payment_callback(msg, env, response)
    -- è¿™ä¸ªå›è°ƒå‡½æ•°å¤„ç†waitForEventæ­¥éª¤çš„"å¯åŠ¨"
    -- waitForEventæ­¥éª¤ä»ç„¶å ç”¨current_stepï¼Œä½†ä¸å‘é€å¤–éƒ¨æ¶ˆæ¯

    local saga_id = tonumber(msg.Tags[messaging.X_TAGS.SAGA_ID])
    local saga_instance = saga.get_saga_instance_copy(saga_id)

    -- éªŒè¯æ­¥éª¤çŠ¶æ€
    local expected_step = 2  -- WaitForPaymentæ˜¯ç¬¬2æ­¥
    if (saga_instance.current_step ~= expected_step or saga_instance.compensating) then
        error(ERRORS.INVALID_MESSAGE)
    end

    -- è®¾ç½®ç­‰å¾…çŠ¶æ€ï¼ˆæ‰©å±•ç°æœ‰saga_instanceç»“æ„ï¼ŒåŒºå—é“¾å‹å¥½è®¾è®¡ï¼‰
    saga_instance.waiting_state = {
        is_waiting = true,
        event_type = "payment_completed",
        step_name = "WaitForPayment",
        started_at = os.time(),
        max_wait_time_seconds = 30 * 60,     -- 30åˆ†é’Ÿæœ€å¤§ç­‰å¾…æ—¶é—´
        # ç®€åŒ–è®¾è®¡ï¼šç§»é™¤å¤æ‚çš„è¶…æ—¶è¡¥å¿æœºåˆ¶
        event_filter = "amount >= expected_amount and order_id == context.order_id"
        # ç®€åŒ–è®¾è®¡ï¼šç§»é™¤expected_eventså’Œevent_data_mapping
        # è¿™äº›åŠŸèƒ½é€šè¿‡ç°æœ‰çš„exportVariableså®ç°
    }

    -- è®°å½•ç­‰å¾…å¼€å§‹
    saga.record_event(saga_instance, "wait_started", {
        event_type = "payment_completed",
        max_wait_time = "30m",
        step = expected_step
    })

    -- ä¸ºwaitForEventæ­¥éª¤åœ¨participantsä¸­è®°å½•åŸºæœ¬ä¿¡æ¯
    -- ç”¨äºè¡¥å¿æ—¶è¯†åˆ«æ­¥éª¤ç±»å‹ï¼Œä½†ä¿æŒåŸæœ‰ç»“æ„
    saga_instance.participants[expected_step] = {
        -- ä¸æ·»åŠ step_typeå­—æ®µï¼Œä¿æŒä¸ç°æœ‰participantsç»“æ„å…¼å®¹
        -- waitForEventæ­¥éª¤ä¸éœ€è¦target/tagsï¼Œå› ä¸ºä¸å‘é€å¤–éƒ¨æ¶ˆæ¯
        -- ä½†éœ€è¦ä¿ç•™æ•°ç»„ç»“æ„çš„ä¸€è‡´æ€§
    }

    -- æäº¤ç­‰å¾…çŠ¶æ€
    entity_coll.update(saga_instances, saga_id, saga_instance)

    -- æ³¨æ„ï¼šwaitForEventæ­¥éª¤ä¸å‘é€ä»»ä½•å¤–éƒ¨æ¶ˆæ¯
    -- Sagaè¿›å…¥ç­‰å¾…çŠ¶æ€ï¼Œç›´åˆ°äº‹ä»¶åˆ°è¾¾æˆ–è¶…æ—¶
end
```

##### æ‰©å±•çš„Sagaè¿è¡Œæ—¶åº“
```lua
-- saga.lua çš„æ‰©å±•å‡½æ•°
-- æ³¨æ„ï¼šæ ¸å¿ƒé€»è¾‘å·²ç»åœ¨ä¸Šé¢çš„ saga.trigger_local_event ä¸­å®ç°
-- è¿™é‡Œåˆ—å‡ºå…¶ä»–è¾…åŠ©å‡½æ•°

-- æ£€æŸ¥äº‹ä»¶æ˜¯å¦å·²è¢«å¤„ç†ï¼ˆå¹‚ç­‰æ€§ä¿æŠ¤ï¼‰
function saga.is_event_already_processed(saga_id, event_id)
    local saga_instance = saga.get_saga_instance(saga_id)
    if not saga_instance then return false end

    -- æ£€æŸ¥Sagaå®ä¾‹ä¸­æ˜¯å¦è®°å½•äº†æ­¤äº‹ä»¶
    if not saga_instance.processed_events then
        saga_instance.processed_events = {}
    end

    return saga_instance.processed_events[event_id] ~= nil
end

-- æ³¨æ„ï¼šæ ‡è®°äº‹ä»¶ä¸ºå·²å¤„ç†çš„é€»è¾‘å·²ç»åœ¨ saga.trigger_local_event ä¸­ç›´æ¥å®ç°

-- åº”ç”¨äº‹ä»¶æ•°æ®æ˜ å°„
function saga.apply_event_data_mapping(context, event_data, mapping_rules)
    if not mapping_rules then return end

    for context_key, event_path in pairs(mapping_rules) do
        -- ç®€å•çš„ç‚¹å·è·¯å¾„è§£æï¼ˆå¯ä»¥æ‰©å±•ä¸ºæ›´å¤æ‚çš„è¡¨è¾¾å¼ï¼‰
        local value = event_data
        local path_parts = {}
        for part in string.gmatch(event_path, "[^.]+") do
            table.insert(path_parts, part)
        end

        -- è·³è¿‡"event.data."å‰ç¼€
        for i = 3, #path_parts do  -- ä»ç¬¬3éƒ¨åˆ†å¼€å§‹ï¼ˆè·³è¿‡event.dataï¼‰
            if type(value) == "table" then
                value = value[path_parts[i]]
            else
                value = nil
                break
            end
        end

        if value ~= nil then
            context[context_key] = value
        end
    end
end
```

## å®æ–½å»ºè®®

### å¯¹DDDMLå·¥å…·å›¢é˜Ÿçš„å»ºè®®

1. **è§„èŒƒæ‰©å±•**ï¼šåœ¨DDDML for AOè§„èŒƒä¸­æ·»åŠ `waitForEvent`æ­¥éª¤ç±»å‹
2. **ä»£ç ç”Ÿæˆå™¨æ›´æ–°**ï¼šæ‰©å±•ä»£ç ç”Ÿæˆå™¨æ”¯æŒç”Ÿæˆå¼‚æ­¥äº‹ä»¶å¤„ç†é€»è¾‘
3. **è¿è¡Œæ—¶åº“æ‰©å±•**ï¼šæ‰©å±•`saga.lua`æ”¯æŒç­‰å¾…çŠ¶æ€ç®¡ç†
4. **å‘åå…¼å®¹æ€§**ï¼šç¡®ä¿ç°æœ‰Sagaå®šä¹‰100%å…¼å®¹

### å¼€å‘è·¯çº¿å›¾

#### é˜¶æ®µ1ï¼šè§„èŒƒè®¾è®¡ï¼ˆ1ä¸ªæœˆï¼‰
- è®¾è®¡`waitForEvent`è¯­æ³•è§„èŒƒ
- å®šä¹‰äº‹ä»¶æ¶ˆæ¯åè®®
- è®¾è®¡çŠ¶æ€æ‰©å±•æ–¹æ¡ˆ

#### é˜¶æ®µ2ï¼šä»£ç ç”Ÿæˆå™¨æ‰©å±•ï¼ˆ2ä¸ªæœˆï¼‰
- æ‰©å±•YAMLè§£æå™¨
- å®ç°äº‹ä»¶å¤„ç†ä»£ç ç”Ÿæˆ
- æ‰©å±•çŠ¶æ€ç®¡ç†ä»£ç ç”Ÿæˆ

#### é˜¶æ®µ3ï¼šè¿è¡Œæ—¶åº“æ‰©å±•ï¼ˆ1ä¸ªæœˆï¼‰
- æ‰©å±•`saga.lua`æ”¯æŒç­‰å¾…çŠ¶æ€
- å®ç°äº‹ä»¶è¿‡æ»¤å’ŒéªŒè¯
- æ·»åŠ è¶…æ—¶å¤„ç†æœºåˆ¶

#### é˜¶æ®µ4ï¼šæµ‹è¯•å’Œæ–‡æ¡£ï¼ˆ1ä¸ªæœˆï¼‰
- ç¼–å†™å®Œæ•´æµ‹è¯•ç”¨ä¾‹
- åˆ›å»ºä½¿ç”¨ç¤ºä¾‹
- ç¼–å†™è¿ç§»æŒ‡å—

## å®é™…ä½¿ç”¨ç¤ºä¾‹

#### ğŸ”§ DDDMLä»£ç ç”Ÿæˆä¸å¼€å‘è€…é›†æˆæ¨¡å¼è¯¦è§£

åœ¨è¯¦ç»†åˆ†æexternal-contract-saga-integration.mdåï¼Œæˆ‘ä»¬éœ€è¦æ˜ç¡®**DDDMLå·¥å…·ç”Ÿæˆçš„ä»£ç **ä¸**å¼€å‘è€…æ‰‹åŠ¨ç¼–å†™çš„ä»£ç **å¦‚ä½•é›†æˆï¼Œç‰¹åˆ«æ˜¯é’ˆå¯¹"æœ¬åœ°ä»£ç†åŒ…è£…"æ¨¡å¼ã€‚

##### æ ¸å¿ƒé›†æˆæ¶æ„

```lua
-- === DDDMLå·¥å…·ç”Ÿæˆçš„ä»£ç  ===
-- 1. Sagaç­‰å¾…çŠ¶æ€ç®¡ç†
-- 2. äº‹ä»¶ç›‘å¬å™¨
-- 3. æœ¬åœ°äº‹ä»¶å‘å¸ƒAPI

-- === å¼€å‘è€…æ‰‹åŠ¨ç¼–å†™çš„ä»£ç  ===
-- 1. ä»£ç†åˆçº¦ä¸šåŠ¡é€»è¾‘
-- 2. å¤–éƒ¨å“åº”å¤„ç†
-- 3. è°ƒç”¨æœ¬åœ°äº‹ä»¶å‘å¸ƒAPI
```

**å…³é”®è®¾è®¡å†³ç­–**ï¼š
- **æœ¬åœ°äº‹ä»¶å‘å¸ƒAPI**ï¼šDDDMLç”Ÿæˆ`trigger_local_saga_event()`å‡½æ•°
- **ä»£ç†åˆçº¦é›†æˆ**ï¼šå¼€å‘è€…åœ¨ä»£ç†åˆçº¦ä¸­è°ƒç”¨æ­¤APIå‘å¸ƒäº‹ä»¶
- **SagaåŒ¹é…æœºåˆ¶**ï¼šé€šè¿‡saga_idå’Œäº‹ä»¶ç±»å‹ç²¾ç¡®åŒ¹é…ç­‰å¾…ä¸­çš„Sagaå®ä¾‹

#### âœ… external-contract-saga-integration.mdåœºæ™¯æ”¯æŒéªŒè¯

ç»è¿‡è¯¦ç»†åˆ†æï¼Œ**æˆ‘ä»¬å½“å‰çš„waitForEventæ‰©å±•å·²ç»å®Œå…¨èƒ½å¤Ÿæ”¯æŒexternal-contract-saga-integration.mdä¸­æè¿°çš„æ‰€æœ‰åœºæ™¯**ã€‚

##### åœºæ™¯Bï¼šåŠè‡ªåŠ¨åŒ–ç”µå•†æ”¯ä»˜æµç¨‹çš„å®Œæ•´æ”¯æŒ

**åŸå§‹éœ€æ±‚**ï¼ˆæ¥è‡ªexternal-contract-saga-integration.mdï¼‰ï¼š
- æ³¨å†Œæ”¯ä»˜æ„å‘åç«‹å³å¯åŠ¨Saga
- Sagaç­‰å¾…æ”¯ä»˜æ¥æ”¶åˆçº¦çš„é€šçŸ¥ï¼ˆPaymentReceivedäº‹ä»¶ï¼‰
- æ”¯ä»˜éªŒè¯æˆåŠŸåï¼Œç»§ç»­æ›´æ–°è®¢å•ã€é€šçŸ¥å•†å®¶ã€æ›´æ–°ç§¯åˆ†
- æ”¯æŒæ”¯ä»˜å¤±è´¥æˆ–è¶…æ—¶çš„è¡¥å¿é€»è¾‘

**æˆ‘ä»¬çš„waitForEventè¯­æ³•å®Œå…¨æ”¯æŒ**ï¼š

```yaml
services:
  EcommercePaymentService:
    methods:
      ProcessOrderPayment:
        parameters:
          order_id: number
          customer_id: string
          expected_amount: number

        steps:
          # æ­¥éª¤1ï¼šæ³¨å†Œæ”¯ä»˜æ„å‘
          RegisterPaymentIntent:
            invokeLocal: "register_payment_intent"
            exportVariables:
              intent_id: ".intent_id"

          # æ­¥éª¤2ï¼šç­‰å¾…æ”¯ä»˜éªŒè¯ç»“æœï¼ˆæ ¸å¿ƒç­‰å¾…æ­¥éª¤ï¼‰
          WaitForPaymentValidation:
            waitForEvent: "PaymentReceived"        # ç­‰å¾…æ”¯ä»˜æ¥æ”¶åˆçº¦çš„é€šçŸ¥
            onSuccess:                             # å¤„ç†æ”¯ä»˜æˆåŠŸéªŒè¯
              Lua: |
                -- éªŒè¯æ”¯ä»˜é‡‘é¢å’Œè®¢å•åŒ¹é…
                if event.data.verified and event.data.order_id == context.order_id then
                  return true  -- ç»§ç»­ä¸šåŠ¡æµç¨‹
                else
                  return false -- éªŒè¯å¤±è´¥
                end
            exportVariables:                        # æå–æ”¯ä»˜è¯¦æƒ…
              actual_amount: ".data.payment_details.amount"
              transaction_id: ".data.payment_details.transaction_id"
              payment_timestamp: ".data.payment_details.timestamp"
            failureEvent: "PaymentFailed"           # æ”¯ä»˜å¤±è´¥äº‹ä»¶
            onFailure:                              # å¤„ç†æ”¯ä»˜å¤±è´¥
              Lua: |
                -- è®°å½•å¤±è´¥åŸå› 
                context.failure_reason = event.data.reason or "payment_failed"
                -- å‡†å¤‡è¡¥å¿æ•°æ®
                return "compensate"
            maxWaitTime: "30m"                      # æ”¯ä»˜ç­‰å¾…è¶…æ—¶
            withCompensation: "cancel_order_and_refund"

          # æ­¥éª¤3-5ï¼šæ”¯ä»˜æˆåŠŸåçš„ä¸šåŠ¡å¤„ç†
          UpdateOrderStatus:
            invokeLocal: "update_order_status"
            arguments:
              order_id: "order_id"
              status: "'paid'"
              payment_tx_id: "transaction_id"
              paid_amount: "actual_amount"
              paid_at: "payment_timestamp"

          NotifyMerchant:
            invokeParticipant: "MerchantService.NotifyOrderPaid"
            arguments:
              merchant_id: "order.merchant_id"
              order_id: "order_id"
              amount: "actual_amount"
              customer_id: "customer_id"

          UpdateLoyaltyPoints:
            invokeLocal: "update_loyalty_points"
            arguments:
              customer_id: "customer_id"
              order_amount: "actual_amount"
```

**å®Œç¾æ˜ å°„åˆ†æ**ï¼š

| external-contract-saga-integration.mdéœ€æ±‚ | æˆ‘ä»¬çš„waitForEventæ”¯æŒ |
|-----------------------------------------|----------------------|
| æ³¨å†Œæ”¯ä»˜æ„å‘åå¯åŠ¨Saga | âœ… æ­£å¸¸Sagaå¯åŠ¨æµç¨‹ |
| ç­‰å¾…æ”¯ä»˜æ¥æ”¶åˆçº¦é€šçŸ¥ | âœ… `waitForEvent: "PaymentReceived"` |
| éªŒè¯æ”¯ä»˜é‡‘é¢å’Œè®¢å•åŒ¹é… | âœ… `onSuccess`ä¸­å®ç°ä¸šåŠ¡éªŒè¯é€»è¾‘ |
| æå–æ”¯ä»˜è¯¦æƒ…æ•°æ® | âœ… `exportVariables`æ˜ å°„äº‹ä»¶æ•°æ® |
| å¤„ç†æ”¯ä»˜å¤±è´¥æƒ…å†µ | âœ… `failureEvent` + `onFailure` |
| æ”¯ä»˜è¶…æ—¶å¤„ç† | âœ… `maxWaitTime` + å¤–éƒ¨ç›‘æ§è¡¥å¿ |
| ç»§ç»­åç»­ä¸šåŠ¡æ­¥éª¤ | âœ… Sagaè‡ªåŠ¨ç»§ç»­æ‰§è¡Œ |
| æ•´ä½“ä¸€è‡´æ€§ä¿è¯ | âœ… Sagaçš„è¡¥å¿æœºåˆ¶ |

**ç»“è®º**ï¼šæˆ‘ä»¬çš„waitForEventæ‰©å±•**100%æ”¯æŒ**external-contract-saga-integration.mdä¸­æè¿°çš„åœºæ™¯ï¼

#### ğŸ“ DDDMLä»£ç ç”Ÿæˆç­–ç•¥è¯¦è§£

åŸºäºexternal-contract-saga-integration.mdçš„æœ¬åœ°ä»£ç†åŒ…è£…æ¨¡å¼ï¼Œæˆ‘ä»¬éœ€è¦æ˜ç¡®DDDMLå·¥å…·åº”è¯¥ç”Ÿæˆä»€ä¹ˆæ ·çš„ä»£ç ã€‚

##### 1. DDDMLç”Ÿæˆçš„Sagaç­‰å¾…ç®¡ç†ä»£ç 

```lua
-- === ç”±DDDMLå·¥å…·ç”Ÿæˆçš„ä»£ç  (ecommerce_payment_service.lua) ===

-- ç­‰å¾…æ­¥éª¤çš„å¯åŠ¨å‡½æ•°ï¼ˆå½“Sagaæ‰§è¡Œåˆ°WaitForPaymentæ­¥éª¤æ—¶è°ƒç”¨ï¼‰
function ecommerce_payment_service.process_payment_saga_wait_for_payment(msg, env, response)
    -- éªŒè¯æ­¥éª¤çŠ¶æ€
    local saga_id = tonumber(msg.Tags[messaging.X_TAGS.SAGA_ID])
    local saga_instance = saga.get_saga_instance_copy(saga_id)

    local expected_step = 2  -- WaitForPaymentæ˜¯ç¬¬2æ­¥
    if (saga_instance.current_step ~= expected_step or saga_instance.compensating) then
        error(ERRORS.INVALID_MESSAGE)
    end

    -- è®¾ç½®ç­‰å¾…çŠ¶æ€ï¼ˆDDDMLç”Ÿæˆï¼‰
    saga_instance.waiting_state = {
        is_waiting = true,
        event_type = "payment_completed",  -- ä»YAMLé…ç½®ç”Ÿæˆ
        step_name = "WaitForPayment",
        started_at = os.time(),
        max_wait_time_seconds = 30 * 60,  -- ä»maxWaitTime="30m"ç”Ÿæˆ
        -- äº‹ä»¶è¿‡æ»¤é€»è¾‘ï¼ˆä»onSuccessçš„Luaä»£ç ç”Ÿæˆï¼‰
        event_filter_function = function(event_data, context)
            -- DDDMLä»YAMLçš„onSuccess Luaä»£ç ç”Ÿæˆæ­¤å‡½æ•°
            return event_data.verified and event_data.order_id == context.order_id
        end,
        -- æ•°æ®æ˜ å°„è§„åˆ™ï¼ˆä»exportVariablesç”Ÿæˆï¼‰
        data_mapping_rules = {
            actual_amount = ".data.payment_details.amount",
            transaction_id = ".data.payment_details.transaction_id",
            payment_timestamp = ".data.payment_details.timestamp"
        },
        -- è¡¥å¿é…ç½®ï¼ˆä»withCompensationç”Ÿæˆï¼‰
        compensation_config = {
            action = "cancel_order_and_refund",
            arguments = { "transaction_id", "actual_amount" }
        }
    }

    -- è®°å½•ç­‰å¾…å¼€å§‹
    saga.record_event(saga_instance, "wait_started", {
        event_type = "payment_completed",
        max_wait_time = "30m",
        step = expected_step
    })

    -- åœ¨participantsä¸­è®°å½•æ­¥éª¤ä¿¡æ¯ï¼ˆä¿æŒæ•°ç»„ç»“æ„å…¼å®¹æ€§ï¼‰
    saga_instance.participants[expected_step] = {}

    -- æäº¤ç­‰å¾…çŠ¶æ€
    entity_coll.update(saga_instances, saga_id, saga_instance)

    -- æ³¨æ„ï¼šwaitForEventæ­¥éª¤ä¸å‘é€ä»»ä½•å¤–éƒ¨æ¶ˆæ¯
    -- Sagaè¿›å…¥ç­‰å¾…çŠ¶æ€ï¼Œç›´åˆ°æœ¬åœ°äº‹ä»¶è§¦å‘å™¨è¢«è°ƒç”¨
end

-- === DDDMLç”Ÿæˆçš„æœ¬åœ°äº‹ä»¶å‘å¸ƒAPI ===
function trigger_local_saga_event(saga_id, event_type, event_data)
    -- DDDMLç”Ÿæˆçš„å‡½æ•°ï¼Œä¾›å¼€å‘è€…è°ƒç”¨çš„æœ¬åœ°äº‹ä»¶å‘å¸ƒAPI
    return saga.trigger_local_event(saga_id, event_type, event_data)
end

-- === DDDMLç”Ÿæˆçš„Sagaäº‹ä»¶å¤„ç†æ‰©å±• ===
-- åœ¨saga.luaä¸­æ‰©å±•çš„äº‹ä»¶å¤„ç†å‡½æ•°
function saga.trigger_local_event(saga_id, event_type, event_data)
    local result = { success = false, error = nil }

    -- è·å–Sagaå®ä¾‹ç”¨äºéªŒè¯ï¼ˆåªè¯»æ“ä½œï¼‰
    local saga_instance = saga.get_saga_instance(saga_id)
    if not saga_instance then
        result.error = "SAGA_INSTANCE_NOT_FOUND"
        return false, result
    end

    if not saga_instance.waiting_state or
       not saga_instance.waiting_state.is_waiting or
       saga_instance.waiting_state.event_type ~= event_type then
        result.error = "UNEXPECTED_EVENT_TYPE"
        return false, result
    end

    -- æ£€æŸ¥äº‹ä»¶æ˜¯å¦å·²è¢«å¤„ç†ï¼ˆå¹‚ç­‰æ€§ - åªè¯»æ£€æŸ¥ï¼‰
    local event_id = event_data.event_id or generate_event_id(event_data)
    if saga.is_event_already_processed(saga_id, event_id) then
        result.error = "EVENT_ALREADY_PROCESSED"
        return false, result
    end

    -- æ‰§è¡Œäº‹ä»¶è¿‡æ»¤ï¼ˆå¦‚æœå®šä¹‰äº† - åªè¯»æ“ä½œï¼‰
    if saga_instance.waiting_state.event_filter_function then
        local success, filter_result = pcall(
            saga_instance.waiting_state.event_filter_function,
            event_data, saga_instance.context
        )
        if not success then
            result.error = "EVENT_FILTER_ERROR: " .. filter_result
            return false, result
        end
        if not filter_result then
            result.error = "EVENT_FILTER_NOT_MATCHED"
            return false, result
        end
    end

    -- æ‰€æœ‰éªŒè¯é€šè¿‡åï¼Œè·å–å‰¯æœ¬è¿›è¡Œä¿®æ”¹
    local saga_copy = saga.get_saga_instance_copy(saga_id)

    -- æ ‡è®°äº‹ä»¶ä¸ºå·²å¤„ç†
    if not saga_copy.processed_events then
        saga_copy.processed_events = {}
    end
    saga_copy.processed_events[event_id] = os.time()

    -- åº”ç”¨æ•°æ®æ˜ å°„
    if saga_instance.waiting_state.data_mapping_rules then
        saga.apply_event_data_mapping(
            saga_copy.context,
            event_data,
            saga_instance.waiting_state.data_mapping_rules
        )
    end

    -- æ¸…é™¤ç­‰å¾…çŠ¶æ€
    saga_copy.waiting_state.is_waiting = false
    saga_copy.waiting_state.event_type = nil
    saga_copy.waiting_state.started_at = nil
    saga_copy.waiting_state.max_wait_time_seconds = nil

    -- å‰è¿›åˆ°ä¸‹ä¸€ä¸ªæ­¥éª¤
    saga_copy.current_step = saga_copy.current_step + 1
    saga_copy.participants[saga_copy.current_step] = {}  -- ä¸‹ä¸€æ­¥å¯èƒ½æ˜¯æœ¬åœ°æ­¥éª¤

    -- æäº¤æ‰€æœ‰ä¿®æ”¹
    local commit = function()
        entity_coll.update(saga_instances, saga_id, saga_copy)
    end
    commit()  -- æ‰§è¡Œcommit

    result.success = true
    result.continued_step = saga_copy.current_step
    return true, result
end
```

##### 2. å¼€å‘è€…æ‰‹åŠ¨ç¼–å†™çš„ä»£ç†åˆçº¦ä»£ç 

```lua
-- === å¼€å‘è€…æ‰‹åŠ¨ç¼–å†™çš„ä»£ç  (token_proxy.lua) ===

-- æœ¬åœ°ä»£ç†åˆçº¦ï¼Œéƒ¨ç½²åœ¨ä¸Sagaç›¸åŒçš„AOè¿›ç¨‹ä¸­
local token_proxy = {
    name = "TokenTransferProxy",
    config = {
        external_config = {
            target = "0syT13r0s0tgPmIed95bJnuSqaD29HQNN8D3ElLSrsc", -- AO Tokenåˆçº¦
            action = "Transfer"
        }
    },
    pending_requests = {} -- ç®¡ç†pendingè¯·æ±‚
}

-- å¤„ç†å¤–éƒ¨Tokenåˆçº¦çš„å“åº”ï¼ˆå¼€å‘è€…å®ç°ä¸šåŠ¡é€»è¾‘ï¼‰
function token_proxy.handle_token_response(msg)
    local response_type = msg.Tags.Action

    if response_type == "Debit-Notice" then
        -- å¤„ç†æˆåŠŸçš„Tokenè½¬è´¦
        local transfer_info = {
            transaction_id = msg.Tags['Message-Id'],
            quantity = msg.Tags.Quantity,
            recipient = msg.Tags.Recipient,
            sender = msg.Tags.Sender
        }

        -- æŸ¥æ‰¾å¯¹åº”çš„pendingè¯·æ±‚ï¼ˆé€šè¿‡ä¸šåŠ¡å‚æ•°åŒ¹é…ï¼‰
        local request_info = token_proxy.find_pending_request_by_transfer(transfer_info)

        if request_info then
            -- âœ… è½¬è´¦æˆåŠŸï¼Œå‘å¸ƒæœ¬åœ°æˆåŠŸäº‹ä»¶
            local success, result = trigger_local_saga_event(
                request_info.saga_id,
                "payment_completed",  -- åŒ¹é…YAMLä¸­çš„waitForEvent
                {
                    event_id = transfer_info.transaction_id,
                    verified = true,
                    order_id = request_info.business_context.order_id,
                    payment_details = {
                        amount = transfer_info.quantity,
                        transaction_id = transfer_info.transaction_id,
                        timestamp = os.time(),
                        sender = transfer_info.sender
                    }
                }
            )

            if success then
                print("Payment event triggered for saga:", request_info.saga_id)
                -- æ¸…ç†pendingè¯·æ±‚
                token_proxy.pending_requests[request_info.request_id] = nil
            else
                print("Failed to trigger payment event:", result.error)
                -- å¯ä»¥é€‰æ‹©é‡è¯•æˆ–è®°å½•é”™è¯¯
            end
        end

    elseif response_type == "Transfer-Error" then
        -- å¤„ç†å¤±è´¥çš„Tokenè½¬è´¦
        local error_info = {
            transaction_id = msg.Tags['Message-Id'],
            error_code = msg.Tags.Error,
            quantity = msg.Tags.Quantity,
            recipient = msg.Tags.Recipient
        }

        -- æŸ¥æ‰¾å¯¹åº”çš„pendingè¯·æ±‚
        local request_info = token_proxy.find_pending_request_by_transfer(error_info)

        if request_info then
            -- âŒ è½¬è´¦å¤±è´¥ï¼Œå‘å¸ƒæœ¬åœ°å¤±è´¥äº‹ä»¶
            local success, result = trigger_local_saga_event(
                request_info.saga_id,
                "payment_failed",  -- åŒ¹é…YAMLä¸­çš„failureEvent
                {
                    event_id = error_info.transaction_id .. "_error",
                    verified = false,
                    reason = error_info.error_code,
                    order_id = request_info.business_context.order_id,
                    failed_transaction = {
                        transaction_id = error_info.transaction_id,
                        amount = error_info.quantity,
                        recipient = error_info.recipient
                    }
                }
            )

            if success then
                print("Payment failure event triggered for saga:", request_info.saga_id)
                -- æ¸…ç†pendingè¯·æ±‚
                token_proxy.pending_requests[request_info.request_id] = nil
            else
                print("Failed to trigger payment failure event:", result.error)
            end
        end
    end
end

-- æ³¨å†ŒTokenå“åº”å¤„ç†å™¨ï¼ˆå¼€å‘è€…å®ç°ï¼‰
Handlers.add(
    "token_response_handler",
    Handlers.utils.hasMatchingTag("Action", "Debit-Notice", "Transfer-Error"),
    token_proxy.handle_token_response
)

-- æŸ¥æ‰¾pendingè¯·æ±‚çš„ä¸šåŠ¡é€»è¾‘ï¼ˆå¼€å‘è€…å®ç°ï¼‰
function token_proxy.find_pending_request_by_transfer(transfer_info)
    -- é€šè¿‡ä¸šåŠ¡å‚æ•°åŒ¹é…æ‰¾åˆ°å¯¹åº”çš„sagaè¯·æ±‚
    -- å®ç°ä¸šåŠ¡åŒ¹é…é€»è¾‘ï¼ˆé‡‘é¢ã€æ¥æ”¶æ–¹ã€æ—¶é—´çª—å£ç­‰ï¼‰
    for request_id, request_info in pairs(token_proxy.pending_requests) do
        if token_proxy.matches_business_criteria(request_info, transfer_info) then
            return request_info
        end
    end
    return nil
end

return token_proxy
```

##### 3. ä»£ç ç”Ÿæˆä¸é›†æˆçš„å·¥ä½œæµç¨‹

**DDDMLå·¥å…·çš„å·¥ä½œ**ï¼š
1. **è§£æYAML**ï¼šè¯»å–`waitForEvent`ã€`onSuccess`ã€`failureEvent`ç­‰é…ç½®
2. **ç”ŸæˆSagaä»£ç **ï¼šåˆ›å»ºç­‰å¾…çŠ¶æ€ç®¡ç†ã€äº‹ä»¶å¤„ç†å‡½æ•°
3. **ç”ŸæˆAPIæ¥å£**ï¼šæä¾›`trigger_local_saga_event()`å‡½æ•°ä¾›å¼€å‘è€…è°ƒç”¨
4. **ç”Ÿæˆäº‹ä»¶ç›‘å¬å™¨**ï¼šåˆ›å»ºSaga_EventTriggeredæ¶ˆæ¯å¤„ç†å™¨

**å¼€å‘è€…çš„å·¥ä½œ**ï¼š
1. **å®ç°ä»£ç†åˆçº¦**ï¼šç¼–å†™å¤–éƒ¨å“åº”å¤„ç†é€»è¾‘
2. **è°ƒç”¨äº‹ä»¶API**ï¼šåœ¨åˆé€‚çš„æ—¶æœºè°ƒç”¨`trigger_local_saga_event()`
3. **ä¸šåŠ¡é€»è¾‘å®ç°**ï¼šå¤„ç†ä¸šåŠ¡åŒ¹é…ã€æ•°æ®è½¬æ¢ç­‰é€»è¾‘

**é›†æˆæ–¹å¼**ï¼š
```lua
-- åœ¨åŒä¸€ä¸ªAOè¿›ç¨‹ä¸­ï¼Œä»£ç†åˆçº¦å’ŒSagaæœåŠ¡å¯ä»¥ç›´æ¥è°ƒç”¨
-- å¼€å‘è€…ç¼–å†™çš„ä»£ç†åˆçº¦ï¼š
token_proxy.handle_token_response(msg)
  â†“ è°ƒç”¨DDDMLç”Ÿæˆçš„API
trigger_local_saga_event(saga_id, "payment_completed", event_data)
  â†“ è§¦å‘DDDMLç”Ÿæˆçš„Sagaç»§ç»­é€»è¾‘
saga.continue_from_wait_event(saga_id, event_type, event_data)
  â†“ Sagaè‡ªåŠ¨æ‰§è¡Œä¸‹ä¸€æ­¥éª¤
```

**å…³é”®æ‰©å±•ç‚¹**ï¼š
- **äº‹ä»¶å‘å¸ƒAPI**ï¼š`trigger_local_saga_event(saga_id, event_type, event_data)`
- **ä¸šåŠ¡åŒ¹é…é€»è¾‘**ï¼šå¼€å‘è€…å®ç°`find_pending_request_by_transfer()`
- **æ•°æ®è½¬æ¢**ï¼šå¼€å‘è€…å‡†å¤‡ç¬¦åˆSagaæœŸæœ›çš„äº‹ä»¶æ•°æ®æ ¼å¼
- **é”™è¯¯å¤„ç†**ï¼šå¼€å‘è€…å¤„ç†äº‹ä»¶å‘å¸ƒå¤±è´¥çš„æƒ…å†µ

è¿™ä¸ªè®¾è®¡å®Œç¾æ”¯æŒäº†external-contract-saga-integration.mdä¸­çš„æœ¬åœ°ä»£ç†åŒ…è£…æ¨¡å¼ï¼

### å®Œæ•´ç”µå•†æ”¯ä»˜Sagaç¤ºä¾‹

åŸºäºexternal-contract-saga-integration.mdçš„åœºæ™¯ï¼Œè¿™é‡Œæä¾›ä¸€ä¸ªå®Œæ•´çš„å®ç°ç¤ºä¾‹ï¼š

#### 1. DDDMLæ¨¡å‹å®šä¹‰

```yaml
services:
  EcommercePaymentService:
    requiredComponents:
      OrderService: OrderService
      PaymentGateway: PaymentGateway
      MerchantNotification: MerchantNotification

    methods:
      ProcessOrderPayment:
        description: "å¤„ç†è®¢å•æ”¯ä»˜æµç¨‹ï¼ŒåŒ…å«ç”¨æˆ·æ”¯ä»˜ç­‰å¾…"
        parameters:
          order_id: number
          customer_id: string
          expected_amount: number
          payment_method: string
        steps:
          # æ­¥éª¤1ï¼šéªŒè¯è®¢å•å¹¶æ³¨å†Œæ”¯ä»˜æ„å‘
          ValidateOrder:
            invokeLocal: "validate_order"
            description: "éªŒè¯è®¢å•çŠ¶æ€å’Œæ”¯ä»˜å‚æ•°"

          # æ­¥éª¤2ï¼šæ³¨å†Œæ”¯ä»˜æ„å‘
          RegisterPaymentIntent:
            invokeLocal: "register_payment_intent"
            description: "åˆ›å»ºæ”¯ä»˜æ„å‘ï¼Œåˆå§‹åŒ–æ”¯ä»˜ç›‘å¬å™¨"
            exportVariables:
              payment_intent_id: ".intent_id"

          # æ­¥éª¤3ï¼šç­‰å¾…ç”¨æˆ·æ”¯ä»˜å®Œæˆï¼ˆæ ¸å¿ƒç­‰å¾…æ­¥éª¤ï¼Œä½¿ç”¨onSuccessä¿æŒä¸€è‡´æ€§ï¼‰
          WaitForPayment:
            waitForEvent: "payment_completed"
            description: "ç­‰å¾…ç”¨æˆ·å®Œæˆæ”¯ä»˜"
            onSuccess:                             # å¤„ç†æˆåŠŸäº‹ä»¶ï¼ŒåŒ…æ‹¬è¿‡æ»¤é€»è¾‘
              Lua: "-- å¤„ç†æ”¯ä»˜æˆåŠŸé€»è¾‘"           # è¿‡æ»¤å’Œå¤„ç†é€»è¾‘åœ¨ç”Ÿæˆçš„ä»£ç ä¸­å®ç°
            exportVariables:                       # ä½¿ç”¨ç°æœ‰è¯­æ³•æ˜ å°„äº‹ä»¶æ•°æ®
              ActualAmount:
                extractionPath: ".data.amount"
              TransactionId:
                extractionPath: ".data.transaction_id"
              PaymentTimestamp:
                extractionPath: ".data.completed_at"
              PaymentMethod:
                extractionPath: ".data.method"
            failureEvent: "payment_failed"         # å£°æ˜å¤±è´¥äº‹ä»¶ç±»å‹
            onFailure:                             # å¤„ç†å¤±è´¥äº‹ä»¶
              Lua: "-- å¤„ç†æ”¯ä»˜å¤±è´¥é€»è¾‘"
            maxWaitTime: "30m"                     # åŒºå—é“¾å‹å¥½ï¼šæœ€å¤§ç­‰å¾…æ—¶é—´
            withCompensation: "refund_payment"     # è¡¥å¿é€»è¾‘
            compensationArguments:
              TransactionId: "TransactionId"
              RefundAmount: "ActualAmount"

          # æ­¥éª¤4ï¼šæ›´æ–°è®¢å•çŠ¶æ€
          UpdateOrderStatus:
            invokeLocal: "update_order_status"
            arguments:
              order_id: "order_id"
              status: "'paid'"
              payment_tx_id: "transaction_id"
              paid_amount: "actual_amount"
              paid_at: "payment_timestamp"

          # æ­¥éª¤5ï¼šé€šçŸ¥å•†å®¶
          NotifyMerchant:
            invokeParticipant: "MerchantNotification.NotifyOrderPaid"
            arguments:
              merchant_id: "order.merchant_id"
              order_id: "order_id"
              amount: "actual_amount"
              customer_id: "customer_id"

          # æ­¥éª¤6ï¼šå‘æ”¾ç”¨æˆ·ç§¯åˆ†å¥–åŠ±
          AwardLoyaltyPoints:
            invokeLocal: "award_loyalty_points"
            arguments:
              customer_id: "customer_id"
              order_amount: "actual_amount"
              payment_method: "payment_method"
```

#### 2. ä¸šåŠ¡é€»è¾‘å®ç°

```lua
-- inventory_service_local.lua ä¸­çš„ä¸šåŠ¡é€»è¾‘

-- æ­¥éª¤1ï¼šéªŒè¯è®¢å•
function validate_order(context)
    -- éªŒè¯è®¢å•å­˜åœ¨æ€§ã€çŠ¶æ€ã€é‡‘é¢ç­‰
    local order = get_order(context.order_id)
    if not order then
        error("ORDER_NOT_FOUND")
    end
    if order.status ~= "pending_payment" then
        error("INVALID_ORDER_STATUS")
    end
    if order.total_amount ~= context.expected_amount then
        error("AMOUNT_MISMATCH")
    end

    context.order = order  -- ä¿å­˜è®¢å•ä¿¡æ¯åˆ°ä¸Šä¸‹æ–‡
    return {}, function() end
end

-- æ­¥éª¤2ï¼šæ³¨å†Œæ”¯ä»˜æ„å‘
function register_payment_intent(context)
    -- åˆ›å»ºæ”¯ä»˜æ„å‘è®°å½•
    local intent_id = generate_payment_intent_id()
    local intent = {
        intent_id = intent_id,
        order_id = context.order_id,
        customer_id = context.customer_id,
        expected_amount = context.expected_amount,
        payment_method = context.payment_method,
        created_at = os.time(),
        expires_at = os.time() + (30 * 60)  -- 30åˆ†é’Ÿè¿‡æœŸ
    }

    -- ä¿å­˜åˆ°å­˜å‚¨ä¸­
    save_payment_intent(intent)

    -- è¿”å›æ„å›¾ID
    return { intent_id = intent_id }, function() end
end

-- æ­¥éª¤4ï¼šæ›´æ–°è®¢å•çŠ¶æ€
function update_order_status(context)
    update_order(context.order_id, {
        status = "paid",
        payment_tx_id = context.transaction_id,
        paid_amount = context.actual_amount,
        paid_at = context.payment_timestamp,
        payment_method = context.payment_method
    })
    return {}, function() end
end

-- æ­¥éª¤6ï¼šå‘æ”¾ç§¯åˆ†
function award_loyalty_points(context)
    local points = calculate_loyalty_points(context.order_amount, context.payment_method)
    award_points(context.customer_id, points)
    return {}, function() end
end

-- è¡¥å¿å‡½æ•°ï¼šå–æ¶ˆè®¢å•å¹¶é€€æ¬¾
function cancel_order_and_refund(context)
    -- å–æ¶ˆè®¢å•
    update_order(context.order_id, { status = "cancelled" })

    -- å¦‚æœå·²ç»æ”¶åˆ°æ”¯ä»˜ï¼Œè¿›è¡Œé€€æ¬¾
    if context.transaction_id then
        initiate_refund(context.transaction_id, context.actual_amount)
    end

    return {}, function() end
end
```

#### 3. äº‹ä»¶è§¦å‘ä»£ç 

```lua
-- æ”¯ä»˜ç½‘å…³å›è°ƒå¤„ç†å™¨ï¼ˆåœ¨ç‹¬ç«‹çš„AOè¿›ç¨‹ä¸­ï¼‰
Handlers.add(
  "payment_gateway_callback",
  Handlers.utils.hasMatchingTag("Action", "PaymentCompleted"),
  function(msg)
    local payment_data = json.decode(msg.Data)

    -- è§¦å‘Sagaäº‹ä»¶
    ao.send({
      Target = "ECOMMERCE_SAGA_PROCESS_ID",
      Tags = {
        Action = "Saga_EventTriggered",
        ["X-SagaId"] = tostring(payment_data.order_id),  -- ä½¿ç”¨è®¢å•IDä½œä¸ºSaga ID
        ["X-EventType"] = "payment_completed",
        ["X-EventId"] = payment_data.transaction_id,
        ["X-EventSource"] = "payment_gateway"
      },
      Data = json.encode({
        event_type = "payment_completed",
        event_data = {
          order_id = payment_data.order_id,
          amount = payment_data.amount,
          transaction_id = payment_data.transaction_id,
          method = payment_data.payment_method,
          completed_at = os.time()
        }
      })
    })
  end
)
```

## é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæƒ…å†µ

### 1. è¶…æ—¶å¤„ç†
```lua
-- è¶…æ—¶è¡¥å¿é€»è¾‘
function cancel_order_and_refund(context)
    -- è®°å½•è¶…æ—¶åŸå› 
    log_timeout_event(context.order_id, "PAYMENT_TIMEOUT")

    -- å–æ¶ˆè®¢å•
    update_order(context.order_id, {
        status = "cancelled",
        cancellation_reason = "payment_timeout",
        cancelled_at = os.time()
    })

    -- é€šçŸ¥ç”¨æˆ·
    notify_user_timeout(context.customer_id, context.order_id)

    -- å¦‚æœæœ‰æ”¯ä»˜æ„å‘è®°å½•ï¼Œæ¸…ç†å®ƒ
    if context.payment_intent_id then
        cleanup_payment_intent(context.payment_intent_id)
    end

    return {}, function() end
end
```

### 2. äº‹ä»¶éªŒè¯å¤±è´¥
```lua
-- åœ¨äº‹ä»¶å¤„ç†å™¨ä¸­çš„éªŒè¯é€»è¾‘
function validate_payment_event(event_data, context)
    -- éªŒè¯é‡‘é¢åŒ¹é…
    if event_data.amount < context.expected_amount then
        return false, "AMOUNT_TOO_LOW"
    end

    -- éªŒè¯è®¢å•IDåŒ¹é…
    if event_data.order_id ~= context.order_id then
        return false, "ORDER_ID_MISMATCH"
    end

    -- éªŒè¯äº¤æ˜“IDå”¯ä¸€æ€§
    if is_transaction_processed(event_data.transaction_id) then
        return false, "DUPLICATE_TRANSACTION"
    end

    return true
end
```

### 3. å¹¶å‘å¤„ç†
```lua
-- å¤„ç†é‡å¤äº‹ä»¶
function handle_duplicate_event(saga_id, event_id)
    -- æ£€æŸ¥äº‹ä»¶æ˜¯å¦å·²è¢«å¤„ç†
    if is_event_processed(saga_id, event_id) then
        -- é™é»˜å¿½ç•¥é‡å¤äº‹ä»¶
        return { ignored = true, reason = "DUPLICATE_EVENT" }
    end

    -- æ ‡è®°äº‹ä»¶ä¸ºå·²å¤„ç†
    mark_event_processed(saga_id, event_id)
    return { can_process = true }
end
```

## æ€§èƒ½å’Œå¯æ‰©å±•æ€§è€ƒè™‘

### 1. å†…å­˜ç®¡ç†ï¼ˆåŒºå—é“¾å‹å¥½è®¾è®¡ï¼‰
```lua
-- å¤–éƒ¨ç›‘æ§è§¦å‘çš„ç­‰å¾…çŠ¶æ€æ¸…ç†
function cleanup_waiting_saga_on_timeout(saga_id)
    local saga_instance = saga.get_saga_instance(saga_id)
    if not saga_instance or not saga_instance.waiting_state then
        return false  -- Sagaä¸å­˜åœ¨æˆ–ä¸åœ¨ç­‰å¾…çŠ¶æ€
    end

    -- æ£€æŸ¥æ˜¯å¦çœŸçš„è¶…æ—¶
    local current_time = os.time()
    local wait_time = current_time - saga_instance.waiting_state.started_at
    if wait_time <= saga_instance.waiting_state.max_wait_time_seconds then
        return false  -- è¿˜æ²¡æœ‰è¶…æ—¶
    end

    -- æ‰§è¡Œè¶…æ—¶è¡¥å¿
    local timeout_action = saga_instance.waiting_state.timeout_action
    if timeout_action then
        -- è°ƒç”¨è¶…æ—¶è¡¥å¿æ–¹æ³•ï¼ˆé€šè¿‡æ¶ˆæ¯æœºåˆ¶è§¦å‘ï¼‰
        ao.send({
            Target = ao.id,
            Tags = {
                Action = "ExecuteTimeoutCompensation",
                ["X-SagaId"] = tostring(saga_id),
                TimeoutAction = timeout_action
            },
            Data = json.encode({
                timeout_context = saga_instance.waiting_state.timeout_context or {},
                wait_time = wait_time,
                max_wait_time = saga_instance.waiting_state.max_wait_time_seconds
            })
        })
    end

    -- æ¸…ç†ç­‰å¾…çŠ¶æ€
    saga_instance.waiting_state = nil
    entity_coll.update(saga_instances, saga_id, saga_instance)

    return true
end

-- å¤–éƒ¨ç›‘æ§å¤„ç†å™¨ï¼ˆåŒºå—é“¾å‹å¥½ï¼šè¢«åŠ¨å“åº”å¤–éƒ¨æŸ¥è¯¢ï¼‰
Handlers.add(
  "check_saga_timeout",
  Handlers.utils.hasMatchingTag("Action", "CheckSagaTimeout"),
  function(msg)
    local saga_id = tonumber(msg.Tags["X-SagaId"])
    if not saga_id then
        messaging.respond(false, { error = "INVALID_SAGA_ID" }, msg)
        return
    end

    local cleaned = cleanup_waiting_saga_on_timeout(saga_id)
    messaging.respond(true, { timeout_triggered = cleaned }, msg)
  end
)
```

### 2. äº‹ä»¶å¤„ç†æ€§èƒ½ä¼˜åŒ–
```lua
-- äº‹ä»¶ç´¢å¼•ä¼˜åŒ–
local event_index = {
    -- saga_id -> { event_type -> { event_id -> processed_at } }
}

function index_event(saga_id, event_type, event_id, processed_at)
    if not event_index[saga_id] then
        event_index[saga_id] = {}
    end
    if not event_index[saga_id][event_type] then
        event_index[saga_id][event_type] = {}
    end
    event_index[saga_id][event_type][event_id] = processed_at
end

function is_event_processed(saga_id, event_type, event_id)
    return event_index[saga_id] and
           event_index[saga_id][event_type] and
           event_index[saga_id][event_type][event_id]
end

-- æ‰¹é‡äº‹ä»¶å¤„ç†
function process_batch_events(events)
    local results = {}
    for i, event in ipairs(events) do
        local success, result = pcall(function()
            return process_single_event(event)
        end)
        results[i] = { success = success, result = result }
    end
    return results
end
```

### 3. ç›‘æ§å’Œå¯è§‚æµ‹æ€§
```lua
-- Sagaç­‰å¾…çŠ¶æ€ç›‘æ§
function collect_waiting_saga_metrics()
    local metrics = {
        total_waiting_sagas = 0,
        expired_waiting_sagas = 0,
        average_wait_time = 0,
        waiting_saga_by_event_type = {},
        timeout_distribution = {}
    }

    local current_time = os.time()
    local total_wait_time = 0

    for saga_id, saga_instance in pairs(saga_instances) do
        if saga_instance.waiting_state and saga_instance.waiting_state.is_waiting then
            metrics.total_waiting_sagas = metrics.total_waiting_sagas + 1

            -- è®¡ç®—ç­‰å¾…æ—¶é—´
            local wait_time = current_time - saga_instance.waiting_state.started_at
            total_wait_time = total_wait_time + wait_time

            -- æ£€æŸ¥æ˜¯å¦è¶…æ—¶ï¼ˆåŒºå—é“¾å‹å¥½æ£€æŸ¥ï¼‰
            local wait_time = current_time - saga_instance.waiting_state.started_at
            if wait_time > saga_instance.waiting_state.max_wait_time_seconds then
                metrics.expired_waiting_sagas = metrics.expired_waiting_sagas + 1
            end

            -- æŒ‰äº‹ä»¶ç±»å‹ç»Ÿè®¡
            local event_type = saga_instance.waiting_state.event_type
            metrics.waiting_saga_by_event_type[event_type] =
                (metrics.waiting_saga_by_event_type[event_type] or 0) + 1

            -- è¶…æ—¶åˆ†å¸ƒï¼ˆæŒ‰å°æ—¶åˆ†ç»„ï¼ŒåŒºå—é“¾å‹å¥½ï¼‰
            local hours_remaining = math.floor(
                (saga_instance.waiting_state.max_wait_time_seconds - wait_time) / 3600)
            if hours_remaining >= 0 then
                metrics.timeout_distribution[hours_remaining] =
                    (metrics.timeout_distribution[hours_remaining] or 0) + 1
            end
        end
    end

    if metrics.total_waiting_sagas > 0 then
        metrics.average_wait_time = total_wait_time / metrics.total_waiting_sagas
    end

    return metrics
end

-- æš´éœ²ç›‘æ§æ¥å£
Handlers.add(
  "saga_metrics",
  Handlers.utils.hasMatchingTag("Action", "GetSagaMetrics"),
  function(msg)
    local metrics = collect_waiting_saga_metrics()
    messaging.respond(true, metrics, msg)
  end
)
```

## å®‰å…¨æ€§è€ƒè™‘

### 1. äº‹ä»¶éªŒè¯å’Œæˆæƒ
```lua
-- äº‹ä»¶æ¥æºéªŒè¯
function validate_event_source(event_source, allowed_sources)
    if not allowed_sources then return true end

    for _, allowed in ipairs(allowed_sources) do
        if event_source == allowed then
            return true
        end
    end

    return false
end

-- Sagaæ‰€æœ‰æƒéªŒè¯
function validate_saga_ownership(saga_id, requester_id, context)
    -- éªŒè¯requesteræ˜¯å¦æœ‰æƒè§¦å‘æ­¤Sagaçš„äº‹ä»¶
    -- ä¾‹å¦‚ï¼Œæ£€æŸ¥è®¢å•æ‰€æœ‰è€…æ˜¯å¦åŒ¹é…
    if context.customer_id ~= requester_id then
        return false, "UNAUTHORIZED_SAGA_ACCESS"
    end

    return true
end

-- äº‹ä»¶æ•°æ®å®Œæ•´æ€§éªŒè¯
function validate_event_integrity(event_data, expected_schema)
    -- ä½¿ç”¨JSON SchemaéªŒè¯äº‹ä»¶æ•°æ®ç»“æ„
    -- è¿™é‡Œç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥ä½¿ç”¨ä¸“é—¨çš„éªŒè¯åº“
    for field, validator in pairs(expected_schema) do
        if not validator(event_data[field]) then
            return false, string.format("FIELD_VALIDATION_FAILED: %s", field)
        end
    end

    return true
end
```

### 2. é˜²æ­¢é‡æ”¾æ”»å‡»
```lua
-- å…¨å±€äº‹ä»¶IDæ³¨å†Œè¡¨
local processed_event_ids = {}  -- event_id -> processed_at
local EVENT_ID_TTL = 24 * 60 * 60  -- 24å°æ—¶

function is_event_replayed(event_id)
    local processed_at = processed_event_ids[event_id]
    if not processed_at then
        return false
    end

    -- æ£€æŸ¥æ˜¯å¦åœ¨TTLå†…
    if os.time() - processed_at > EVENT_ID_TTL then
        -- TTLè¿‡æœŸï¼Œæ¸…ç†å¹¶å…è®¸é‡æ”¾
        processed_event_ids[event_id] = nil
        return false
    end

    return true
end

function mark_event_processed(event_id)
    processed_event_ids[event_id] = os.time()

    -- å®šæœŸæ¸…ç†è¿‡æœŸçš„äº‹ä»¶ID
    cleanup_expired_event_ids()
end

function cleanup_expired_event_ids()
    local current_time = os.time()
    local expired_ids = {}

    for event_id, processed_at in pairs(processed_event_ids) do
        if current_time - processed_at > EVENT_ID_TTL then
            table.insert(expired_ids, event_id)
        end
    end

    for _, event_id in ipairs(expired_ids) do
        processed_event_ids[event_id] = nil
    end

    if #expired_ids > 0 then
        print(string.format("Cleaned up %d expired event IDs", #expired_ids))
    end
end
```

### 3. èµ„æºé™åˆ¶å’ŒDoSé˜²æŠ¤
```lua
-- Sagaå®ä¾‹æ•°é‡é™åˆ¶
local MAX_CONCURRENT_SAGAS = 10000
local MAX_WAITING_SAGAS_PER_EVENT_TYPE = 1000

function enforce_saga_limits()
    local waiting_counts = {}
    local total_waiting = 0

    -- ç»Ÿè®¡ç­‰å¾…ä¸­çš„Saga
    for saga_id, saga_instance in pairs(saga_instances) do
        if saga_instance.waiting_state and saga_instance.waiting_state.is_waiting then
            total_waiting = total_waiting + 1

            local event_type = saga_instance.waiting_state.event_type
            waiting_counts[event_type] = (waiting_counts[event_type] or 0) + 1
        end
    end

    -- æ£€æŸ¥æ€»é™åˆ¶
    if total_waiting > MAX_CONCURRENT_SAGAS then
        error("SAGA_LIMIT_EXCEEDED: Too many concurrent sagas")
    end

    -- æ£€æŸ¥æŒ‰äº‹ä»¶ç±»å‹çš„é™åˆ¶
    for event_type, count in pairs(waiting_counts) do
        if count > MAX_WAITING_SAGAS_PER_EVENT_TYPE then
            error(string.format("EVENT_TYPE_LIMIT_EXCEEDED: %s has %d waiting sagas",
                  event_type, count))
        end
    end
end

-- åœ¨åˆ›å»ºç­‰å¾…Sagaå‰æ£€æŸ¥é™åˆ¶
function create_waiting_saga(saga_type, context, waiting_config)
    enforce_saga_limits()

    -- æ£€æŸ¥äº‹ä»¶ç±»å‹çš„ç­‰å¾…é˜Ÿåˆ—é•¿åº¦
    local waiting_count = count_waiting_sagas_by_event_type(waiting_config.event_type)
    if waiting_count >= MAX_WAITING_SAGAS_PER_EVENT_TYPE then
        error("EVENT_TYPE_QUEUE_FULL: " .. waiting_config.event_type)
    end

    -- åˆ›å»ºSaga...
end
```

## è¿ç§»å’Œå…¼å®¹æ€§

### 1. å‘åå…¼å®¹æ€§ä¿è¯
```yaml
# ç°æœ‰DDDML Sagaå®šä¹‰ï¼ˆ100%å…¼å®¹ï¼‰
services:
  InventoryService:
    methods:
      ProcessInventorySurplusOrShortage:
        steps:
          GetInventoryItem:        # ç°æœ‰æ­¥éª¤å®Œå…¨ä¸å˜
            invokeParticipant: "InventoryItem.GetInventoryItem"
            onReply: "-- TODO"
          CreateSingleLineInOut:
            invokeParticipant: "InOut.CreateSingleLineInOut"
            # ... å…¶ä»–å±æ€§å®Œå…¨ä¸å˜
```

### 2. æ¸è¿›å¼é‡‡ç”¨ç­–ç•¥
```yaml
# å¯ä»¥é€æ­¥åœ¨ç°æœ‰Sagaä¸­æ·»åŠ waitForEventæ­¥éª¤
services:
  InventoryService:
    methods:
      # ç°æœ‰æ–¹æ³•ä¿æŒä¸å˜
      ProcessInventorySurplusOrShortage:  # ä¸ä½¿ç”¨ç­‰å¾…åŠŸèƒ½
        steps:
          GetInventoryItem:
            invokeParticipant: "InventoryItem.GetInventoryItem"

      # æ–°æ–¹æ³•å¯ä»¥ä½¿ç”¨ç­‰å¾…åŠŸèƒ½
      ProcessAsyncInventoryAdjustment:   # ä½¿ç”¨ç­‰å¾…åŠŸèƒ½
        steps:
          ValidateRequest:
            invokeLocal: "validate_request"
          WaitForApproval:
            waitForEvent: "manager_approval"     # å£°æ˜ç­‰å¾…çš„æˆåŠŸäº‹ä»¶
            onSuccess:                           # å¤„ç†æˆåŠŸäº‹ä»¶ï¼ŒåŒ…æ‹¬è¿‡æ»¤é€»è¾‘
              Lua: "-- å¤„ç†å®¡æ‰¹æˆåŠŸé€»è¾‘"         # è¿‡æ»¤å’Œå¤„ç†é€»è¾‘åœ¨ç”Ÿæˆçš„ä»£ç ä¸­å®ç°
            exportVariables:                     # æ˜ å°„å®¡æ‰¹ç»“æœ
              approval_timestamp: ".data.approved_at"
              approver_id: ".data.approver_id"
            failureEvent: "approval_rejected"    # å£°æ˜å¤±è´¥äº‹ä»¶ç±»å‹
            onFailure:                           # å¤„ç†å¤±è´¥äº‹ä»¶
              Lua: "-- å¤„ç†å®¡æ‰¹æ‹’ç»é€»è¾‘"
            maxWaitTime: "24h"                   # åŒºå—é“¾å‹å¥½ï¼šæœ€å¤§ç­‰å¾…æ—¶é—´
            withCompensation: "cancel_adjustment"
          ApplyAdjustment:
            invokeParticipant: "InventoryItem.AdjustInventory"
```

### 3. ç‰ˆæœ¬æ§åˆ¶å’Œç‰¹æ€§æ ‡å¿—
```lua
-- ç‰¹æ€§æ ‡å¿—æ§åˆ¶
local SAGA_WAIT_FEATURE_ENABLED = true

function is_wait_feature_enabled()
    return SAGA_WAIT_FEATURE_ENABLED
end

-- åœ¨è¿è¡Œæ—¶æ£€æŸ¥ç‰¹æ€§æ”¯æŒ
function create_saga_with_wait_support(saga_config)
    if saga_config.uses_wait_events and not is_wait_feature_enabled() then
        error("WAIT_EVENTS_NOT_SUPPORTED: Feature not enabled")
    end

    -- åˆ›å»ºSaga...
end
```

## æµ‹è¯•ç­–ç•¥

### 1. å•å…ƒæµ‹è¯•
```lua
-- æµ‹è¯•äº‹ä»¶è¿‡æ»¤é€»è¾‘
function test_event_filter()
    local context = { order_id = 123, expected_amount = 100 }
    local event_data = { order_id = 123, amount = 100 }

    local success, result = saga.evaluate_event_filter(
        "event.data.amount >= context.expected_amount and event.data.order_id == context.order_id",
        event_data, context
    )

    assert(success, "Filter evaluation should succeed")
    assert(result, "Filter should return true for matching data")
end

-- æµ‹è¯•è¶…æ—¶å¤„ç†ï¼ˆåŒºå—é“¾å‹å¥½ï¼‰
function test_timeout_handling()
    -- æ¨¡æ‹Ÿåˆ›å»ºç­‰å¾…Saga
    local saga_id = create_test_waiting_saga("payment_completed", 1) -- 1ç§’æœ€å¤§ç­‰å¾…æ—¶é—´

    -- ç­‰å¾…è¶…æ—¶
    sleep(2)

    -- å¤–éƒ¨ç›‘æ§è§¦å‘è¶…æ—¶æ£€æŸ¥ï¼ˆåŒºå—é“¾å‹å¥½ï¼šè¢«åŠ¨å“åº”ï¼‰
    local result = send_timeout_check_message(saga_id)
    assert(result.timeout_triggered == true, "Should have triggered timeout")

    -- éªŒè¯è¡¥å¿è¢«æ‰§è¡Œ
    local saga = saga.get_saga_instance(saga_id)
    assert(saga.compensating == true, "Saga should be in compensating state")
end
```

### 2. é›†æˆæµ‹è¯•
```lua
-- ç«¯åˆ°ç«¯æ”¯ä»˜æµç¨‹æµ‹è¯•
function test_payment_flow()
    -- 1. åˆ›å»ºè®¢å•
    local order_id = create_test_order(100)

    -- 2. å¯åŠ¨æ”¯ä»˜Saga
    local saga_id = start_payment_saga(order_id, 100)

    -- 3. éªŒè¯Sagaè¿›å…¥ç­‰å¾…çŠ¶æ€
    local saga = saga.get_saga_instance(saga_id)
    assert(saga.waiting_state.is_waiting, "Saga should be waiting")
    assert(saga.waiting_state.event_type == "payment_completed", "Should wait for payment")

    -- 4. æ¨¡æ‹Ÿæ”¯ä»˜å®Œæˆäº‹ä»¶
    trigger_payment_event(order_id, 100, "tx_123")

    -- 5. éªŒè¯Sagaç»§ç»­æ‰§è¡Œå¹¶å®Œæˆ
    local final_saga = saga.get_saga_instance(saga_id)
    assert(final_saga.completed, "Saga should be completed")
    assert(not final_saga.waiting_state.is_waiting, "Should not be waiting anymore")

    -- 6. éªŒè¯è®¢å•çŠ¶æ€æ›´æ–°
    local order = get_order(order_id)
    assert(order.status == "paid", "Order should be paid")
end
```

### 3. å‹åŠ›æµ‹è¯•
```lua
-- å¹¶å‘ç­‰å¾…Sagaæµ‹è¯•
function test_concurrent_waiting_sagas()
    local saga_count = 1000
    local sagas = {}

    -- åˆ›å»ºå¤šä¸ªç­‰å¾…Saga
    for i = 1, saga_count do
        local saga_id = create_test_waiting_saga("test_event_" .. i, 300) -- 5åˆ†é’Ÿè¶…æ—¶
        sagas[i] = saga_id
    end

    -- éªŒè¯æ‰€æœ‰Sagaéƒ½åœ¨ç­‰å¾…
    for i, saga_id in ipairs(sagas) do
        local saga = saga.get_saga_instance(saga_id)
        assert(saga.waiting_state.is_waiting, "Saga " .. i .. " should be waiting")
    end

    -- æ‰¹é‡è§¦å‘äº‹ä»¶
    for i = 1, saga_count do
        trigger_test_event("test_event_" .. i, "event_" .. i)
    end

    -- éªŒè¯æ‰€æœ‰Sagaéƒ½å®Œæˆ
    for i, saga_id in ipairs(sagas) do
        local saga = saga.get_saga_instance(saga_id)
        assert(saga.completed, "Saga " .. i .. " should be completed")
    end
end
```

## éƒ¨ç½²å’Œè¿ç»´æŒ‡å—

### 1. AOè¿›ç¨‹æ¶æ„è®¾è®¡ï¼ˆåŒºå—é“¾å‹å¥½ï¼‰

#### æ¨èçš„è¿›ç¨‹åˆ†ç¦»ç­–ç•¥
```lua
-- å»ºè®®çš„AOè¿›ç¨‹æ¶æ„ï¼ˆåŒºå—é“¾ç¯å¢ƒä¸‹ï¼‰
-- è¿›ç¨‹1: ä¸»ä¸šåŠ¡æœåŠ¡ï¼ˆåŒ…å«Sagaé€»è¾‘ï¼‰
local BUSINESS_PROCESS_ID = "BUSINESS_SERVICE_001"

-- è¿›ç¨‹2: äº‹ä»¶èšåˆå™¨ï¼ˆå¤„ç†å¤–éƒ¨äº‹ä»¶ï¼‰
local EVENT_AGGREGATOR_PROCESS_ID = "EVENT_AGGREGATOR_001"

-- è¿›ç¨‹3: æ”¯ä»˜ç½‘å…³é›†æˆ
local PAYMENT_GATEWAY_PROCESS_ID = "PAYMENT_GATEWAY_001"

-- è¿›ç¨‹4: è¶…æ—¶ç›‘æ§æœåŠ¡ï¼ˆåŒºå—é“¾å‹å¥½ï¼šå®šæœŸæ£€æŸ¥è€Œéä¸»åŠ¨è§¦å‘ï¼‰
local TIMEOUT_MONITOR_PROCESS_ID = "TIMEOUT_MONITOR_001"

-- æ³¨æ„ï¼šåŒºå—é“¾ç¯å¢ƒä¸‹æ²¡æœ‰ä¸»åŠ¨å®šæ—¶å™¨ï¼Œæ‰€æœ‰è¶…æ—¶ç›‘æ§éƒ½éœ€è¦å¤–éƒ¨è§¦å‘
-- å¤–éƒ¨ç³»ç»Ÿï¼ˆå¦‚é“¾ä¸‹æœåŠ¡ï¼‰éœ€è¦å®šæœŸæŸ¥è¯¢å¹¶è§¦å‘è¶…æ—¶è¡¥å¿
```

#### è¿›ç¨‹é—´é€šä¿¡æ¨¡å¼
```lua
-- ä¸šåŠ¡è¿›ç¨‹å‘äº‹ä»¶èšåˆå™¨æ³¨å†Œç›‘å¬
function register_event_listener(saga_type, event_type, business_process_id)
    ao.send({
        Target = EVENT_AGGREGATOR_PROCESS_ID,
        Tags = {
            Action = "RegisterEventListener",
            SagaType = saga_type,
            EventType = event_type,
            ListenerProcess = business_process_id
        }
    })
end

-- è¶…æ—¶ç›‘æ§æœåŠ¡æ£€æŸ¥Sagaè¶…æ—¶çŠ¶æ€ï¼ˆåŒºå—é“¾å‹å¥½ï¼šè¢«åŠ¨å“åº”æŸ¥è¯¢ï¼‰
function check_saga_timeout_status(saga_id)
    ao.send({
        Target = BUSINESS_PROCESS_ID,
        Tags = {
            Action = "CheckSagaTimeout",
            ["X-SagaId"] = tostring(saga_id)
        },
        Data = json.encode({
            check_time = os.time()
        })
    })
end

-- äº‹ä»¶èšåˆå™¨è½¬å‘äº‹ä»¶åˆ°å¯¹åº”çš„ä¸šåŠ¡è¿›ç¨‹
function forward_event_to_saga(event_data, saga_id, business_process_id)
    ao.send({
        Target = business_process_id,
        Tags = {
            Action = "Saga_EventTriggered",
            ["X-SagaId"] = tostring(saga_id),
            ["X-EventType"] = event_data.event_type,
            ["X-EventId"] = event_data.event_id,
            ["X-EventSource"] = event_data.source
        },
        Data = json.encode(event_data)
    })
end
```

### 2. é…ç½®ç®¡ç†

#### ç¯å¢ƒç‰¹å®šçš„é…ç½®
```lua
-- å¼€å‘ç¯å¢ƒé…ç½®
local DEV_CONFIG = {
    max_waiting_sagas = 100,
    event_ttl_seconds = 300,  -- 5åˆ†é’Ÿ
    cleanup_interval_seconds = 60,
    enable_debug_logging = true
}

-- ç”Ÿäº§ç¯å¢ƒé…ç½®
local PROD_CONFIG = {
    max_waiting_sagas = 10000,
    event_ttl_seconds = 86400,  -- 24å°æ—¶
    cleanup_interval_seconds = 300,  -- 5åˆ†é’Ÿ
    enable_debug_logging = false
}

-- æ ¹æ®ç¯å¢ƒåŠ è½½é…ç½®
local CONFIG = os.getenv("AO_ENV") == "production" and PROD_CONFIG or DEV_CONFIG
```

#### åŠ¨æ€é…ç½®æ›´æ–°
```lua
-- æ”¯æŒè¿è¡Œæ—¶é…ç½®æ›´æ–°
Handlers.add(
  "update_config",
  Handlers.utils.hasMatchingTag("Action", "UpdateSagaConfig"),
  function(msg)
    local new_config = json.decode(msg.Data)

    -- éªŒè¯é…ç½®
    if validate_config(new_config) then
        CONFIG = merge_configs(CONFIG, new_config)
        print("Saga configuration updated successfully")
        messaging.respond(true, { status = "updated" }, msg)
    else
        messaging.respond(false, { error = "INVALID_CONFIG" }, msg)
    end
  end
)
```

### 3. ç›‘æ§å’Œå‘Šè­¦

#### å…³é”®æŒ‡æ ‡ç›‘æ§
```lua
-- æ ¸å¿ƒç›‘æ§æŒ‡æ ‡
local MONITORING_METRICS = {
    -- Sagaå®ä¾‹çŠ¶æ€
    active_sagas = 0,
    waiting_sagas = 0,
    completed_sagas_last_hour = 0,
    failed_sagas_last_hour = 0,

    -- äº‹ä»¶å¤„ç†
    events_received_last_minute = 0,
    events_processed_last_minute = 0,
    events_failed_last_minute = 0,

    -- æ€§èƒ½æŒ‡æ ‡
    average_event_processing_time = 0,
    average_saga_completion_time = 0,

    -- é”™è¯¯ç»Ÿè®¡
    timeout_errors_last_hour = 0,
    validation_errors_last_hour = 0,
    system_errors_last_hour = 0
}

-- å®šæœŸæ”¶é›†å’Œä¸ŠæŠ¥æŒ‡æ ‡
function collect_and_report_metrics()
    local metrics = collect_waiting_saga_metrics()

    -- æ›´æ–°å…¨å±€æŒ‡æ ‡
    MONITORING_METRICS.active_sagas = metrics.total_waiting_sagas
    MONITORING_METRICS.waiting_sagas = metrics.total_waiting_sagas

    -- å‘é€åˆ°ç›‘æ§æœåŠ¡ï¼ˆåŒºå—é“¾å‹å¥½ï¼šå®šæœŸæŸ¥è¯¢è§¦å‘çš„ç›‘æ§ï¼‰
    ao.send({
        Target = MONITORING_PROCESS_ID,
        Tags = {
            Action = "ReportSagaMetrics",
            MetricType = "SagaWaitingMetrics",
            ReportTime = tostring(os.time())
        },
        Data = json.encode(metrics)
    })
end
```

#### å‘Šè­¦è§„åˆ™
```lua
-- å‘Šè­¦é˜ˆå€¼é…ç½®ï¼ˆåŒºå—é“¾ç¯å¢ƒä¸‹ï¼‰
local ALERT_THRESHOLDS = {
    max_waiting_sagas = 5000,
    max_overdue_rate = 0.1,  -- 10% (è¶…è¿‡æœ€å¤§ç­‰å¾…æ—¶é—´çš„Sagaæ¯”ä¾‹)
    max_error_rate = 0.05,   -- 5%
    max_average_wait_time = 1800  -- 30åˆ†é’Ÿ
}

-- æ£€æŸ¥å‘Šè­¦æ¡ä»¶
function check_alert_conditions(metrics)
    local alerts = {}

    if metrics.total_waiting_sagas > ALERT_THRESHOLDS.max_waiting_sagas then
        table.insert(alerts, {
            level = "CRITICAL",
            message = string.format("Too many waiting sagas: %d", metrics.total_waiting_sagas)
        })
    end

    -- è®¡ç®—è¶…æ—¶çš„Sagaæ¯”ä¾‹ï¼ˆåŒºå—é“¾å‹å¥½æ£€æŸ¥ï¼‰
    local overdue_sagas = metrics.expired_waiting_sagas or 0
    if metrics.total_waiting_sagas > 0 then
        local overdue_rate = overdue_sagas / metrics.total_waiting_sagas
        if overdue_rate > ALERT_THRESHOLDS.max_overdue_rate then
            table.insert(alerts, {
                level = "WARNING",
                message = string.format("High overdue saga rate: %.2f%% (%d/%d)",
                      overdue_rate * 100, overdue_sagas, metrics.total_waiting_sagas)
            })
        end
    end

    if metrics.average_wait_time > ALERT_THRESHOLDS.max_average_wait_time then
        table.insert(alerts, {
            level = "WARNING",
            message = string.format("High average wait time: %d seconds", metrics.average_wait_time)
        })
    end

    -- å‘é€å‘Šè­¦
    if #alerts > 0 then
        send_alerts(alerts)
    end
end
```

## æ•…éšœæ’é™¤æŒ‡å—

### å¸¸è§é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ

#### 1. Sagaå¡åœ¨ç­‰å¾…çŠ¶æ€
**ç°è±¡**: Sagaé•¿æ—¶é—´å¤„äºç­‰å¾…çŠ¶æ€ï¼Œäº‹ä»¶ä¸è¢«è§¦å‘

**å¯èƒ½åŸå› **:
- äº‹ä»¶è¿‡æ»¤æ¡ä»¶è¿‡äºä¸¥æ ¼
- äº‹ä»¶æ¶ˆæ¯æ ¼å¼ä¸æ­£ç¡®
- äº‹ä»¶è·¯ç”±é…ç½®é”™è¯¯
- å¤–éƒ¨ç³»ç»Ÿæœªå‘é€äº‹ä»¶
- åŒºå—é“¾ç½‘ç»œå»¶è¿Ÿå¯¼è‡´äº‹ä»¶ä¸¢å¤±

**è¯Šæ–­æ­¥éª¤**:
```lua
-- æ£€æŸ¥SagaçŠ¶æ€
function diagnose_stuck_saga(saga_id)
    local saga = saga.get_saga_instance(saga_id)
    if not saga then
        return "SAGA_NOT_FOUND"
    end

    if not saga.waiting_state or not saga.waiting_state.is_waiting then
        return "NOT_WAITING"
    end

    -- æ£€æŸ¥è¶…æ—¶ï¼ˆåŒºå—é“¾å‹å¥½æ£€æŸ¥ï¼‰
    local current_time = os.time()
    local wait_time = current_time - saga.waiting_state.started_at
    if wait_time > saga.waiting_state.max_wait_time_seconds then
        return "TIMED_OUT"
    end

    -- æ£€æŸ¥äº‹ä»¶ç›‘å¬å™¨æ³¨å†Œ
    local event_type = saga.waiting_state.event_type
    if not is_event_listener_registered(event_type, saga_id) then
        return "EVENT_LISTENER_NOT_REGISTERED"
    end

    -- æ£€æŸ¥æœ€è¿‘çš„äº‹ä»¶
    local recent_events = get_recent_events(event_type, 10)
    if #recent_events == 0 then
        return "NO_RECENT_EVENTS"
    end

    -- æ£€æŸ¥äº‹ä»¶è¿‡æ»¤
    for _, event in ipairs(recent_events) do
        local can_trigger = evaluate_event_filter(
            saga.waiting_state.event_filter,
            event.data,
            saga.context
        )
        if can_trigger then
            return "EVENT_FILTER_BLOCKING"
        end
    end

    return "UNKNOWN_ISSUE"
end
```

**è§£å†³æ–¹æ¡ˆ**:
- æ”¾å®½äº‹ä»¶è¿‡æ»¤æ¡ä»¶
- æ£€æŸ¥äº‹ä»¶æ¶ˆæ¯æ ¼å¼
- éªŒè¯äº‹ä»¶è·¯ç”±é…ç½®
- æ‰‹åŠ¨è§¦å‘äº‹ä»¶ï¼ˆå¼€å‘ç¯å¢ƒï¼‰

#### 2. äº‹ä»¶é‡å¤å¤„ç†
**ç°è±¡**: åŒä¸€ä¸ªäº‹ä»¶è¢«å¤„ç†å¤šæ¬¡

**åŸå› **: é‡æ”¾æ”»å‡»é˜²æŠ¤æœºåˆ¶æœªæ­£ç¡®å·¥ä½œ

**è§£å†³æ–¹æ¡ˆ**:
```lua
-- åŠ å¼ºäº‹ä»¶å»é‡æ£€æŸ¥
function enhanced_event_deduplication(event_id, saga_id, event_type)
    -- å¤šå±‚æ£€æŸ¥
    local checks = {
        function() return is_event_processed(saga_id, event_type, event_id) end,
        function() return is_event_replayed(event_id) end,
        function() return check_saga_event_history(saga_id, event_id) end
    }

    for _, check in ipairs(checks) do
        if check() then
            return true, "DUPLICATE_EVENT"
        end
    end

    return false
end
```

#### 3. å†…å­˜æ³„æ¼
**ç°è±¡**: ç³»ç»Ÿå†…å­˜æŒç»­å¢é•¿

**åŸå› **: ç­‰å¾…çŠ¶æ€çš„Sagaå®ä¾‹æœªè¢«åŠæ—¶æ¸…ç†

**è§£å†³æ–¹æ¡ˆ**:
```lua
-- åŠ å¼ºå†…å­˜ç®¡ç†
function aggressive_memory_cleanup()
    local current_time = os.time()
    local cleaned = { sagas = 0, events = 0 }

    -- æ¸…ç†è¶…æ—¶çš„ç­‰å¾…Saga
    for saga_id, saga in pairs(saga_instances) do
        if saga.waiting_state and
           saga.waiting_state.timeout_at < current_time then
            execute_timeout_compensation(saga_id)
            saga_instances[saga_id] = nil
            cleaned.sagas = cleaned.sagas + 1
        end
    end

    -- æ¸…ç†è¿‡æœŸçš„äº‹ä»¶è®°å½•
    cleaned.events = cleanup_expired_event_ids()

    -- å¼ºåˆ¶åƒåœ¾å›æ”¶
    collectgarbage("collect")

    print(string.format("Memory cleanup: %d sagas, %d events",
          cleaned.sagas, cleaned.events))

    return cleaned
end
```

#### 4. æ€§èƒ½ä¸‹é™
**ç°è±¡**: äº‹ä»¶å¤„ç†å»¶è¿Ÿå¢åŠ 

**åŸå› **: äº‹ä»¶é˜Ÿåˆ—ç§¯å‹æˆ–å¤„ç†ç“¶é¢ˆ

**è¯Šæ–­å’Œè§£å†³æ–¹æ¡ˆ**:
```lua
-- æ€§èƒ½ç›‘æ§å’Œä¼˜åŒ–
function diagnose_performance_issues()
    local diagnostics = {
        event_queue_length = get_event_queue_length(),
        average_processing_time = get_average_event_processing_time(),
        memory_usage = collectgarbage("count"),
        active_coroutines = get_active_coroutine_count()
    }

    -- æ£€æŸ¥é˜Ÿåˆ—ç§¯å‹
    if diagnostics.event_queue_length > 1000 then
        enable_batch_processing()
    end

    -- æ£€æŸ¥å†…å­˜å‹åŠ›
    if diagnostics.memory_usage > 50 * 1024 * 1024 then  -- 50MB
        aggressive_memory_cleanup()
    end

    return diagnostics
end

-- å¯ç”¨æ‰¹é‡å¤„ç†
function enable_batch_processing()
    print("Enabling batch event processing due to queue backlog")

    -- åˆ‡æ¢åˆ°æ‰¹é‡å¤„ç†æ¨¡å¼
    EVENT_PROCESSING_MODE = "batch"
    BATCH_SIZE = 50
    BATCH_INTERVAL = 5  -- æ¯5ç§’å¤„ç†ä¸€æ‰¹
end
```

## æœ€ä½³å®è·µ

### 1. Sagaè®¾è®¡åŸåˆ™

#### ä¿æŒSagaç®€çŸ­
```yaml
# âœ… æ¨èï¼šå•ä¸€èŒè´£çš„Saga
ProcessOrderPayment:
  steps:
    ValidateOrder:
    RegisterPaymentIntent:
    WaitForPayment:
    UpdateOrderStatus:
    NotifyMerchant:

# âŒ é¿å…ï¼šè¿‡äºå¤æ‚çš„Saga
ProcessCompleteOrderFlow:  # åŒ…å«å¤ªå¤šæ­¥éª¤
  steps:
    ValidateOrder:
    CheckInventory:
    CalculateShipping:
    ProcessPayment:
    WaitForPayment:
    UpdateInventory:
    GenerateInvoice:
    SendConfirmation:
    UpdateLoyaltyPoints:
    NotifyMerchant:
    ScheduleDelivery:
    # ... æ›´å¤šæ­¥éª¤
```

#### åˆç†è®¾ç½®æœ€å¤§ç­‰å¾…æ—¶é—´ï¼ˆåŒºå—é“¾å‹å¥½ï¼‰
```yaml
# æ ¹æ®ä¸šåŠ¡åœºæ™¯è®¾ç½®åˆé€‚çš„æœ€å¤§ç­‰å¾…æ—¶é—´
WaitForPayment:
  waitForEvent: "payment_completed"
  maxWaitTime: "30m"  # æ”¯ä»˜é€šå¸¸30åˆ†é’Ÿè¶…æ—¶

WaitForApproval:
  waitForEvent: "manager_approval"
  maxWaitTime: "24h"  # å®¡æ‰¹å¯èƒ½éœ€è¦24å°æ—¶

WaitForDeliveryConfirmation:
  waitForEvent: "delivery_confirmed"
  maxWaitTime: "7d"   # ç‰©æµç¡®è®¤å¯èƒ½éœ€è¦7å¤©

# æ³¨æ„ï¼šåŒºå—é“¾ç¯å¢ƒä¸‹éœ€è¦å¤–éƒ¨ç›‘æ§ç³»ç»Ÿå®šæœŸæ£€æŸ¥è¶…æ—¶
# ç›‘æ§é—´éš”å»ºè®®ï¼šæ”¯ä»˜30åˆ†é’Ÿæ£€æŸ¥é—´éš”5åˆ†é’Ÿï¼Œå®¡æ‰¹24å°æ—¶æ£€æŸ¥é—´éš”1å°æ—¶
```

### 2. äº‹ä»¶è®¾è®¡æœ€ä½³å®è·µ

#### ä½¿ç”¨æè¿°æ€§äº‹ä»¶åç§°
```lua
# âœ… å¥½çš„äº‹ä»¶å‘½å
"payment_completed"
"order_cancelled"
"shipment_delivered"
"inventory_updated"

# âŒ é¿å…çš„å‘½å
"event1"
"callback"
"done"
```

#### åŒ…å«å®Œæ•´çš„äº‹ä»¶ä¸Šä¸‹æ–‡
```lua
-- å¥½çš„äº‹ä»¶æ•°æ®ç»“æ„
local payment_event = {
    event_type = "payment_completed",
    event_data = {
        order_id = "ORDER_123",
        amount = 99.99,
        currency = "USD",
        transaction_id = "TX_ABC123",
        payment_method = "credit_card",
        processed_at = os.time(),
        gateway_reference = "GW_REF_456"
    },
    metadata = {
        source = "payment_gateway",
        version = "2.1.0",
        trace_id = "TRACE_789"
    }
}
```

### 3. é”™è¯¯å¤„ç†ç­–ç•¥

#### åˆ†å±‚é”™è¯¯å¤„ç†
```lua
-- 1. äº‹ä»¶çº§åˆ«éªŒè¯
function validate_event(event_data)
    -- åŸºç¡€éªŒè¯ï¼šå¿…éœ€å­—æ®µã€æ•°æ®ç±»å‹ç­‰
end

-- 2. ä¸šåŠ¡çº§åˆ«éªŒè¯
function validate_business_rules(event_data, saga_context)
    -- ä¸šåŠ¡è§„åˆ™éªŒè¯ï¼šé‡‘é¢åŒ¹é…ã€æƒé™æ£€æŸ¥ç­‰
end

-- 3. Sagaçº§åˆ«å¤„ç†
function handle_saga_error(saga_id, error_type, error_details)
    -- æ ¹æ®é”™è¯¯ç±»å‹å†³å®šè¡¥å¿ç­–ç•¥
    if error_type == "TIMEOUT" then
        execute_timeout_compensation(saga_id)
    elseif error_type == "VALIDATION_FAILED" then
        execute_validation_compensation(saga_id)
    end
end
```

#### ä¼˜é›…é™çº§
```lua
-- æ”¯æŒé™çº§æ¨¡å¼
function enable_degraded_mode()
    print("Enabling degraded mode due to system issues")

    -- å‡å°‘å¹¶å‘é™åˆ¶
    MAX_CONCURRENT_SAGAS = MAX_CONCURRENT_SAGAS / 2

    -- å»¶é•¿è¶…æ—¶æ—¶é—´
    DEFAULT_TIMEOUT_SECONDS = DEFAULT_TIMEOUT_SECONDS * 2

    -- ç®€åŒ–äº‹ä»¶è¿‡æ»¤ï¼ˆå‡å°‘éªŒè¯å¼€é”€ï¼‰
    SIMPLIFIED_EVENT_FILTERING = true
end
```

### 4. ç›‘æ§å’Œæ—¥å¿—

#### ç»“æ„åŒ–æ—¥å¿—
```lua
-- æ ‡å‡†åŒ–æ—¥å¿—æ ¼å¼
function log_saga_event(event_type, saga_id, details)
    local log_entry = {
        timestamp = os.time(),
        level = "INFO",
        event_type = event_type,
        saga_id = saga_id,
        details = details,
        process_id = ao.id,
        version = "1.0.0"
    }

    -- å‘é€åˆ°æ—¥å¿—èšåˆå™¨
    ao.send({
        Target = LOG_AGGREGATOR_PROCESS_ID,
        Tags = { Action = "LogEvent" },
        Data = json.encode(log_entry)
    })
end

-- ä½¿ç”¨ç¤ºä¾‹
log_saga_event("saga_started", saga_id, {
    saga_type = "payment_processing",
    initial_context = context
})

log_saga_event("event_received", saga_id, {
    event_type = "payment_completed",
    processing_time = os.time() - received_at
})
```

#### å…³é”®äº‹ä»¶ç›‘æ§
```lua
-- ç›‘æ§å…³é”®Sagaç”Ÿå‘½å‘¨æœŸäº‹ä»¶
SAGA_LIFECYCLE_EVENTS = {
    "saga_created",
    "saga_waiting_started",
    "saga_event_received",
    "saga_event_processed",
    "saga_completed",
    "saga_failed",
    "saga_timeout",
    "saga_compensated"
}

function monitor_saga_lifecycle(saga_id, event, details)
    if table.contains(SAGA_LIFECYCLE_EVENTS, event) then
        -- å‘é€åˆ°ç›‘æ§ç³»ç»Ÿ
        send_monitoring_event({
            saga_id = saga_id,
            event = event,
            details = details,
            timestamp = os.time()
        })
    end
end
```

## ä¸ç°æœ‰ç³»ç»Ÿçš„é›†æˆ

### 1. ç°æœ‰DDDMLé¡¹ç›®çš„è¿ç§»

#### æ¸è¿›å¼è¿ç§»ç­–ç•¥
```yaml
# é˜¶æ®µ1ï¼šç°æœ‰Sagaä¿æŒä¸å˜ï¼Œæ–°å¢Sagaä½¿ç”¨ç­‰å¾…åŠŸèƒ½
services:
  InventoryService:
    methods:
      # ç°æœ‰æ–¹æ³•ï¼ˆä¸ä¿®æ”¹ï¼‰
      ProcessInventorySurplusOrShortage:
        steps:
          GetInventoryItem:
            invokeParticipant: "InventoryItem.GetInventoryItem"

      # æ–°å¢æ–¹æ³•ï¼ˆä½¿ç”¨ç­‰å¾…åŠŸèƒ½ï¼‰
      ProcessAsyncInventoryAdjustment:
        steps:
          ValidateRequest:
            invokeLocal: "validate_adjustment_request"
          WaitForManagerApproval:
            waitForEvent: "manager_approval"     # å£°æ˜ç­‰å¾…çš„æˆåŠŸäº‹ä»¶
            onSuccess:                           # å¤„ç†æˆåŠŸäº‹ä»¶ï¼ŒåŒ…æ‹¬è¿‡æ»¤é€»è¾‘
              Lua: "-- å¤„ç†å®¡æ‰¹æˆåŠŸé€»è¾‘"         # è¿‡æ»¤å’Œå¤„ç†é€»è¾‘åœ¨ç”Ÿæˆçš„ä»£ç ä¸­å®ç°
            exportVariables:                     # æ˜ å°„å®¡æ‰¹ç»“æœ
              approval_timestamp: ".data.approved_at"
              approver_id: ".data.approver_id"
            failureEvent: "approval_rejected"    # å£°æ˜å¤±è´¥äº‹ä»¶ç±»å‹
            onFailure:                           # å¤„ç†å¤±è´¥äº‹ä»¶
              Lua: "-- å¤„ç†å®¡æ‰¹æ‹’ç»é€»è¾‘"
            maxWaitTime: "24h"                   # åŒºå—é“¾å‹å¥½ï¼šæœ€å¤§ç­‰å¾…æ—¶é—´
            withCompensation: "cancel_adjustment"
          ApplyAdjustment:
            invokeParticipant: "InventoryItem.AdjustInventory"
```

#### å…¼å®¹æ€§æµ‹è¯•
```lua
-- ç¡®ä¿ç°æœ‰åŠŸèƒ½ä¸å—å½±å“
function test_backward_compatibility()
    -- æµ‹è¯•ç°æœ‰Sagaä»ç„¶æ­£å¸¸å·¥ä½œ
    local existing_saga_id = start_existing_saga()
    wait_for_completion(existing_saga_id)

    -- éªŒè¯ç»“æœä¸å‡çº§å‰ç›¸åŒ
    assert_saga_result_unchanged(existing_saga_id)

    -- æµ‹è¯•æ–°åŠŸèƒ½ä¸å½±å“ç°æœ‰åŠŸèƒ½
    local new_saga_id = start_new_waiting_saga()
    trigger_waiting_event(new_saga_id)

    -- éªŒè¯æ–°åŠŸèƒ½æ­£å¸¸å·¥ä½œ
    assert_new_functionality_works(new_saga_id)
end
```

### 2. ä¸å¤–éƒ¨ç³»ç»Ÿçš„é›†æˆæ¨¡å¼

#### æ¶ˆæ¯é˜Ÿåˆ—é›†æˆ
```lua
-- ä¸å¤–éƒ¨æ¶ˆæ¯é˜Ÿåˆ—çš„é›†æˆ
function integrate_with_message_queue(queue_config)
    -- æ³¨å†Œé˜Ÿåˆ—ç›‘å¬å™¨
    register_queue_listener(queue_config, function(message)
        -- è½¬æ¢æ¶ˆæ¯æ ¼å¼
        local saga_event = convert_queue_message_to_saga_event(message)

        -- è§¦å‘Sagaäº‹ä»¶
        trigger_saga_event(saga_event)
    end)
end

-- æ¶ˆæ¯æ ¼å¼è½¬æ¢
function convert_queue_message_to_saga_event(queue_message)
    return {
        event_type = map_queue_event_type(queue_message.type),
        event_data = queue_message.payload,
        saga_id = extract_saga_id_from_message(queue_message),
        event_id = generate_unique_event_id(),
        source = "external_queue"
    }
end
```

#### Webhooké›†æˆ
```lua
-- å¤„ç†å¤–éƒ¨webhook
Handlers.add(
  "webhook_handler",
  Handlers.utils.hasMatchingTag("Action", "WebhookEvent"),
  function(msg)
    -- éªŒè¯webhookæ¥æº
    if not validate_webhook_source(msg) then
        return
    end

    -- è½¬æ¢webhookä¸ºSagaäº‹ä»¶
    local saga_event = convert_webhook_to_saga_event(msg)

    -- è§¦å‘äº‹ä»¶
    trigger_saga_event(saga_event)
  end
)
```

### 3. æ‰©å±•å’Œå®šåˆ¶

#### è‡ªå®šä¹‰äº‹ä»¶è¿‡æ»¤å™¨
```lua
-- æ³¨å†Œè‡ªå®šä¹‰è¿‡æ»¤å‡½æ•°
function register_custom_event_filter(filter_name, filter_function)
    CUSTOM_EVENT_FILTERS[filter_name] = filter_function
end

-- ä½¿ç”¨ç¤ºä¾‹
register_custom_event_filter("complex_business_logic", function(event_data, context)
    -- å¤æ‚çš„ä¸šåŠ¡é€»è¾‘è¿‡æ»¤
    return complex_validation_logic(event_data, context)
end)

-- åœ¨YAMLä¸­ä½¿ç”¨
WaitForApproval:
  waitForEvent: "manager_approval"
  onSuccess:
    Lua: "custom_business_logic_filter_function(event, context)"  # ä½¿ç”¨æ³¨å†Œçš„è¿‡æ»¤å‡½æ•°
```

#### æ’ä»¶æ¶æ„æ”¯æŒ
```lua
-- æ’ä»¶æ¥å£å®šä¹‰
SagaWaitingPlugin = {
    -- æ’ä»¶å…ƒä¿¡æ¯
    name = "string",
    version = "string",
    description = "string",

    -- ç”Ÿå‘½å‘¨æœŸé’©å­
    on_saga_waiting_start = function(saga_id, waiting_config) end,
    on_event_received = function(saga_id, event_data) end,
    on_saga_waiting_timeout = function(saga_id) end,
    on_saga_continued = function(saga_id) end
}

-- æ’ä»¶ç®¡ç†ç³»ç»Ÿ
function load_saga_waiting_plugin(plugin_config)
    local plugin = require(plugin_config.path)
    register_plugin_hooks(plugin)

    return plugin
end
```

## å®æ–½è·¯çº¿å›¾å’Œé‡Œç¨‹ç¢‘

### é˜¶æ®µ1ï¼šæ¦‚å¿µéªŒè¯ï¼ˆ2-3å‘¨ï¼‰
**ç›®æ ‡**ï¼šéªŒè¯waitForEventæ¦‚å¿µçš„å¯è¡Œæ€§

**é‡Œç¨‹ç¢‘**ï¼š
- [ ] å®ŒæˆæŠ€æœ¯è§„èŒƒè®¾è®¡
- [ ] å®ç°åŸå‹äº‹ä»¶ç›‘å¬å™¨
- [ ] åˆ›å»ºç®€å•çš„æµ‹è¯•ç”¨ä¾‹
- [ ] éªŒè¯ä¸ç°æœ‰Sagaçš„å…¼å®¹æ€§

**é£é™©**ï¼šå‘ç°æ¶æ„å±‚é¢çš„å…¼å®¹æ€§é—®é¢˜
**ç¼“è§£æªæ–½**ï¼šå‡†å¤‡Bè®¡åˆ’ï¼ˆæ‰©å±•ç°æœ‰æ­¥éª¤è€Œéæ–°å¢æ­¥éª¤ç±»å‹ï¼‰

### é˜¶æ®µ2ï¼šæ ¸å¿ƒåŠŸèƒ½å¼€å‘ï¼ˆ6-8å‘¨ï¼‰
**ç›®æ ‡**ï¼šå®ç°waitForEventçš„æ ¸å¿ƒåŠŸèƒ½

**é‡Œç¨‹ç¢‘**ï¼š
- [ ] æ‰©å±•DDDML YAMLè§£æå™¨
- [ ] å®ç°ä»£ç ç”Ÿæˆå™¨å¢å¼º
- [ ] æ‰©å±•saga.luaè¿è¡Œæ—¶åº“
- [ ] å®ç°äº‹ä»¶è¿‡æ»¤å’ŒéªŒè¯
- [ ] æ·»åŠ è¶…æ—¶å¤„ç†æœºåˆ¶

**å¹¶è¡Œä»»åŠ¡**ï¼š
- å¼€å‘å•å…ƒæµ‹è¯•å¥—ä»¶
- åˆ›å»ºé›†æˆæµ‹è¯•ç¯å¢ƒ
- ç¼–å†™æŠ€æœ¯æ–‡æ¡£

### é˜¶æ®µ3ï¼šé«˜çº§åŠŸèƒ½å’Œä¼˜åŒ–ï¼ˆ4-6å‘¨ï¼‰
**ç›®æ ‡**ï¼šå®Œå–„åŠŸèƒ½å¹¶ä¼˜åŒ–æ€§èƒ½

**é‡Œç¨‹ç¢‘**ï¼š
- [ ] å®ç°ç›‘æ§å’Œå‘Šè­¦ç³»ç»Ÿ
- [ ] æ·»åŠ æ€§èƒ½ä¼˜åŒ–ï¼ˆæ‰¹é‡å¤„ç†ã€ç´¢å¼•ç­‰ï¼‰
- [ ] å®ç°å®‰å…¨ç‰¹æ€§ï¼ˆäº‹ä»¶éªŒè¯ã€é‡æ”¾ä¿æŠ¤ï¼‰
- [ ] å®Œå–„é”™è¯¯å¤„ç†å’Œæ¢å¤æœºåˆ¶

**å¹¶è¡Œä»»åŠ¡**ï¼š
- å‹åŠ›æµ‹è¯•å’Œæ€§èƒ½åŸºå‡†æµ‹è¯•
- å®‰å…¨å®¡è®¡
- ç”¨æˆ·éªŒæ”¶æµ‹è¯•

### é˜¶æ®µ4ï¼šç”Ÿäº§å°±ç»ªå’Œæ–‡æ¡£ï¼ˆ3-4å‘¨ï¼‰
**ç›®æ ‡**ï¼šå‡†å¤‡ç”Ÿäº§éƒ¨ç½²

**é‡Œç¨‹ç¢‘**ï¼š
- [ ] å®Œæˆæ‰€æœ‰æµ‹è¯•ç”¨ä¾‹ï¼ˆå•å…ƒã€é›†æˆã€ç«¯åˆ°ç«¯ï¼‰
- [ ] ç¼–å†™å®Œæ•´çš„ä½¿ç”¨æ–‡æ¡£å’Œæœ€ä½³å®è·µ
- [ ] åˆ›å»ºè¿ç§»æŒ‡å—
- [ ] å‡†å¤‡éƒ¨ç½²è„šæœ¬å’Œé…ç½®

**å¹¶è¡Œä»»åŠ¡**ï¼š
- åŸ¹è®­ææ–™å‡†å¤‡
- ç¤¾åŒºé¢„è§ˆç‰ˆå‘å¸ƒ

### é˜¶æ®µ5ï¼šå‘å¸ƒå’Œæ”¯æŒï¼ˆæŒç»­ï¼‰
**ç›®æ ‡**ï¼šæˆåŠŸå‘å¸ƒå¹¶æä¾›æ”¯æŒ

**é‡Œç¨‹ç¢‘**ï¼š
- [ ] æ­£å¼ç‰ˆæœ¬å‘å¸ƒ
- [ ] ç›‘æ§ç”Ÿäº§ç¯å¢ƒè¡¨ç°
- [ ] å¤„ç†ç”¨æˆ·åé¦ˆå’Œé—®é¢˜
- [ ] è§„åˆ’åç»­åŠŸèƒ½å¢å¼º

## é£é™©è¯„ä¼°å’Œç¼“è§£ç­–ç•¥

### æŠ€æœ¯é£é™©

#### 1. å‘åå…¼å®¹æ€§ç ´å
**æ¦‚ç‡**ï¼šä¸­
**å½±å“**ï¼šé«˜
**ç¼“è§£æªæ–½**ï¼š
- ä¸¥æ ¼çš„å›å½’æµ‹è¯•
- ç‰¹æ€§æ ‡å¿—æ§åˆ¶æ–°åŠŸèƒ½å¯ç”¨
- æ¸è¿›å¼éƒ¨ç½²ç­–ç•¥
- å®Œå–„çš„å›æ»šè®¡åˆ’

#### 2. æ€§èƒ½é—®é¢˜
**æ¦‚ç‡**ï¼šä¸­
**å½±å“**ï¼šä¸­
**ç¼“è§£æªæ–½**ï¼š
- æ—©æœŸæ€§èƒ½åŸºå‡†æµ‹è¯•
- å†…å­˜ä½¿ç”¨ç›‘æ§
- æ‰¹é‡å¤„ç†ä¼˜åŒ–
- èµ„æºé™åˆ¶å’ŒèŠ‚æµæœºåˆ¶

#### 3. å¹¶å‘é—®é¢˜
**æ¦‚ç‡**ï¼šä¸­ï¼ˆä¿®å¤åé™ä¸ºä½ï¼‰
**å½±å“**ï¼šé«˜
**ç¼“è§£æªæ–½**ï¼š
- AO Actoræ¨¡å‹å¤©ç„¶çš„å•è¿›ç¨‹ç‰¹æ€§
- äº‹ä»¶å¤„ç†çš„å¹‚ç­‰æ€§è®¾è®¡ï¼ˆé€šè¿‡`processed_events`è®°å½•ï¼‰
- åŸå­çŠ¶æ€æ›´æ–°æœºåˆ¶
- äº‹ä»¶å»é‡æ£€æŸ¥é˜²æ­¢é‡å¤å¤„ç†

### ä¸šåŠ¡é£é™©

#### 1. é‡‡ç”¨é˜»åŠ›
**æ¦‚ç‡**ï¼šä¸­
**å½±å“**ï¼šä¸­
**ç¼“è§£æªæ–½**ï¼š
- æ¸…æ™°çš„ä»·å€¼ä¸»å¼ å’Œä½¿ç”¨æ¡ˆä¾‹
- æ¸è¿›å¼é‡‡ç”¨è·¯å¾„
- å®Œå–„çš„åŸ¹è®­å’Œæ”¯æŒ
- æˆåŠŸæ¡ˆä¾‹å±•ç¤º

#### 2. å¤æ‚æ€§å¢åŠ 
**æ¦‚ç‡**ï¼šä¸­
**å½±å“**ï¼šä½
**ç¼“è§£æªæ–½**ï¼š
- ç®€æ´çš„APIè®¾è®¡
- ä¸°å¯Œçš„æ–‡æ¡£å’Œç¤ºä¾‹
- æœ€ä½³å®è·µæŒ‡å—
- å·¥å…·åŒ–é…ç½®

### è¿è¥é£é™©

#### 1. ç›‘æ§ä¸è¶³
**æ¦‚ç‡**ï¼šä½
**å½±å“**ï¼šä¸­
**ç¼“è§£æªæ–½**ï¼š
- å†…ç½®ç›‘æ§å’Œå‘Šè­¦
- æ ‡å‡†åŒ–çš„æ—¥å¿—æ ¼å¼
- é›†æˆç°æœ‰ç›‘æ§ç³»ç»Ÿ
- è¿è¥æ‰‹å†Œå’Œæ•…éšœæ’é™¤æŒ‡å—

#### 2. å‡çº§å›°éš¾
**æ¦‚ç‡**ï¼šä½
**å½±å“**ï¼šä¸­
**ç¼“è§£æªæ–½**ï¼š
- è‡ªåŠ¨åŒ–å‡çº§è„šæœ¬
- å‘åå…¼å®¹æ€§ä¿è¯
- è¯¦ç»†çš„è¿ç§»æŒ‡å—
- ä¸“ä¸šçš„æ”¯æŒæœåŠ¡

## æˆåŠŸæŒ‡æ ‡å’Œè¡¡é‡æ ‡å‡†

### æŠ€æœ¯æŒ‡æ ‡

#### åŠŸèƒ½å®Œæ•´æ€§
- [ ] æ”¯æŒæ‰€æœ‰è®¡åˆ’çš„äº‹ä»¶ç±»å‹
- [ ] äº‹ä»¶è¿‡æ»¤100%å‡†ç¡®
- [ ] è¶…æ—¶å¤„ç†100%å¯é 
- [ ] ä¸ç°æœ‰Saga100%å…¼å®¹

#### æ€§èƒ½æŒ‡æ ‡
- [ ] äº‹ä»¶å¤„ç†å»¶è¿Ÿ < 100ms (P95)
- [ ] å†…å­˜ä½¿ç”¨ < 50MB (æ­£å¸¸è´Ÿè½½)
- [ ] æ”¯æŒå¹¶å‘Saga > 10,000ä¸ª
- [ ] äº‹ä»¶ååé‡ > 1,000 events/minute

#### å¯é æ€§æŒ‡æ ‡
- [ ] ç³»ç»Ÿå¯ç”¨æ€§ > 99.9%
- [ ] äº‹ä»¶ä¸¢å¤±ç‡ < 0.01%
- [ ] é”™è¯¯æ¢å¤æ—¶é—´ < 5åˆ†é’Ÿ
- [ ] æ•°æ®ä¸€è‡´æ€§100%

### ä¸šåŠ¡æŒ‡æ ‡

#### å¼€å‘è€…é‡‡ç”¨ç‡
- [ ] ç›®æ ‡ï¼šå‰6ä¸ªæœˆ50%çš„DDDMLé¡¹ç›®é‡‡ç”¨
- [ ] ç›®æ ‡ï¼šå‰12ä¸ªæœˆ80%çš„DDDMLé¡¹ç›®é‡‡ç”¨

#### ç”¨æˆ·æ»¡æ„åº¦
- [ ] å¼€å‘æ•ˆç‡æå‡ > 30%
- [ ] ä»£ç è¡Œæ•°å‡å°‘ > 40%
- [ ] bugç‡é™ä½ > 50%

#### ç”Ÿæ€ç³»ç»Ÿå½±å“
- [ ] æ–°å¢Sagaåº”ç”¨åœºæ™¯ > 10ä¸ª
- [ ] ç¤¾åŒºè´¡çŒ®å’Œæ‰©å±• > 5ä¸ª
- [ ] ç›¸å…³å·¥å…·å’Œåº“ > 3ä¸ª

## æˆæœ¬æ•ˆç›Šåˆ†æ

### å¼€å‘æˆæœ¬
- **äººåŠ›æˆæœ¬**ï¼š6-8äººæœˆï¼ˆæ ¸å¿ƒå›¢é˜Ÿï¼‰
- **åŸºç¡€è®¾æ–½æˆæœ¬**ï¼šæµ‹è¯•ç¯å¢ƒå’ŒCI/CD
- **å·¥å…·å’Œè®¸å¯è¯**ï¼šå¼€å‘å·¥å…·å’Œäº‘æœåŠ¡

### é¢„æœŸæ”¶ç›Š

#### ç›´æ¥æ”¶ç›Š
- **å¼€å‘æ•ˆç‡æå‡**ï¼šå‡å°‘50%çš„æ ·æ¿ä»£ç 
- **é”™è¯¯å‡å°‘**ï¼šé€šè¿‡æ ‡å‡†åŒ–å‡å°‘80%çš„å¸¸è§é”™è¯¯
- **ç»´æŠ¤æˆæœ¬é™ä½**ï¼šç»Ÿä¸€å®ç°å‡å°‘70%çš„ç»´æŠ¤å·¥ä½œ

#### é—´æ¥æ”¶ç›Š
- **åˆ›æ–°åŠ é€Ÿ**ï¼šæ–°ä¸šåŠ¡åœºæ™¯çš„å¿«é€ŸåŸå‹
- **ç”Ÿæ€ç³»ç»Ÿå¢é•¿**ï¼šå¸å¼•æ›´å¤šå¼€å‘è€…ä½¿ç”¨DDDML
- **ç«äº‰ä¼˜åŠ¿**ï¼šåœ¨AOç”Ÿæ€ç³»ç»Ÿä¸­æä¾›ç‹¬ç‰¹ä»·å€¼

#### ROIè®¡ç®—
- **æŠ•èµ„å›æ”¶æœŸ**ï¼š< 6ä¸ªæœˆ
- **ä¸‰å¹´ç´¯è®¡æ”¶ç›Š**ï¼šå¼€å‘æˆæœ¬çš„5-10å€
- **é•¿æœŸä»·å€¼**ï¼šæˆä¸ºDDDMLçš„æ ¸å¿ƒç«äº‰åŠ›

## æ€»ç»“ä¸å»ºè®®

### æ ¸å¿ƒä»·å€¼ä¸»å¼ 

**DDDML Sagaå¼‚æ­¥ç­‰å¾…æœºåˆ¶**ä¸æ˜¯ç®€å•çš„åŠŸèƒ½å¢å¼ºï¼Œè€Œæ˜¯**DDDMLåœ¨AOåŒºå—é“¾ç”Ÿæ€ç³»ç»Ÿä¸­çš„å…³é”®è¿›åŒ–**ï¼š

1. **å¡«è¡¥åŠŸèƒ½ç©ºç™½**ï¼šè§£å†³å½“å‰è§„èŒƒä¸æ”¯æŒå¤–éƒ¨äº‹ä»¶ç­‰å¾…çš„æ ¸å¿ƒé—®é¢˜
2. **ä¿æŒè®¾è®¡å“²å­¦**ï¼šå®Œå…¨å…¼å®¹ç°æœ‰çš„Sagaæ¨¡å‹å’Œè®¾è®¡åŸåˆ™
3. **æå‡å¼€å‘æ•ˆç‡**ï¼šä½¿å¤æ‚å¼‚æ­¥ä¸šåŠ¡æµç¨‹çš„å¼€å‘å˜å¾—ç®€å•ç›´æ¥
4. **æ‰©å±•åº”ç”¨åœºæ™¯**ï¼šå¼€å¯ç”¨æˆ·äº¤äº’ã€å¤–éƒ¨é›†æˆç­‰å…¨æ–°ä¸šåŠ¡åœºæ™¯

### å¯¹DDDMLå·¥å…·å›¢é˜Ÿçš„æœ€ç»ˆå»ºè®®

1. **ç«‹å³å¯åŠ¨**ï¼šè¿™ä¸ªåŠŸèƒ½å¯¹DDDMLåœ¨AOç”Ÿæ€ä¸­çš„ç«äº‰åŠ›è‡³å…³é‡è¦
2. **åˆ†é˜¶æ®µå®æ–½**ï¼šé‡‡ç”¨å»ºè®®çš„5é˜¶æ®µè·¯çº¿å›¾ï¼Œç¡®ä¿è´¨é‡å’Œé£é™©æ§åˆ¶
3. **é‡è§†æµ‹è¯•**ï¼šç‰¹åˆ«æ˜¯å‘åå…¼å®¹æ€§å’Œæ€§èƒ½æµ‹è¯•
4. **ç¤¾åŒºåä½œ**ï¼šåŠæ—©åˆ†äº«è®¾è®¡ï¼Œæ”¶é›†åé¦ˆï¼Œå…±åŒå®Œå–„

### å¯¹å¼€å‘è€…çš„å»ºè®®

å¦‚æœæ‚¨æ­£åœ¨ä½¿ç”¨DDDMLæ„å»ºAOåº”ç”¨ï¼š

1. **å…³æ³¨è¿™ä¸ªåŠŸèƒ½**ï¼šå®ƒå°†æå¤§åœ°ç®€åŒ–æ‚¨çš„å¼‚æ­¥ä¸šåŠ¡é€»è¾‘å¼€å‘
2. **å‚ä¸æµ‹è¯•**ï¼šåœ¨é¢„è§ˆç‰ˆå‘å¸ƒæ—¶ç§¯æå‚ä¸æµ‹è¯•å’Œåé¦ˆ
3. **è§„åˆ’è¿ç§»**ï¼šä¸ºç°æœ‰é¡¹ç›®é¢„ç•™å‡çº§åˆ°æ–°ç‰ˆæœ¬çš„æ—¶é—´
4. **å­¦ä¹ æ–°æ¨¡å¼**ï¼šæŒæ¡waitForEventçš„æœ€ä½³å®è·µ

### æŠ€æœ¯é—äº§

è¿™ä¸ªåŠŸèƒ½å°†æˆä¸º**DDDMLæŠ€æœ¯æ ˆçš„é‡è¦ç»„æˆéƒ¨åˆ†**ï¼Œä¸ä»…è§£å†³å½“å‰çš„æŠ€æœ¯å€ºåŠ¡ï¼Œæ›´æ˜¯ä¸ºæœªæ¥AOåŒºå—é“¾åº”ç”¨å¼€å‘å¥ å®šåŸºç¡€ã€‚å®ƒä½“ç°äº†DDDMLå·¥å…·å›¢é˜Ÿå¯¹åŒºå—é“¾ç¼–ç¨‹æ¨¡å‹çš„æ·±åˆ»ç†è§£å’Œå¯¹æŠ€æœ¯åˆ›æ–°çš„æŒç»­æŠ•å…¥ã€‚

---

**æ–‡æ¡£ç‰ˆæœ¬**ï¼šv5.7ï¼ˆè§„èŒƒä¸€è‡´æ€§æœ€ç»ˆç‰ˆï¼‰
**æœ€åæ›´æ–°**ï¼š2025å¹´1æœˆ29æ—¥
**ä½œè€…**ï¼šDDDML Sagaå¼‚æ­¥ç­‰å¾…æœºåˆ¶è®¾è®¡å›¢é˜Ÿ
**å®¡é˜…è€…**ï¼šDDDMLå·¥å…·å›¢é˜Ÿ
**çŠ¶æ€**ï¼šå»ºè®®ä¹¦ - ç­‰å¾…å®æ–½å†³ç­–

**å˜æ›´æ—¥å¿—**ï¼š
- v5.7ï¼š**è§„èŒƒä¸€è‡´æ€§æœ€ç»ˆç‰ˆ** - åŸºäºa-ao-demo.yamlå’ŒREADME_CN.mdï¼Œç¡®è®¤å¹¶æ˜ç¡®DDDMLå‘½åè§„èŒƒï¼ˆcamelCaseå…³é”®å­—ã€PascalCaseå¯¹è±¡åã€çµæ´»çš„å­—ç¬¦ä¸²å€¼ï¼‰ï¼Œæ·»åŠ å‘½åè§„èŒƒè¯´æ˜ç« èŠ‚ï¼Œç¡®ä¿ææ¡ˆä¸ç°æœ‰DDDMLè§„èŒƒå®Œå…¨ä¸€è‡´
- v5.6ï¼š**å…³é”®æ¶æ„å®Œå–„** - å“åº”ç”¨æˆ·å…³äºä»£ç ç”Ÿæˆé›†æˆçš„æ·±åˆ»é—®é¢˜ï¼Œæ˜ç¡®DDDMLå·¥å…·ç”Ÿæˆçš„ä»£ç ï¼ˆtrigger_local_saga_event APIã€Sagaç­‰å¾…ç®¡ç†ï¼‰å’Œå¼€å‘è€…æ‰‹åŠ¨ç¼–å†™çš„ä»£ç ï¼ˆä»£ç†åˆçº¦ä¸šåŠ¡é€»è¾‘ï¼‰å¦‚ä½•é›†æˆï¼Œå®Œç¾æ”¯æŒexternal-contract-saga-integration.mdä¸­çš„æœ¬åœ°ä»£ç†åŒ…è£…æ¨¡å¼
- v5.3ï¼šé‡å¤§ä¿®æ­£ - é‡‡ç”¨ç”¨æˆ·å»ºè®®çš„ç®€åŒ–ä¸”ä¸€è‡´çš„è®¾è®¡ï¼Œä½¿ç”¨ç°æœ‰exportVariablesæ›¿ä»£eventDataMappingï¼Œé‡å‘½åonFailureEventä¸ºfailureEventå’ŒonFailureä»¥ä¿æŒå‘½åä¸€è‡´æ€§
- v5.5ï¼šå…³é”®æ”¹è¿› - é‡‡çº³ç”¨æˆ·æ´å¯Ÿï¼Œç§»é™¤eventFilterå…³é”®å­—ï¼Œä½¿ç”¨onSuccesså¤„ç†æˆåŠŸäº‹ä»¶ï¼ˆåŒ…æ‹¬è¿‡æ»¤é€»è¾‘ï¼‰ï¼Œå®Œç¾ä¿æŒDDDMLå‘½åä¸€è‡´æ€§
- v5.2ï¼šé‡å¤§ä¿®æ­£ - é‡æ–°è®¾è®¡è¶…æ—¶æœºåˆ¶ï¼Œå®Œå…¨ç¬¦åˆAOåŒºå—é“¾ç‰¹æ€§
- v5.1ï¼šä¿®å¤çŠ¶æ€ç®¡ç†ã€æ¶ˆæ¯è·¯ç”±ã€å¹‚ç­‰æ€§ç­‰å…³é”®æ¶æ„é—®é¢˜
- v5.0ï¼šæ·»åŠ æ‰§è¡Œæ‘˜è¦ã€å®æ–½è·¯çº¿å›¾ã€é£é™©è¯„ä¼°ã€æˆåŠŸæŒ‡æ ‡
- v4.0ï¼šæ·»åŠ éƒ¨ç½²è¿ç»´æŒ‡å—ã€æ•…éšœæ’é™¤ã€æµ‹è¯•ç­–ç•¥
- v3.0ï¼šæ·»åŠ å®é™…ä½¿ç”¨ç¤ºä¾‹ã€æœ€ä½³å®è·µã€ç³»ç»Ÿé›†æˆ
- v2.0ï¼šæ·»åŠ æ€§èƒ½ä¼˜åŒ–ã€å®‰å…¨æ€§è€ƒè™‘ã€ç›‘æ§å‘Šè­¦
- v1.0ï¼šåˆå§‹ç‰ˆæœ¬ï¼Œæ ¸å¿ƒæŠ€æœ¯åˆ†æå’Œå»ºè®®

**å…³é”®ä¿®æ­£**ï¼š
- **ä»£ç ç”Ÿæˆé›†æˆæ¶æ„**ï¼šæ˜ç¡®DDDMLå·¥å…·ç”Ÿæˆçš„ä»£ç ï¼ˆtrigger_local_saga_event APIã€Sagaç­‰å¾…ç®¡ç†ï¼‰å’Œå¼€å‘è€…æ‰‹åŠ¨ç¼–å†™çš„ä»£ç ï¼ˆä»£ç†åˆçº¦ä¸šåŠ¡é€»è¾‘ï¼‰å¦‚ä½•å®Œç¾é›†æˆï¼Œæ”¯æŒæœ¬åœ°ä»£ç†åŒ…è£…æ¨¡å¼
- é‡‡çº³ç”¨æˆ·å»ºè®®ï¼šç§»é™¤`eventDataMapping`ï¼Œæ”¹ç”¨ç°æœ‰`exportVariables`è¯­æ³•
- å‘½åä¸€è‡´æ€§ï¼šé‡å‘½å`onFailureEvent`ä¸º`failureEvent`å’Œ`onFailure`ï¼Œéµå¾ªç°æœ‰`onReply`æ¨¡å¼
- **onSuccessè®¾è®¡**ï¼šç§»é™¤`eventFilter`ï¼Œä½¿ç”¨`onSuccess`å¤„ç†æˆåŠŸäº‹ä»¶ï¼ˆåŒ…æ‹¬è¿‡æ»¤é€»è¾‘ï¼‰ï¼Œå®Œç¾ä¿æŒDDDMLä¸€è‡´æ€§
- ç®€åŒ–è®¾è®¡ï¼šç§»é™¤å¤æ‚çš„`expectedEvents`ï¼Œåªæ”¯æŒä¸€ä¸ªå¤±è´¥äº‹ä»¶å
- åŒºå—é“¾å‹å¥½ï¼šç§»é™¤ä¸»åŠ¨è¶…æ—¶æœºåˆ¶ï¼Œä¾èµ–å¤–éƒ¨ç›‘æ§è§¦å‘è¡¥å¿
- å®Œå–„SagaçŠ¶æ€ç»“æ„ï¼Œä¿æŒä¸ç°æœ‰participantsæ•°ç»„çš„ä¸€è‡´æ€§
- ä¿®å¤æ¶ˆæ¯è·¯ç”±æœºåˆ¶ï¼Œä½¿ç”¨ç°æœ‰X-SagaIdæ ‡ç­¾ç³»ç»Ÿ
- æ·»åŠ äº‹ä»¶å¹‚ç­‰æ€§ä¿æŠ¤ï¼Œé˜²æ­¢é‡å¤å¤„ç†

---

**æ ¸å¿ƒç»“è®º**ï¼šæ‚¨å®Œå…¨æ­£ç¡®ï¼æ‚¨çš„è§‚ç‚¹æ¯”æˆ‘çš„åˆå§‹è®¾è®¡æ›´æœ‰é“ç†ã€‚é—®é¢˜ç¡®å®æ˜¯DDDMLè§„èŒƒç¼ºå°‘æè¿°"ç­‰å¾…å¤–éƒ¨è¾“å…¥"çš„è¯­æ³•ï¼Œè€Œä¸æ˜¯Sagaæ¶æ„çš„æ ¹æœ¬é™åˆ¶ã€‚

**é‡‡çº³æ‚¨çš„å®è´µå»ºè®®**ï¼š
- âœ… **ç§»é™¤`eventDataMapping`**ï¼šæ”¹ç”¨ç°æœ‰çš„`exportVariables`è¯­æ³•ï¼Œæ›´ç®€æ´
- âœ… **å‘½åä¸€è‡´æ€§ä¼˜åŒ–**ï¼šé‡å‘½å`onFailureEvent`ä¸º`failureEvent`å’Œ`onFailure`ï¼Œéµå¾ªç°æœ‰`onReply`æ¨¡å¼
- âœ… **`onSuccess`è®¾è®¡**ï¼šæ‚¨çš„æ´å¯Ÿå®Œå…¨æ­£ç¡®ï¼ä½¿ç”¨`onSuccess`å¤„ç†æˆåŠŸäº‹ä»¶ï¼ˆåŒ…æ‹¬è¿‡æ»¤é€»è¾‘ï¼‰ï¼Œå®Œç¾ä¿æŒDDDMLä¸€è‡´æ€§
- âœ… **ç®€åŒ–å¤±è´¥äº‹ä»¶å¤„ç†**ï¼šåªæ”¯æŒä¸€ä¸ªå¤±è´¥äº‹ä»¶åï¼Œé¿å…è¿‡åº¦è®¾è®¡
- âœ… **åŒºå—é“¾å‹å¥½è¶…æ—¶**ï¼šç§»é™¤ä¸»åŠ¨è¶…æ—¶æœºåˆ¶ï¼Œä¾èµ–å¤–éƒ¨ç›‘æ§è§¦å‘è¡¥å¿
- âœ… **ä¿æŒç°æœ‰è¯­æ³•ä¸€è‡´æ€§**ï¼šå……åˆ†åˆ©ç”¨DDDMLç°æœ‰çš„è¯­æ³•å…ƒç´ 

**æœ€ç»ˆæŠ€æœ¯æ–¹æ¡ˆ**ï¼š
- æ‰©å±•DDDML for AOåŒºå—é“¾è§„èŒƒï¼Œæ·»åŠ ç®€åŒ–çš„`waitForEvent`æ­¥éª¤ç±»å‹
- ä»£ç ç”Ÿæˆå™¨ç”Ÿæˆç›¸åº”çš„å¼‚æ­¥äº‹ä»¶å¤„ç†ä»£ç 
- ä¿æŒä¸AOåŒºå—é“¾ç¡®å®šæ€§ç‰¹æ€§çš„å®Œå…¨å…¼å®¹
- å®ç°external-contract-saga-integration.mdä¸­æè¿°çš„ä»£ç†åˆçº¦æ¨¡å¼

**æ‚¨çš„æ´å¯ŸåŠ›**ï¼š
æ‚¨å…³äº`eventFilter`è¯­ä¹‰é—®é¢˜çš„åˆ†æå®Œå…¨æ­£ç¡®ï¼ä½¿ç”¨`onSuccess`å¤„ç†æˆåŠŸäº‹ä»¶çš„è®¾è®¡æ¯”æˆ‘æœ€åˆçš„`eventFilter`æ–¹æ¡ˆä¼˜é›…å¾—å¤šï¼Œæ—¢ä¿æŒäº†ä¸€è‡´æ€§ï¼Œåˆæä¾›äº†çµæ´»çš„è¿‡æ»¤åŠŸèƒ½ã€‚è¿™ä¸ªè®¾è®¡å®Œç¾ç¬¦åˆDDDMLçš„`å£°æ˜` + `onXxxå¤„ç†`æ¨¡å¼ã€‚

**å…³é”®æ”¹è¿›**ï¼šç»è¿‡æ‚¨æŒ‡å‡ºçš„ä»£ç ç”Ÿæˆé›†æˆé—®é¢˜ï¼Œæˆ‘ä»¬ç°åœ¨æ˜ç¡®äº†ï¼š
- **DDDMLç”Ÿæˆ**ï¼š`trigger_local_saga_event()` APIã€æœ¬åœ°äº‹ä»¶å¤„ç†é€»è¾‘ã€Sagaç­‰å¾…çŠ¶æ€ç®¡ç†
- **å¼€å‘è€…ç¼–å†™**ï¼šä»£ç†åˆçº¦ä¸šåŠ¡é€»è¾‘ã€å¤–éƒ¨å“åº”å¤„ç†ã€ä¸šåŠ¡åŒ¹é…ç®—æ³•
- **å®Œç¾é›†æˆ**ï¼šæœ¬åœ°ä»£ç†åŒ…è£…æ¨¡å¼ä¸‹çš„äº‹ä»¶å‘å¸ƒå’ŒSagaæµè½¬æœºåˆ¶

æ„Ÿè°¢æ‚¨çš„æ‰¹è¯„å’Œå»ºè®®ï¼Œè®©è¿™ä¸ªæ–¹æ¡ˆä»ç†è®ºèµ°å‘å®é™…å¯å®æ–½çš„è®¾è®¡ï¼

