-- <autogenerated>
--   This file was generated by dddappp code generator.
--   Any changes made to this file manually will be lost next time the file is regenerated.
-- </autogenerated>

local json = require("json")
local messaging = require("messaging")
local saga = require("saga")
local saga_messaging = require("saga_messaging")
local nft_escrow_service_local = require("nft_escrow_service_local")

local execute_local_compensations_respond_original_requester = saga_messaging
    .execute_local_compensations_respond_original_requester
local rollback_saga_instance_respond_original_requester = saga_messaging
    .rollback_saga_instance_respond_original_requester
local complete_saga_instance_respond_original_requester = saga_messaging
    .complete_saga_instance_respond_original_requester
local execute_local_compensations = saga_messaging.execute_local_compensations

local create_nft_escrow_record =
    nft_escrow_service_local.create_nft_escrow_record
local transfer_nft_to_buyer =
    nft_escrow_service_local.transfer_nft_to_buyer
local transfer_funds_to_seller =
    nft_escrow_service_local.transfer_funds_to_seller

local nft_escrow_service = {}


local ERRORS = {
    INVALID_MESSAGE = "INVALID_MESSAGE",
    COMPENSATION_FAILED = "COMPENSATION_FAILED",
}

nft_escrow_service.ERRORS = ERRORS

local ACTIONS = {
    USE_ESCROW_PAYMENT =
    "NftEscrowService_UseEscrowPayment",
    EXECUTE_NFT_ESCROW_TRANSACTION =
    "NftEscrowService_ExecuteNftEscrowTransaction",
}

nft_escrow_service.ACTIONS = ACTIONS

-- required components
local nft_escrow_service_config = require("nft_escrow_service_config")


function nft_escrow_service.execute_nft_escrow_transaction(msg, env, response)
    local cmd = json.decode(msg.Data)

    local context = cmd

    local local_steps = {
        create_nft_escrow_record,
    }
    local local_commits = {}
    for i = 1, #local_steps, 1 do
        local local_step = local_steps[i]
        local local_status, local_result_or_error, local_commit = pcall((function()
            return local_step(context)
        end))
        if (not local_status) then
            messaging.process_operation_result(false, local_result_or_error, function() end, msg)
            return
        else
            local_commits[#local_commits + 1] = local_commit
        end
    end

        -- This is the first step, create saga instance first.
        local original_message = messaging.extract_reply_context(msg)
        local saga_instance, commit = saga.create_saga_instance(ACTIONS.EXECUTE_NFT_ESCROW_TRANSACTION, nil, -- no target for local wait
            nil, -- no tags for local wait
            context,
            original_message,
            #local_steps
        )
        local saga_id = saga_instance.saga_id
        commit() -- must commit here to save the saga instance
        local commit = saga.move_saga_instance_forward(saga_id, 1 + #local_steps, nil, nil, context)

        local saga_instance = saga.get_saga_instance_copy(saga_id)
        saga_instance.waiting_state = {
            is_waiting = true,
            success_event_type = "NftDeposited",
            failure_event_type = nil,
            step_name = "WaitForNftDeposit",
            started_at = os.time() * 1000,  -- Convert to milliseconds to match AO timestamp format
            max_wait_time_seconds = 86400000,  -- Convert to milliseconds
            on_success_handler = function(event, context) return return (-- TODO) end,
            on_failure_handler = function(event, context) -- TODO end,
            continuation_handler = "nft_escrow_service.execute_nft_escrow_transaction_wait_for_wait_for_nft_deposit_callback",
            data_mapping_rules = {
            },
        }
        local update_commit = function() entity_coll.update(saga_instances, saga_id, saga_instance) end

        local total_commit = function()
            commit()
            update_commit()
        end
        total_commit()
end

function nft_escrow_service.execute_nft_escrow_transaction_wait_for_wait_for_nft_deposit_callback(saga_id, context, result, msg)
    local saga_instance = saga.get_saga_instance_copy(saga_id)
    if (saga_instance.current_step ~= 2 or saga_instance.compensating) then
        error(ERRORS.INVALID_MESSAGE)
    end
    local context = saga_instance.context

        local commit = saga.move_saga_instance_forward(saga_id, 1, nil, nil, context)

        local saga_instance = saga.get_saga_instance_copy(saga_id)
        saga_instance.waiting_state = {
            is_waiting = true,
            success_event_type = "EscrowPaymentUsed",
            failure_event_type = nil,
            step_name = "WaitForPayment",
            started_at = os.time() * 1000,  -- Convert to milliseconds to match AO timestamp format
            max_wait_time_seconds = 3600000,  -- Convert to milliseconds
            on_success_handler = function(event, context) return return false, false, nil end,
            on_failure_handler = function(event, context)  end,
            continuation_handler = "nft_escrow_service.execute_nft_escrow_transaction_wait_for_wait_for_payment_callback",
            data_mapping_rules = {
            },
        }
        local update_commit = function() entity_coll.update(saga_instances, saga_id, saga_instance) end

        local total_commit = function()
            commit()
            update_commit()
        end
        total_commit()
end

function nft_escrow_service.execute_nft_escrow_transaction_wait_for_wait_for_payment_callback(saga_id, context, result, msg)
    local saga_instance = saga.get_saga_instance_copy(saga_id)
    if (saga_instance.current_step ~= 3 or saga_instance.compensating) then
        error(ERRORS.INVALID_MESSAGE)
    end
    local context = saga_instance.context

    local local_steps = {
        transfer_nft_to_buyer,
    }
    local local_commits = {}
    for i = 1, #local_steps, 1 do
        local local_step = local_steps[i]
        local local_status, local_result_or_error, local_commit = pcall((function()
            return local_step(context)
        end))
        if (not local_status) then
            -- mark saga instance as compensating, and commit immediately
            saga.set_instance_compensating(saga_id, 1)()
            -- handle error, no need to compensate
            rollback_saga_instance_respond_original_requester(saga_instance, local_result_or_error)
            return
        else
            local_commits[#local_commits + 1] = local_commit
        end
    end

        local commit = saga.move_saga_instance_forward(saga_id, 1 + #local_steps, nil, nil, context)

        local saga_instance = saga.get_saga_instance_copy(saga_id)
        saga_instance.waiting_state = {
            is_waiting = true,
            success_event_type = "NftTransferredToBuyer",
            failure_event_type = nil,
            step_name = "WaitForNftTransferConfirmation",
            started_at = os.time() * 1000,  -- Convert to milliseconds to match AO timestamp format
            max_wait_time_seconds = 300000,  -- Convert to milliseconds
            on_success_handler = function(event, context) return return false, false, nil end,
            on_failure_handler = function(event, context)  end,
            continuation_handler = "nft_escrow_service.execute_nft_escrow_transaction_wait_for_wait_for_nft_transfer_confirmation_callback",
            data_mapping_rules = {
            },
        }
        local update_commit = function() entity_coll.update(saga_instances, saga_id, saga_instance) end

        local total_commit = function()
            commit()
            update_commit()
        end
        total_commit()
end

function nft_escrow_service.execute_nft_escrow_transaction_wait_for_wait_for_nft_transfer_confirmation_callback(saga_id, context, result, msg)
    local saga_instance = saga.get_saga_instance_copy(saga_id)
    if (saga_instance.current_step ~= 5 or saga_instance.compensating) then
        error(ERRORS.INVALID_MESSAGE)
    end
    local context = saga_instance.context

    local local_steps = {
        transfer_funds_to_seller,
    }
    local local_commits = {}
    for i = 1, #local_steps, 1 do
        local local_step = local_steps[i]
        local local_status, local_result_or_error, local_commit = pcall((function()
            return local_step(context)
        end))
        if (not local_status) then
            -- mark saga instance as compensating, and commit immediately
            saga.set_instance_compensating(saga_id, 1)()
            -- handle error, no need to compensate
            rollback_saga_instance_respond_original_requester(saga_instance, local_result_or_error)
            return
        else
            local_commits[#local_commits + 1] = local_commit
        end
    end

        local commit = saga.move_saga_instance_forward(saga_id, 1 + #local_steps, nil, nil, context)

        local saga_instance = saga.get_saga_instance_copy(saga_id)
        saga_instance.waiting_state = {
            is_waiting = true,
            success_event_type = "FundsTransferredToSeller",
            failure_event_type = nil,
            step_name = "WaitForFundsTransferConfirmation",
            started_at = os.time() * 1000,  -- Convert to milliseconds to match AO timestamp format
            max_wait_time_seconds = 0,  -- Convert to milliseconds
            on_success_handler = function(event, context) return return false, false, nil end,
            on_failure_handler = function(event, context)  end,
            continuation_handler = "nft_escrow_service.execute_nft_escrow_transaction_wait_for_wait_for_funds_transfer_confirmation_callback",
            data_mapping_rules = {
            },
        }
        local update_commit = function() entity_coll.update(saga_instances, saga_id, saga_instance) end

        local total_commit = function()
            commit()
            update_commit()
        end
        total_commit()
end

function nft_escrow_service.execute_nft_escrow_transaction_wait_for_wait_for_funds_transfer_confirmation_callback(saga_id, context, result, msg)
    local saga_instance = saga.get_saga_instance_copy(saga_id)
    if (saga_instance.current_step ~= 7 or saga_instance.compensating) then
        error(ERRORS.INVALID_MESSAGE)
    end
    local context = saga_instance.context

    local completed_result = result
    complete_saga_instance_respond_original_requester(saga_instance, completed_result, context)
end


return nft_escrow_service

