-- <autogenerated>
--   This file was generated by dddappp code generator.
--   Any changes made to this file manually will be lost next time the file is regenerated.
-- </autogenerated>

local json = require("json")
local messaging = require("messaging")
local saga = require("saga")
local saga_messaging = require("saga_messaging")
local nft_escrow_service_local = require("nft_escrow_service_local")

local execute_local_compensations_respond_original_requester = saga_messaging
    .execute_local_compensations_respond_original_requester
local rollback_saga_instance_respond_original_requester = saga_messaging
    .rollback_saga_instance_respond_original_requester
local complete_saga_instance_respond_original_requester = saga_messaging
    .complete_saga_instance_respond_original_requester
local execute_local_compensations = saga_messaging.execute_local_compensations

local create_nft_escrow_record =
    nft_escrow_service_local.create_nft_escrow_record
local transfer_nft_to_buyer =
    nft_escrow_service_local.transfer_nft_to_buyer
local transfer_funds_to_seller =
    nft_escrow_service_local.transfer_funds_to_seller

local nft_escrow_service = {}


local ERRORS = {
    INVALID_MESSAGE = "INVALID_MESSAGE",
    COMPENSATION_FAILED = "COMPENSATION_FAILED",
}

nft_escrow_service.ERRORS = ERRORS

local ACTIONS = {
    USE_ESCROW_PAYMENT =
    "NftEscrowService_UseEscrowPayment",
    EXECUTE_NFT_ESCROW_TRANSACTION =
    "NftEscrowService_ExecuteNftEscrowTransaction",
}

nft_escrow_service.ACTIONS = ACTIONS

-- required components
local nft_escrow_service_config = require("nft_escrow_service_config")

-- TODO 因为当前文件应该是完全 AutoGenerated 的，所以这里的方法应该调用 nft_escrow_service_local 中的方法.
--   nft_escrow_service_local 文件是工具生成了脚手架代码，但是可以修改的。
-- UseEscrowPayment method - minimal implementation for reference
function nft_escrow_service.use_escrow_payment(msg, env, response)
    local cmd = json.decode(msg.Data)
    local escrow_id = cmd.EscrowId
    local payment_id = cmd.PaymentId

    -- Get records (simplified - in real implementation would use proper error handling)
    local escrow_payment = EscrowPaymentTable[payment_id]
    if not escrow_payment or escrow_payment.Status ~= "AVAILABLE" then
        messaging.process_operation_result(false, "Invalid payment record", function() end, msg)
        return
    end

    local escrow_record = NftEscrowTable[escrow_id]
    if not escrow_record then
        messaging.process_operation_result(false, "Escrow record not found", function() end, msg)
        return
    end

    -- Match payment with escrow conditions
    if escrow_payment.TokenContract ~= escrow_record.TokenContract or
       escrow_payment.Amount ~= escrow_record.Price then
        messaging.process_operation_result(false, "Payment does not match escrow conditions", function() end, msg)
        return
    end

    -- Update records
    escrow_record.BuyerAddress = escrow_payment.PayerAddress
    escrow_record.PaymentId = payment_id
    NftEscrowTable[escrow_id] = escrow_record

    escrow_payment.Status = "USED"
    escrow_payment.UsedByEscrowId = escrow_id
    EscrowPaymentTable[payment_id] = escrow_payment

    -- Trigger event (simplified)
    local saga_id = escrow_id
    saga.trigger_local_event(saga_id, "EscrowPaymentUsed", {
        escrowId = escrow_id,
        buyerAddress = escrow_payment.PayerAddress
    })

    messaging.process_operation_result(true, "Payment applied successfully", function() end, msg)
end

-- TODO 因为当前文件应该是完全 AutoGenerated 的，所以这里的方法应该调用 nft_escrow_service_local 中的方法。
--   nft_escrow_service_local 文件是工具生成了脚手架代码，但是可以修改的。
-- Event handler for EscrowPaymentUsed event (simplified for reference)
function nft_escrow_service.handle_escrow_payment_used_event(saga_id, event_data, msg)
    -- This would be called when EscrowPaymentUsed event is triggered
    -- In a real implementation, this would continue the Saga flow
    local saga_instance = saga.get_saga_instance_copy(saga_id)
    if saga_instance and saga_instance.waiting_state and
       saga_instance.waiting_state.success_event_type == "EscrowPaymentUsed" then
        -- Continue to next step in Saga
        nft_escrow_service.execute_nft_escrow_transaction_wait_for_payment_callback(
            saga_id, saga_instance.context, true, msg)
    end
end


function nft_escrow_service.execute_nft_escrow_transaction(msg, env, response)
    local cmd = json.decode(msg.Data)

    local context = cmd

    local local_steps = {
        create_nft_escrow_record,
    }
    local local_commits = {}
    for i = 1, #local_steps, 1 do
        local local_step = local_steps[i]
        local local_status, local_result_or_error, local_commit = pcall((function()
            return local_step(context)
        end))
        if (not local_status) then
            messaging.process_operation_result(false, local_result_or_error, function() end, msg)
            return
        else
            local_commits[#local_commits + 1] = local_commit
        end
    end

        -- This is the first step, create saga instance first.
        local original_message = messaging.extract_reply_context(msg)
        local saga_instance, commit = saga.create_saga_instance(ACTIONS.EXECUTE_NFT_ESCROW_TRANSACTION, nil, -- no target for local wait
            nil, -- no tags for local wait
            context,
            original_message,
            #local_steps
        )
        local saga_id = saga_instance.saga_id
        commit() -- must commit here to save the saga instance
        local commit = saga.move_saga_instance_forward(saga_id, 1 + #local_steps, nil, nil, context)

        local saga_instance = saga.get_saga_instance_copy(saga_id)
        saga_instance.waiting_state = {
            is_waiting = true,
            success_event_type = "NftDeposited",
            failure_event_type = nil,
            step_name = "WaitForNftDeposit",
            started_at = os.time() * 1000,  -- Convert to milliseconds to match AO timestamp format
            max_wait_time_seconds = 86400000,  -- Convert to milliseconds
            -- TODO 不应该在 saga 实例中使用这两个字段。应该直接在 execute_nft_escrow_transaction_wait_for_nft_deposit_callback 函数内部处理成功或者失败的情况
            -- on_success_handler = function(event, context) return true end,
            -- on_failure_handler = function(event, context) end,
            -- TODO 不要让 continuation_handler 的值是一个字符串！直接保存函数引用是不是更好？
            continuation_handler = "nft_escrow_service.execute_nft_escrow_transaction_wait_for_nft_deposit_callback",
            data_mapping_rules = {
            },
        }
        local update_commit = function() SagaInstances[saga_id] = saga_instance end

        local total_commit = function()
            commit()
            update_commit()
        end
        total_commit()
end

-- TODO 参考下面其他 wait_for_*_callback 函数的修改说明（注释）
function nft_escrow_service.execute_nft_escrow_transaction_wait_for_nft_deposit_callback(saga_id, context, result, msg)
    local saga_instance = saga.get_saga_instance_copy(saga_id)
    if (saga_instance.current_step ~= 2 or saga_instance.compensating) then
        error(ERRORS.INVALID_MESSAGE)
    end
    local context = saga_instance.context

        local commit = saga.move_saga_instance_forward(saga_id, 1, nil, nil, context)

        local saga_instance = saga.get_saga_instance_copy(saga_id)
        saga_instance.waiting_state = {
            is_waiting = true,
            success_event_type = "EscrowPaymentUsed",
            failure_event_type = nil,
            step_name = "WaitForPayment",
            started_at = os.time() * 1000,  -- Convert to milliseconds to match AO timestamp format
            max_wait_time_seconds = 3600000,  -- Convert to milliseconds
            -- TODO 不应该在 saga 实例中使用这两个字段。应该直接在 execute_nft_escrow_transaction_wait_for_payment_callback 函数内部处理成功或者失败的情况
            -- on_success_handler = function(event, context) return false, false, nil end,
            -- on_failure_handler = function(event, context)  end,
            -- TODO 不要让 continuation_handler 的值是一个字符串！直接保存函数引用是不是更好？
            continuation_handler = "nft_escrow_service.execute_nft_escrow_transaction_wait_for_payment_callback",
            data_mapping_rules = {
            },
        }
        local update_commit = function() SagaInstances[saga_id] = saga_instance end

        local total_commit = function()
            commit()
            update_commit()
        end
        total_commit()
end

-- TODO 参考下面其他 wait_for_*_callback 函数的修改说明（注释）
function nft_escrow_service.execute_nft_escrow_transaction_wait_for_payment_callback(saga_id, context, result, msg)
    local saga_instance = saga.get_saga_instance_copy(saga_id)
    if (saga_instance.current_step ~= 3 or saga_instance.compensating) then
        error(ERRORS.INVALID_MESSAGE)
    end
    local context = saga_instance.context

    local local_steps = {
        transfer_nft_to_buyer,
    }
    local local_commits = {}
    for i = 1, #local_steps, 1 do
        local local_step = local_steps[i]
        local local_status, local_result_or_error, local_commit = pcall((function()
            return local_step(context)
        end))
        if (not local_status) then
            -- mark saga instance as compensating, and commit immediately
            saga.set_instance_compensating(saga_id, 1)()
            -- handle error, no need to compensate
            rollback_saga_instance_respond_original_requester(saga_instance, local_result_or_error)
            return
        else
            local_commits[#local_commits + 1] = local_commit
        end
    end

        local commit = saga.move_saga_instance_forward(saga_id, 1 + #local_steps, nil, nil, context)

        local saga_instance = saga.get_saga_instance_copy(saga_id)
        saga_instance.waiting_state = {
            is_waiting = true,
            success_event_type = "NftTransferredToBuyer",
            failure_event_type = nil,
            step_name = "WaitForNftTransferConfirmation",
            started_at = os.time() * 1000,  -- Convert to milliseconds to match AO timestamp format
            max_wait_time_seconds = 300000,  -- Convert to milliseconds
            -- TODO 不应该在 saga 实例中使用这两个字段。应该直接在 execute_nft_escrow_transaction_wait_for_nft_transfer_confirmation_callback 函数内部处理成功或者失败的情况
            on_success_handler = function(event, context) return false, false, nil end,
            on_failure_handler = function(event, context)  end,
            -- TODO 不要让 continuation_handler 的值是一个字符串！直接保存函数引用是不是更好？
            continuation_handler = "nft_escrow_service.execute_nft_escrow_transaction_wait_for_nft_transfer_confirmation_callback",
            data_mapping_rules = {
            },
        }
        local update_commit = function() SagaInstances[saga_id] = saga_instance end

        local total_commit = function()
            commit()
            update_commit()
        end
        total_commit()
end

-- todo 这个函数的行为应该和 inventory_service.process_inventory_surplus_or_shortage_get_inventory_item_callback 这类方法类似。
--   不同之处只是 inventory_service.process_inventory_surplus_or_shortage_get_inventory_item_callback 这样的方法是外部的消息触发执行的，而这里是本地的 saga 实例内部触发的。
--   外部消息触发执行的时候，也会有成功或失败的情形，和内部事件（内部事件也有可能是成功事件或失败事件）触发其他类似。所以这里的处理流程应该是大同小异的。
function nft_escrow_service.execute_nft_escrow_transaction_wait_for_nft_transfer_confirmation_callback(saga_id, context, result, msg)
    local saga_instance = saga.get_saga_instance_copy(saga_id)
    if (saga_instance.current_step ~= 5 or saga_instance.compensating) then
        error(ERRORS.INVALID_MESSAGE)
    end
    local context = saga_instance.context

    local local_steps = {
        transfer_funds_to_seller,
    }
    local local_commits = {}
    for i = 1, #local_steps, 1 do
        local local_step = local_steps[i]
        local local_status, local_result_or_error, local_commit = pcall((function()
            return local_step(context)
        end))
        if (not local_status) then
            -- mark saga instance as compensating, and commit immediately
            saga.set_instance_compensating(saga_id, 1)()
            -- handle error, no need to compensate
            rollback_saga_instance_respond_original_requester(saga_instance, local_result_or_error)
            return
        else
            local_commits[#local_commits + 1] = local_commit
        end
    end

        local commit = saga.move_saga_instance_forward(saga_id, 1 + #local_steps, nil, nil, context)

        local saga_instance = saga.get_saga_instance_copy(saga_id)
        saga_instance.waiting_state = {
            is_waiting = true,
            success_event_type = "FundsTransferredToSeller",
            failure_event_type = nil,
            step_name = "WaitForFundsTransferConfirmation",
            started_at = os.time() * 1000,  -- Convert to milliseconds to match AO timestamp format
            max_wait_time_seconds = 0,  -- Convert to milliseconds
            -- TODO 不应该在 saga 实例中使用这两个字段。应该直接在 execute_nft_escrow_transaction_wait_for_funds_transfer_confirmation_callback 函数内部处理成功或者失败的情况
            on_success_handler = function(event, context) return false, false, nil end,
            on_failure_handler = function(event, context)  end,
            -- TODO 
            continuation_handler = "nft_escrow_service.execute_nft_escrow_transaction_wait_for_funds_transfer_confirmation_callback",
            data_mapping_rules = {
            },
        }
        local update_commit = function() SagaInstances[saga_id] = saga_instance end

        local total_commit = function()
            commit()
            update_commit()
        end
        total_commit()
end

function nft_escrow_service.execute_nft_escrow_transaction_wait_for_funds_transfer_confirmation_callback(saga_id, context, result, msg)
    local saga_instance = saga.get_saga_instance_copy(saga_id)
    if (saga_instance.current_step ~= 7 or saga_instance.compensating) then
        error(ERRORS.INVALID_MESSAGE)
    end
    local context = saga_instance.context

    local completed_result = result
    complete_saga_instance_respond_original_requester(saga_instance, completed_result, context)
end


return nft_escrow_service

