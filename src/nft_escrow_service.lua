-- <autogenerated>
--   This file was generated by dddappp code generator.
--   Any changes made to this file manually will be lost next time the file is regenerated.
-- </autogenerated>

print("SERVICE_LOAD_SUCCESS: nft_escrow_service.lua executed")

local json = require("json")
local messaging = require("messaging")
local saga = require("saga")
local saga_messaging = require("saga_messaging")
local nft_escrow_service_local = require("nft_escrow_service_local")

-- Load required modules for Saga operation
local nft_escrow_aggregate = require("nft_escrow_aggregate")
local escrow_payment_aggregate = require("escrow_payment_aggregate")

-- Ensure global tables are initialized
NftEscrowTable = NftEscrowTable or {}
NftEscrowIdSequence = NftEscrowIdSequence or { current = "0" }
EscrowPaymentTable = EscrowPaymentTable or {}
PaymentIdSequence = PaymentIdSequence or { current = "0" }
SagaInstances = SagaInstances or {}
SagaIdSequence = SagaIdSequence or { current = "0" }

-- Initialize aggregates
local nft_escrow_aggregate = require("nft_escrow_aggregate")
local escrow_payment_aggregate = require("escrow_payment_aggregate")
local saga = require("saga")

nft_escrow_aggregate.init(NftEscrowTable, NftEscrowIdSequence)
escrow_payment_aggregate.init(EscrowPaymentTable, PaymentIdSequence)
saga.init(SagaInstances, SagaIdSequence)

print("DEBUG: nft_escrow_service.lua loaded, tables and aggregates initialized")

-- Verify handlers are available
if Handlers and Handlers.list then
    print("DEBUG: Handlers system available")
else
    print("ERROR: Handlers system not available")
end

local execute_local_compensations_respond_original_requester = saga_messaging
    .execute_local_compensations_respond_original_requester
local rollback_saga_instance_respond_original_requester = saga_messaging
    .rollback_saga_instance_respond_original_requester
local complete_saga_instance_respond_original_requester = saga_messaging
    .complete_saga_instance_respond_original_requester
local execute_local_compensations = saga_messaging.execute_local_compensations

local create_nft_escrow_record =
    nft_escrow_service_local.create_nft_escrow_record
local transfer_nft_to_buyer =
    nft_escrow_service_local.transfer_nft_to_buyer
local transfer_funds_to_seller =
    nft_escrow_service_local.transfer_funds_to_seller
local use_escrow_payment =
    nft_escrow_service_local.use_escrow_payment
local return_nft_to_seller =
    nft_escrow_service_local.return_nft_to_seller
local unlock_escrow_payment =
    nft_escrow_service_local.unlock_escrow_payment

local nft_escrow_service = {}

-- Helper function
function table_keys(t)
    local keys = {}
    for k, v in pairs(t) do
        table.insert(keys, tostring(k))
    end
    return keys
end


local ERRORS = {
    INVALID_MESSAGE = "INVALID_MESSAGE",
    COMPENSATION_FAILED = "COMPENSATION_FAILED",
}

nft_escrow_service.ERRORS = ERRORS

local ACTIONS = {
    USE_ESCROW_PAYMENT =
    "NftEscrowService_UseEscrowPayment",
    EXECUTE_NFT_ESCROW_TRANSACTION =
    "NftEscrowService_ExecuteNftEscrowTransaction",
    EXECUTE_NFT_ESCROW_TRANSACTION_WAIT_FOR_NFT_DEPOSIT_CALLBACK =
    "NftEscrowService_ExecuteNftEscrowTransaction_WaitForNftDeposit_Callback",
    EXECUTE_NFT_ESCROW_TRANSACTION_WAIT_FOR_PAYMENT_CALLBACK =
    "NftEscrowService_ExecuteNftEscrowTransaction_WaitForPayment_Callback",
    EXECUTE_NFT_ESCROW_TRANSACTION_WAIT_FOR_NFT_TRANSFER_CONFIRMATION_CALLBACK =
    "NftEscrowService_ExecuteNftEscrowTransaction_WaitForNftTransferConfirmation_Callback",
    EXECUTE_NFT_ESCROW_TRANSACTION_WAIT_FOR_FUNDS_TRANSFER_CONFIRMATION_CALLBACK =
    "NftEscrowService_ExecuteNftEscrowTransaction_WaitForFundsTransferConfirmation_Callback",
}

nft_escrow_service.ACTIONS = ACTIONS

-- required components
local nft_escrow_service_config = require("nft_escrow_service_config")

-- TODO å› ä¸ºå½“å‰æ–‡ä»¶åº”è¯¥æ˜¯å®Œå…¨ AutoGenerated çš„ï¼Œæ‰€ä»¥è¿™é‡Œçš„æ–¹æ³•åº”è¯¥è°ƒç”¨ nft_escrow_service_local ä¸­çš„æ–¹æ³•.
--   nft_escrow_service_local æ–‡ä»¶æ˜¯å·¥å…·ç”Ÿæˆäº†è„šæ‰‹æ¶ä»£ç ï¼Œä½†æ˜¯å¯ä»¥ä¿®æ”¹çš„ã€‚
function nft_escrow_service.use_escrow_payment(msg, env, response)
    local cmd = json.decode(msg.Data)

    local status, result_or_error, commit = pcall((function()
        return use_escrow_payment(cmd)
    end))

    if not status then
        messaging.process_operation_result(false, result_or_error, function() end, msg)
        return
    end

    -- Execute the commit function returned by the local implementation
    local commit_status, commit_error = pcall(commit)
    if not commit_status then
        messaging.process_operation_result(false, commit_error, function() end, msg)
        return
    end

    messaging.process_operation_result(true, "Payment applied successfully", function() end, msg)
end

-- TODO å› ä¸ºå½“å‰æ–‡ä»¶åº”è¯¥æ˜¯å®Œå…¨ AutoGenerated çš„ï¼Œæ‰€ä»¥è¿™é‡Œçš„æ–¹æ³•åº”è¯¥è°ƒç”¨ nft_escrow_service_local ä¸­çš„æ–¹æ³•ã€‚
--   nft_escrow_service_local æ–‡ä»¶æ˜¯å·¥å…·ç”Ÿæˆäº†è„šæ‰‹æ¶ä»£ç ï¼Œä½†æ˜¯å¯ä»¥ä¿®æ”¹çš„ã€‚


function nft_escrow_service.execute_nft_escrow_transaction(msg, env, response)
    local cmd
    if msg.Data and msg.Data ~= "" then
        cmd = json.decode(msg.Data)
    else
        -- Handle data sent via --prop parameters
        cmd = {
            SellerAddress = msg.SellerAddress or (msg.Tags and msg.Tags.SellerAddress),
            NftContract = msg.NftContract or (msg.Tags and msg.Tags.NftContract),
            TokenId = msg.TokenId or (msg.Tags and msg.Tags.TokenId),
            TokenContract = msg.TokenContract or (msg.Tags and msg.Tags.TokenContract),
            Price = msg.Price or (msg.Tags and msg.Tags.Price),
            EscrowTerms = msg.EscrowTerms or (msg.Tags and msg.Tags.EscrowTerms)
        }
    end

    local context = cmd
    context.Timestamp = msg.Timestamp -- Add timestamp to context for AO environment

    local local_steps = {
        create_nft_escrow_record,
    }
    local local_commits = {}
    for i = 1, #local_steps, 1 do
        local local_step = local_steps[i]
        local local_status, local_result_or_error, local_commit = pcall((function()
            return local_step(context)
        end))
        if (not local_status) then
            messaging.process_operation_result(false, local_result_or_error, function() end, msg)
            return
        else
            local_commits[#local_commits + 1] = local_commit
        end
    end

    -- Execute local commits first
    for i = 1, #local_commits, 1 do
        local_commits[i]()
    end

    -- This is the first step, create saga instance first.
    local original_message = messaging.extract_reply_context(msg)
    -- Debug: check if saga creation works
    print("Creating SAGA with context keys: " .. table.concat(table_keys(context), ", "))
    local saga_instance, commit = saga.create_saga_instance(ACTIONS.EXECUTE_NFT_ESCROW_TRANSACTION, nil, -- no target for local wait
        nil,                                                                                             -- no tags for local wait
        context,
        original_message,
        #local_steps
    )
    print("SAGA created: " .. tostring(saga_instance ~= nil) .. ", saga_id: " .. tostring(saga_instance and saga_instance.saga_id))
    local saga_id = saga_instance.saga_id
    commit() -- must commit here to save the saga instance
    local commit = saga.move_saga_instance_forward(saga_id, 1 + #local_steps, nil, nil, context)

    local saga_instance = saga.get_saga_instance_copy(saga_id)
    saga_instance.waiting_state = {
        is_waiting = true,
        success_event_type = "NftDeposited",
        failure_event_type = nil,
        step_name = "WaitForNftDeposit",
        started_at = msg.Timestamp,       -- Use AO message timestamp (already in milliseconds)
        max_wait_time_seconds = 86400000, -- 24 hours in milliseconds
        continuation_handler = nft_escrow_service.execute_nft_escrow_transaction_wait_for_nft_deposit_callback,
        data_mapping_rules = {
        },
    }
    local update_commit = function() SagaInstances[saga_id] = saga_instance end

    local total_commit = function()
        -- Execute all local commits first
        for i = 1, #local_commits, 1 do
            local local_commit = local_commits[i]
            local_commit()
        end
        -- Then execute saga commit
        commit()
        update_commit()
    end
    total_commit()
end

-- TODO å‚è€ƒä¸‹é¢å…¶ä»– wait_for_*_callback å‡½æ•°çš„ä¿®æ”¹è¯´æ˜ï¼ˆæ³¨é‡Šï¼‰
function nft_escrow_service.execute_nft_escrow_transaction_wait_for_nft_deposit_callback(saga_id, context, event_type,
                                                                                         event_data, msg)
    -- This function is called when an event is received
    -- Similar to inventory_service callbacks - call onSuccess/onFailure handlers like DDDML defines
    local saga_instance = saga.get_saga_instance_copy(saga_id)
    if (saga_instance.current_step ~= 2 or saga_instance.compensating) then
        error(ERRORS.INVALID_MESSAGE)
    end
    local context = saga_instance.context

    -- Handle failure events first (like inventory_service handles data.error)
    if event_type ~= "NftDeposited" then
        -- onFailure: No return value specification - must execute compensation flow
        nft_escrow_service_local.process_nft_deposit_on_failure(context, event_data)
        -- onFailure cannot be ignored - immediately rollback and trigger compensation
        rollback_saga_instance_respond_original_requester(saga_instance, "NFT deposit failure event received")
        return
    end

    -- Handle success case (like inventory_service continues after error check)
    -- onSuccess: Returns (short_circuited, is_error, result_or_error) like onReply
    local short_circuited, is_error, result_or_error = nft_escrow_service_local.process_nft_deposit_on_success(context,
        event_data)

    -- Handle short-circuit cases like inventory_service does
    if short_circuited then
        if not is_error then
            complete_saga_instance_respond_original_requester(saga_instance, result_or_error, context)
        else
            rollback_saga_instance_respond_original_requester(saga_instance, result_or_error)
        end
        return
    end

    -- Continue with normal saga flow
    local commit = saga.move_saga_instance_forward(saga_id, 1, nil, nil, context)

    local saga_instance_copy = saga.get_saga_instance_copy(saga_id)
    saga_instance_copy.waiting_state = {
        is_waiting = true,
        success_event_type = "EscrowPaymentUsed",
        failure_event_type = nil,
        step_name = "WaitForPayment",
        started_at = msg.Timestamp,
        max_wait_time_seconds = 3600000,
        continuation_handler = nft_escrow_service.execute_nft_escrow_transaction_wait_for_payment_callback,
        data_mapping_rules = {},
    }

    -- Commit both the move forward and the waiting state setup
    local update_commit = function() SagaInstances[saga_id] = saga_instance_copy end
    commit()
    update_commit()
end

function nft_escrow_service.execute_nft_escrow_transaction_wait_for_payment_callback(saga_id, context, event_type,
                                                                                     event_data, msg)
    -- This function is called when an event is received
    -- Similar to inventory_service callbacks - call onSuccess handler as defined in DDDML YAML
    local saga_instance = saga.get_saga_instance_copy(saga_id)
    if (saga_instance.current_step ~= 3 or saga_instance.compensating) then
        error(ERRORS.INVALID_MESSAGE)
    end
    local context = saga_instance.context

    -- Handle unexpected event types first
    if event_type ~= "EscrowPaymentUsed" then
        rollback_saga_instance_respond_original_requester(saga_instance, "Unexpected event type: " .. event_type)
        return
    end

    -- Handle success case - validate and continue (no onSuccess/onFailure callbacks defined)
    if event_data.escrowId ~= context.EscrowId then
        rollback_saga_instance_respond_original_requester(saga_instance, "Payment escrowId mismatch")
        return
    end

    -- Update context with buyer address from payment
    context.BuyerAddress = event_data.buyerAddress

    -- Continue with normal flow: execute NFT transfer step and setup next waiting state
    local local_steps = { transfer_nft_to_buyer }
    local local_commits = {}
    for i = 1, #local_steps, 1 do
        local local_step = local_steps[i]
        local local_status, local_result_or_error, local_commit = pcall((function()
            return local_step(context)
        end))
        if (not local_status) then
            saga.set_instance_compensating(saga_id, 1)()
            -- Execute compensation for WaitForPayment step:
            -- Local step 1 (transfer_nft_to_buyer) failed: nil
            -- Business compensation: unlock_escrow_payment
            local pre_local_compensations = { nil, unlock_escrow_payment }
            -- Then rollback the saga with compensations
            execute_local_compensations_respond_original_requester(saga_instance, context, local_result_or_error,
                pre_local_compensations)
            return
        else
            local_commits[#local_commits + 1] = local_commit
        end
    end

    local commit = saga.move_saga_instance_forward(saga_id, 1 + #local_steps, nil, nil, context)
    local saga_instance_copy = saga.get_saga_instance_copy(saga_id)
    saga_instance_copy.waiting_state = {
        is_waiting = true,
        success_event_type = "NftTransferredToBuyer",
        failure_event_type = nil,
        step_name = "WaitForNftTransferConfirmation",
        started_at = msg.Timestamp,
        max_wait_time_seconds = 300000,
        continuation_handler = nft_escrow_service
            .execute_nft_escrow_transaction_wait_for_nft_transfer_confirmation_callback,
        data_mapping_rules = {},
    }

    local update_commit = function() SagaInstances[saga_id] = saga_instance_copy end
    for _, local_commit in ipairs(local_commits) do
        local_commit()
    end
    commit()
    update_commit()
end

-- todo è¿™ä¸ªå‡½æ•°çš„è¡Œä¸ºåº”è¯¥å’Œ inventory_service.process_inventory_surplus_or_shortage_get_inventory_item_callback è¿™ç±»æ–¹æ³•ç±»ä¼¼ã€‚
--   ä¸åŒä¹‹å¤„åªæ˜¯ inventory_service.process_inventory_surplus_or_shortage_get_inventory_item_callback è¿™æ ·çš„æ–¹æ³•æ˜¯å¤–éƒ¨çš„æ¶ˆæ¯è§¦å‘æ‰§è¡Œçš„ï¼Œè€Œè¿™é‡Œæ˜¯æœ¬åœ°çš„ saga å®ä¾‹å†…éƒ¨è§¦å‘çš„ã€‚
--   å¤–éƒ¨æ¶ˆæ¯è§¦å‘æ‰§è¡Œçš„æ—¶å€™ï¼Œä¹Ÿä¼šæœ‰æˆåŠŸæˆ–å¤±è´¥çš„æƒ…å½¢ï¼Œå’Œå†…éƒ¨äº‹ä»¶ï¼ˆå†…éƒ¨äº‹ä»¶ä¹Ÿæœ‰å¯èƒ½æ˜¯æˆåŠŸäº‹ä»¶æˆ–å¤±è´¥äº‹ä»¶ï¼‰è§¦å‘å…¶ä»–ç±»ä¼¼ã€‚æ‰€ä»¥è¿™é‡Œçš„å¤„ç†æµç¨‹åº”è¯¥æ˜¯å¤§åŒå°å¼‚çš„ã€‚
function nft_escrow_service.execute_nft_escrow_transaction_wait_for_nft_transfer_confirmation_callback(saga_id, context,
                                                                                                       event_type,
                                                                                                       event_data, msg)
    -- This function is called when an event is received
    -- Similar to inventory_service callbacks - handle errors first, then normal flow
    local saga_instance = saga.get_saga_instance_copy(saga_id)
    if (saga_instance.current_step ~= 5 or saga_instance.compensating) then
        error(ERRORS.INVALID_MESSAGE)
    end
    local context = saga_instance.context

    -- Handle unexpected event types first (like inventory_service handles data.error)
    if event_type ~= "NftTransferredToBuyer" then
        rollback_saga_instance_respond_original_requester(saga_instance, "Unexpected event type: " .. event_type)
        return
    end

    -- Handle success case - validate and continue (no onSuccess/onFailure callbacks defined)
    if event_data.escrowId ~= context.EscrowId then
        rollback_saga_instance_respond_original_requester(saga_instance, "NFT transfer escrowId mismatch")
        return
    end

    -- Continue with normal flow: execute funds transfer step and setup next waiting state
    local local_steps = { transfer_funds_to_seller }
    local local_commits = {}
    for i = 1, #local_steps, 1 do
        local local_step = local_steps[i]
        local local_status, local_result_or_error, local_commit = pcall((function()
            return local_step(context)
        end))
        if (not local_status) then
            saga.set_instance_compensating(saga_id, 1)()
            -- Execute compensations for previous successful steps:
            -- Local step 1 (transfer_nft_to_buyer) succeeded: return_nft_to_seller
            -- Local step 2 (transfer_funds_to_seller) failed: nil
            -- Business compensation: unlock_escrow_payment
            local pre_local_compensations = { return_nft_to_seller, nil, unlock_escrow_payment }
            -- Then rollback the saga with compensations
            execute_local_compensations_respond_original_requester(saga_instance, context, local_result_or_error,
                pre_local_compensations)
            return
        else
            local_commits[#local_commits + 1] = local_commit
        end
    end

    local commit = saga.move_saga_instance_forward(saga_id, 1 + #local_steps, nil, nil, context)
    local saga_instance_copy = saga.get_saga_instance_copy(saga_id)
    saga_instance_copy.waiting_state = {
        is_waiting = true,
        success_event_type = "FundsTransferredToSeller",
        failure_event_type = nil,
        step_name = "WaitForFundsTransferConfirmation",
        started_at = msg.Timestamp,
        max_wait_time_seconds = 0,
        continuation_handler = nft_escrow_service
            .execute_nft_escrow_transaction_wait_for_funds_transfer_confirmation_callback,
        data_mapping_rules = {},
    }

    local update_commit = function() SagaInstances[saga_id] = saga_instance_copy end
    for _, local_commit in ipairs(local_commits) do
        local_commit()
    end
    commit()
    update_commit()
end

function nft_escrow_service.execute_nft_escrow_transaction_wait_for_funds_transfer_confirmation_callback(saga_id, context,
                                                                                                         event_type,
                                                                                                         event_data, msg)
    -- This function is called when an event is received
    -- Similar to inventory_service callbacks - call onSuccess handler as defined in DDDML YAML
    local saga_instance = saga.get_saga_instance_copy(saga_id)
    if (saga_instance.current_step ~= 7 or saga_instance.compensating) then
        error(ERRORS.INVALID_MESSAGE)
    end
    local context = saga_instance.context

    -- Handle unexpected event types first (like inventory_service handles data.error)
    if event_type ~= "FundsTransferredToSeller" then
        rollback_saga_instance_respond_original_requester(saga_instance, "Unexpected event type: " .. event_type)
        return
    end

    -- Handle success case - validate and complete (no onSuccess/onFailure callbacks defined)
    if event_data.escrowId ~= context.EscrowId then
        rollback_saga_instance_respond_original_requester(saga_instance, "Funds transfer escrowId mismatch")
        return
    end

    -- This is the final step - complete the saga
    local completed_result = { Status = "COMPLETED", EscrowId = context.EscrowId }
    complete_saga_instance_respond_original_requester(saga_instance, completed_result, context)
end

-- Register handlers for service methods
print("ğŸ”§ Registering ExecuteNftEscrowTransaction handler...")
local execute_handler_result = Handlers.add(
    "NftEscrowService_ExecuteNftEscrowTransaction",
    function(msg)
        print("ğŸ” ExecuteNftEscrowTransaction matcher called - Action: " .. tostring(msg.Action))
        local matches = msg.Action == "NftEscrowService_ExecuteNftEscrowTransaction"
        print("ğŸ” Matches: " .. tostring(matches))
        return matches
    end,
    function(msg, env, response)
        print("ğŸ¯ HANDLER TRIGGERED: NftEscrowService_ExecuteNftEscrowTransaction")
        print("ğŸ“‹ Message From: " .. tostring(msg.From) .. ", Target: " .. tostring(msg.Target or ao.id))

        local success, error_msg = pcall(function()
            nft_escrow_service.execute_nft_escrow_transaction(msg, env, response)
        end)
        if not success then
            print("âŒ execute_nft_escrow_transaction failed: " .. error_msg)
        else
            print("âœ… execute_nft_escrow_transaction completed successfully")
        end
    end
)
print("âœ… ExecuteNftEscrowTransaction handler registered: " .. tostring(execute_handler_result))

Handlers.add(
    "NftEscrowService_UseEscrowPayment",
    function(msg)
        return msg.Action == "NftEscrowService_UseEscrowPayment"
    end,
    function(msg, env, response)
        print("ğŸ¯ HANDLER TRIGGERED: NftEscrowService_UseEscrowPayment")
        print("ğŸ“‹ Message From: " .. tostring(msg.From) .. ", Target: " .. tostring(msg.Target or ao.id))

        local success, error_msg = pcall(function()
            nft_escrow_service.use_escrow_payment(msg, env, response)
        end)
        if not success then
            print("âŒ use_escrow_payment failed: " .. error_msg)
        else
            print("âœ… use_escrow_payment completed successfully")
        end
    end
)

-- Register functions globally for direct calling (no return, just set globals)
execute_nft_escrow_transaction = nft_escrow_service.execute_nft_escrow_transaction
use_escrow_payment = nft_escrow_service.use_escrow_payment

print("DEBUG: Basic handler test starting...")

-- Simple handler test
Handlers.add(
    "basic_test",
    function(msg)
        print("ğŸ” BASIC CHECK: Received message with Action='" .. tostring(msg.Action) .. "'")
        return msg.Action == "TestMessage"
    end,
    function(msg, env)
        print("ğŸ‰ BASIC HANDLER: Test message received!")
        print("   Process ID: " .. ao.id)
        print("   Message Action: " .. tostring(msg.Action))
        print("   Message Data: " .. tostring(msg.Data))
    end
)

print("DEBUG: Basic handler registered")

-- Register event listeners for external contract interactions
Handlers.add(
    "nft_transfer_listener",
    function(msg)
        return (msg.Action == "Debit-Notice") and (msg.TokenId or msg.Tokenid or (msg.Tags and (msg.Tags.TokenId or msg.Tags.Tokenid)))
    end,
    function(msg, env)
        local token_id = msg.TokenId or msg.Tokenid or (msg.Tags and (msg.Tags.TokenId or msg.Tags.Tokenid))
        local recipient = msg.Recipient or (msg.Tags and msg.Tags.Recipient) or "unknown"

        -- Find escrow record that matches this token transfer
        local matching_escrow_id = nil
        local escrow_record = nil
        for escrow_id, record in pairs(NftEscrowTable or {}) do
            if (record.token_id == token_id or record.TokenId == token_id) and (record.status == "PAYMENT_LINKED" or record.status == "PENDING") then
                matching_escrow_id = escrow_id
                escrow_record = record
                break
            end
        end

        if matching_escrow_id and escrow_record then
            -- éªŒè¯è½¬ç§»ç›®æ ‡æ˜¯å¦æ­£ç¡®ï¼ˆåº”è¯¥æ˜¯Buyeråœ°å€ï¼‰
            local expected_buyer = escrow_record.buyer_address or escrow_record.BuyerAddress
            if expected_buyer and recipient == expected_buyer then
                -- è§¦å‘NftTransferredToBuyeräº‹ä»¶ï¼Œè®©ç­‰å¾…ä¸­çš„Sagaç»§ç»­
                trigger_waiting_saga_event("NftTransferredToBuyer", {
                    escrowId = matching_escrow_id,
                    tokenId = token_id,
                    buyer = recipient
                })
            end
        end
    end
)

Handlers.add(
    "token_transfer_listener",
    function(msg)
        return (msg.Action == "Debit-Notice") and not (msg.TokenId or msg.Tokenid or (msg.Tags and (msg.Tags.TokenId or msg.Tags.Tokenid)))
    end,
    function(msg, env)
        local recipient = msg.Recipient or (msg.Tags and msg.Tags.Recipient) or "unknown"
        local quantity = msg.Quantity or (msg.Tags and msg.Tags.Quantity) or "0"

        -- Find escrow record that matches this token transfer
        -- The recipient should be the seller, and quantity should match the escrow price
        local matching_escrow_id = nil
        for escrow_id, escrow_record in pairs(NftEscrowTable or {}) do
            if escrow_record.price == quantity and
               (escrow_record.seller_address == recipient or escrow_record.SellerAddress == recipient) then
                matching_escrow_id = escrow_id
                break
            end
        end

        if matching_escrow_id then
            -- è§¦å‘FundsTransferredToSelleräº‹ä»¶ï¼Œè®©ç­‰å¾…ä¸­çš„Sagaç»§ç»­
            trigger_waiting_saga_event("FundsTransferredToSeller", {
                escrowId = matching_escrow_id,
                seller = recipient,
                amount = quantity
            })
        end
    end
)

-- Export functions globally for eval access
_G.nft_escrow_service = nft_escrow_service
_G.execute_nft_escrow_transaction = nft_escrow_service.execute_nft_escrow_transaction
_G.use_escrow_payment = nft_escrow_service.use_escrow_payment

print("DEBUG: Service functions exported to global scope")

-- Initialization function to be called after load
function init_nft_escrow_service()
    print("ğŸ”§ Initializing NFT Escrow Service...")

    -- Re-export functions if needed
    _G.nft_escrow_service = nft_escrow_service
    _G.execute_nft_escrow_transaction = nft_escrow_service.execute_nft_escrow_transaction
    _G.use_escrow_payment = nft_escrow_service.use_escrow_payment

    -- Test internal message
    Send({
        Target = ao.id,
        Action = "SelfPing",
        Data = "service initialized"
    })

    print("âœ… NFT Escrow Service initialized")
    return "SERVICE_INITIALIZED"
end

-- Test internal message sending
Send({
    Target = ao.id,
    Action = "SelfPing",
    Data = "internal test"
})

-- Add simple ping handler to test message reception
Handlers.add(
    "self_ping_handler",
    function(msg)
        return msg.Action == "SelfPing"
    end,
    function(msg, env)
        print("ğŸ”„ SELF-PING: Internal message received in process " .. ao.id)
    end
)

Handlers.add(
    "ping_handler",
    function(msg)
        return msg.Action == "Ping"
    end,
    function(msg, env)
        print("ğŸ“ PING RECEIVED: Process " .. ao.id .. " is alive")
        Send({
            Target = msg.From,
            Action = "Pong",
            Data = "Process " .. ao.id .. " responds to ping"
        })
    end
)

print("DEBUG: Catch-all handler registered")
