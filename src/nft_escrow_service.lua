-- <autogenerated>
--   This file was generated by dddappp code generator.
--   Any changes made to this file manually will be lost next time the file is regenerated.
-- </autogenerated>

local json = require("json")
local messaging = require("messaging")
local saga = require("saga")
local saga_messaging = require("saga_messaging")
local nft_escrow_service_local = require("nft_escrow_service_local")

local execute_local_compensations_respond_original_requester = saga_messaging
    .execute_local_compensations_respond_original_requester
local rollback_saga_instance_respond_original_requester = saga_messaging
    .rollback_saga_instance_respond_original_requester
local complete_saga_instance_respond_original_requester = saga_messaging
    .complete_saga_instance_respond_original_requester
local execute_local_compensations = saga_messaging.execute_local_compensations

local create_nft_escrow_record =
    nft_escrow_service_local.create_nft_escrow_record
local transfer_nft_to_buyer =
    nft_escrow_service_local.transfer_nft_to_buyer
local transfer_funds_to_seller =
    nft_escrow_service_local.transfer_funds_to_seller
local use_escrow_payment =
    nft_escrow_service_local.use_escrow_payment
local return_nft_to_seller =
    nft_escrow_service_local.return_nft_to_seller
local unlock_escrow_payment =
    nft_escrow_service_local.unlock_escrow_payment

local nft_escrow_service = {}


local ERRORS = {
    INVALID_MESSAGE = "INVALID_MESSAGE",
    COMPENSATION_FAILED = "COMPENSATION_FAILED",
}

nft_escrow_service.ERRORS = ERRORS

local ACTIONS = {
    USE_ESCROW_PAYMENT =
    "NftEscrowService_UseEscrowPayment",
    EXECUTE_NFT_ESCROW_TRANSACTION =
    "NftEscrowService_ExecuteNftEscrowTransaction",
}

nft_escrow_service.ACTIONS = ACTIONS

-- required components
local nft_escrow_service_config = require("nft_escrow_service_config")

-- TODO 因为当前文件应该是完全 AutoGenerated 的，所以这里的方法应该调用 nft_escrow_service_local 中的方法.
--   nft_escrow_service_local 文件是工具生成了脚手架代码，但是可以修改的。
function nft_escrow_service.use_escrow_payment(msg, env, response)
    local cmd = json.decode(msg.Data)

    local status, result_or_error, commit = pcall((function()
        return use_escrow_payment(cmd)
    end))

    if not status then
        messaging.process_operation_result(false, result_or_error, function() end, msg)
        return
    end

    -- Execute the commit function returned by the local implementation
    local commit_status, commit_error = pcall(commit)
    if not commit_status then
        messaging.process_operation_result(false, commit_error, function() end, msg)
        return
    end

    messaging.process_operation_result(true, "Payment applied successfully", function() end, msg)
end

-- TODO 因为当前文件应该是完全 AutoGenerated 的，所以这里的方法应该调用 nft_escrow_service_local 中的方法。
--   nft_escrow_service_local 文件是工具生成了脚手架代码，但是可以修改的。


function nft_escrow_service.execute_nft_escrow_transaction(msg, env, response)
    local cmd = json.decode(msg.Data)

    local context = cmd
    context.Timestamp = msg.Timestamp -- Add timestamp to context for AO environment

    local local_steps = {
        create_nft_escrow_record,
    }
    local local_commits = {}
    for i = 1, #local_steps, 1 do
        local local_step = local_steps[i]
        local local_status, local_result_or_error, local_commit = pcall((function()
            return local_step(context)
        end))
        if (not local_status) then
            messaging.process_operation_result(false, local_result_or_error, function() end, msg)
            return
        else
            local_commits[#local_commits + 1] = local_commit
        end
    end

    -- This is the first step, create saga instance first.
    local original_message = messaging.extract_reply_context(msg)
    local saga_instance, commit = saga.create_saga_instance(ACTIONS.EXECUTE_NFT_ESCROW_TRANSACTION, nil, -- no target for local wait
        nil,                                                                                             -- no tags for local wait
        context,
        original_message,
        #local_steps
    )
    local saga_id = saga_instance.saga_id
    commit() -- must commit here to save the saga instance
    local commit = saga.move_saga_instance_forward(saga_id, 1 + #local_steps, nil, nil, context)

    local saga_instance = saga.get_saga_instance_copy(saga_id)
    saga_instance.waiting_state = {
        is_waiting = true,
        success_event_type = "NftDeposited",
        failure_event_type = nil,
        step_name = "WaitForNftDeposit",
        started_at = msg.Timestamp,       -- Use AO message timestamp (already in milliseconds)
        max_wait_time_seconds = 86400000, -- 24 hours in milliseconds
        continuation_handler = nft_escrow_service.execute_nft_escrow_transaction_wait_for_nft_deposit_callback,
        data_mapping_rules = {
        },
    }
    local update_commit = function() SagaInstances[saga_id] = saga_instance end

    local total_commit = function()
        commit()
        update_commit()
    end
    total_commit()
end

-- TODO 参考下面其他 wait_for_*_callback 函数的修改说明（注释）
function nft_escrow_service.execute_nft_escrow_transaction_wait_for_nft_deposit_callback(saga_id, context, event_type,
                                                                                         event_data, msg)
    -- This function is called when an event is received
    -- Similar to inventory_service callbacks - call onSuccess/onFailure handlers like DDDML defines
    local saga_instance = saga.get_saga_instance_copy(saga_id)
    if (saga_instance.current_step ~= 2 or saga_instance.compensating) then
        error(ERRORS.INVALID_MESSAGE)
    end
    local context = saga_instance.context

    -- Handle failure events first (like inventory_service handles data.error)
    if event_type ~= "NftDeposited" then
        -- onFailure: No return value specification - must execute compensation flow
        nft_escrow_service_local.process_nft_deposit_on_failure(context, event_data)
        -- onFailure cannot be ignored - immediately rollback and trigger compensation
        rollback_saga_instance_respond_original_requester(saga_instance, "NFT deposit failure event received")
        return
    end

    -- Handle success case (like inventory_service continues after error check)
    -- onSuccess: Returns (short_circuited, is_error, result_or_error) like onReply
    local short_circuited, is_error, result_or_error = nft_escrow_service_local.process_nft_deposit_on_success(context,
        event_data)

    -- Handle short-circuit cases like inventory_service does
    if short_circuited then
        if not is_error then
            complete_saga_instance_respond_original_requester(saga_instance, result_or_error, context)
        else
            rollback_saga_instance_respond_original_requester(saga_instance, result_or_error)
        end
        return
    end

    -- Continue with normal saga flow
    local commit = saga.move_saga_instance_forward(saga_id, 1, nil, nil, context)

    local saga_instance_copy = saga.get_saga_instance_copy(saga_id)
    saga_instance_copy.waiting_state = {
        is_waiting = true,
        success_event_type = "EscrowPaymentUsed",
        failure_event_type = nil,
        step_name = "WaitForPayment",
        started_at = msg.Timestamp,
        max_wait_time_seconds = 3600000,
        continuation_handler = nft_escrow_service.execute_nft_escrow_transaction_wait_for_payment_callback,
        data_mapping_rules = {},
    }

    -- Commit both the move forward and the waiting state setup
    local update_commit = function() SagaInstances[saga_id] = saga_instance_copy end
    commit()
    update_commit()
end

function nft_escrow_service.execute_nft_escrow_transaction_wait_for_payment_callback(saga_id, context, event_type,
                                                                                     event_data, msg)
    -- This function is called when an event is received
    -- Similar to inventory_service callbacks - call onSuccess handler as defined in DDDML YAML
    local saga_instance = saga.get_saga_instance_copy(saga_id)
    if (saga_instance.current_step ~= 3 or saga_instance.compensating) then
        error(ERRORS.INVALID_MESSAGE)
    end
    local context = saga_instance.context

    -- Handle unexpected event types first
    if event_type ~= "EscrowPaymentUsed" then
        rollback_saga_instance_respond_original_requester(saga_instance, "Unexpected event type: " .. event_type)
        return
    end

    -- Handle success case - validate and continue (no onSuccess/onFailure callbacks defined)
    if event_data.escrowId ~= context.EscrowId then
        rollback_saga_instance_respond_original_requester(saga_instance, "Payment escrowId mismatch")
        return
    end

    -- Update context with buyer address from payment
    context.BuyerAddress = event_data.buyerAddress

    -- Continue with normal flow: execute NFT transfer step and setup next waiting state
    local local_steps = { transfer_nft_to_buyer }
    local local_commits = {}
    for i = 1, #local_steps, 1 do
        local local_step = local_steps[i]
        local local_status, local_result_or_error, local_commit = pcall((function()
            return local_step(context)
        end))
        if (not local_status) then
            saga.set_instance_compensating(saga_id, 1)()
            -- Execute compensation for WaitForPayment step:
            -- Local step 1 (transfer_nft_to_buyer) failed: nil
            -- Business compensation: unlock_escrow_payment
            local pre_local_compensations = { nil, unlock_escrow_payment }
            -- Then rollback the saga with compensations
            execute_local_compensations_respond_original_requester(saga_instance, context, local_result_or_error,
                pre_local_compensations)
            return
        else
            local_commits[#local_commits + 1] = local_commit
        end
    end

    local commit = saga.move_saga_instance_forward(saga_id, 1 + #local_steps, nil, nil, context)
    local saga_instance_copy = saga.get_saga_instance_copy(saga_id)
    saga_instance_copy.waiting_state = {
        is_waiting = true,
        success_event_type = "NftTransferredToBuyer",
        failure_event_type = nil,
        step_name = "WaitForNftTransferConfirmation",
        started_at = msg.Timestamp,
        max_wait_time_seconds = 300000,
        continuation_handler = nft_escrow_service
            .execute_nft_escrow_transaction_wait_for_nft_transfer_confirmation_callback,
        data_mapping_rules = {},
    }

    local update_commit = function() SagaInstances[saga_id] = saga_instance_copy end
    for _, local_commit in ipairs(local_commits) do
        local_commit()
    end
    commit()
    update_commit()
end

-- todo 这个函数的行为应该和 inventory_service.process_inventory_surplus_or_shortage_get_inventory_item_callback 这类方法类似。
--   不同之处只是 inventory_service.process_inventory_surplus_or_shortage_get_inventory_item_callback 这样的方法是外部的消息触发执行的，而这里是本地的 saga 实例内部触发的。
--   外部消息触发执行的时候，也会有成功或失败的情形，和内部事件（内部事件也有可能是成功事件或失败事件）触发其他类似。所以这里的处理流程应该是大同小异的。
function nft_escrow_service.execute_nft_escrow_transaction_wait_for_nft_transfer_confirmation_callback(saga_id, context,
                                                                                                       event_type,
                                                                                                       event_data, msg)
    -- This function is called when an event is received
    -- Similar to inventory_service callbacks - handle errors first, then normal flow
    local saga_instance = saga.get_saga_instance_copy(saga_id)
    if (saga_instance.current_step ~= 5 or saga_instance.compensating) then
        error(ERRORS.INVALID_MESSAGE)
    end
    local context = saga_instance.context

    -- Handle unexpected event types first (like inventory_service handles data.error)
    if event_type ~= "NftTransferredToBuyer" then
        rollback_saga_instance_respond_original_requester(saga_instance, "Unexpected event type: " .. event_type)
        return
    end

    -- Handle success case - validate and continue (no onSuccess/onFailure callbacks defined)
    if event_data.escrowId ~= context.EscrowId then
        rollback_saga_instance_respond_original_requester(saga_instance, "NFT transfer escrowId mismatch")
        return
    end

    -- Continue with normal flow: execute funds transfer step and setup next waiting state
    local local_steps = { transfer_funds_to_seller }
    local local_commits = {}
    for i = 1, #local_steps, 1 do
        local local_step = local_steps[i]
        local local_status, local_result_or_error, local_commit = pcall((function()
            return local_step(context)
        end))
        if (not local_status) then
            saga.set_instance_compensating(saga_id, 1)()
            -- Execute compensations for previous successful steps:
            -- Local step 1 (transfer_nft_to_buyer) succeeded: return_nft_to_seller
            -- Local step 2 (transfer_funds_to_seller) failed: nil
            -- Business compensation: unlock_escrow_payment
            local pre_local_compensations = { return_nft_to_seller, nil, unlock_escrow_payment }
            -- Then rollback the saga with compensations
            execute_local_compensations_respond_original_requester(saga_instance, context, local_result_or_error,
                pre_local_compensations)
            return
        else
            local_commits[#local_commits + 1] = local_commit
        end
    end

    local commit = saga.move_saga_instance_forward(saga_id, 1 + #local_steps, nil, nil, context)
    local saga_instance_copy = saga.get_saga_instance_copy(saga_id)
    saga_instance_copy.waiting_state = {
        is_waiting = true,
        success_event_type = "FundsTransferredToSeller",
        failure_event_type = nil,
        step_name = "WaitForFundsTransferConfirmation",
        started_at = msg.Timestamp,
        max_wait_time_seconds = 0,
        continuation_handler = nft_escrow_service
            .execute_nft_escrow_transaction_wait_for_funds_transfer_confirmation_callback,
        data_mapping_rules = {},
    }

    local update_commit = function() SagaInstances[saga_id] = saga_instance_copy end
    for _, local_commit in ipairs(local_commits) do
        local_commit()
    end
    commit()
    update_commit()
end

function nft_escrow_service.execute_nft_escrow_transaction_wait_for_funds_transfer_confirmation_callback(saga_id, context,
                                                                                                         event_type,
                                                                                                         event_data, msg)
    -- This function is called when an event is received
    -- Similar to inventory_service callbacks - call onSuccess handler as defined in DDDML YAML
    local saga_instance = saga.get_saga_instance_copy(saga_id)
    if (saga_instance.current_step ~= 7 or saga_instance.compensating) then
        error(ERRORS.INVALID_MESSAGE)
    end
    local context = saga_instance.context

    -- Handle unexpected event types first (like inventory_service handles data.error)
    if event_type ~= "FundsTransferredToSeller" then
        rollback_saga_instance_respond_original_requester(saga_instance, "Unexpected event type: " .. event_type)
        return
    end

    -- Handle success case - validate and complete (no onSuccess/onFailure callbacks defined)
    if event_data.escrowId ~= context.EscrowId then
        rollback_saga_instance_respond_original_requester(saga_instance, "Funds transfer escrowId mismatch")
        return
    end

    -- This is the final step - complete the saga
    local completed_result = { Status = "COMPLETED", EscrowId = context.EscrowId }
    complete_saga_instance_respond_original_requester(saga_instance, completed_result, context)
end

return nft_escrow_service
